// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow, TaggedUnion};

#[allow(unused_imports, dead_code)]
pub mod dataformat {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow, TaggedUnion};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SDXOR_SDG: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SDXOR_SDG: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SDXOR_SDG: [SDxorSDG; 3] = [
  SDxorSDG::NONE,
  SDxorSDG::SD,
  SDxorSDG::SDG,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SDxorSDG(pub u8);
#[allow(non_upper_case_globals)]
impl SDxorSDG {
  pub const NONE: Self = Self(0);
  pub const SD: Self = Self(1);
  pub const SDG: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SD,
    Self::SDG,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SD => Some("SD"),
      Self::SDG => Some("SDG"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_sd(
    o: flatbuffers::WIPOffset<SD>,
  ) -> flatbuffers::UnionWIPOffset<SDxorSDGUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::SD, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_sdg(
    o: flatbuffers::WIPOffset<SDG>,
  ) -> flatbuffers::UnionWIPOffset<SDxorSDGUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::SDG, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for SDxorSDG {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SDxorSDG {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SDxorSDG {
    type Output = SDxorSDG;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SDxorSDG {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SDxorSDG {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SDxorSDG {}

impl From<SDxorSDG> for u8 {
  #[inline]
  fn from(v: SDxorSDG) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for SDxorSDG {
  type VectorBuilder = SDxorSDGVectorBuilder<'a, 'b>;
}

pub struct SDxorSDGVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> SDxorSDGVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<SDxorSDGUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, SDxorSDGUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_sd(&mut self, o: flatbuffers::WIPOffset<SD>) {
    self.fbb.push_union_vector_item(SDxorSDG::tag_as_sd(o));
  }

  #[inline]
  pub fn push_as_sdg(&mut self, o: flatbuffers::WIPOffset<SDG>) {
    self.fbb.push_union_vector_item(SDxorSDG::tag_as_sdg(o));
  }

}

pub struct SDxorSDGUnionValue {}

impl flatbuffers::TaggedUnion for SDxorSDGUnionValue {
  type Tag = SDxorSDG;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for SDxorSDGUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      SDxorSDG::SD => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<SD>>(
          "SDxorSDG::SD",
          pos,
        ),
      SDxorSDG::SDG => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<SDG>>(
          "SDxorSDG::SDG",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIAG_CODED_TYPE_NAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIAG_CODED_TYPE_NAME: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIAG_CODED_TYPE_NAME: [DiagCodedTypeName; 4] = [
  DiagCodedTypeName::LEADING_LENGTH_INFO_TYPE,
  DiagCodedTypeName::MIN_MAX_LENGTH_TYPE,
  DiagCodedTypeName::PARAM_LENGTH_INFO_TYPE,
  DiagCodedTypeName::STANDARD_LENGTH_TYPE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DiagCodedTypeName(pub i8);
#[allow(non_upper_case_globals)]
impl DiagCodedTypeName {
  pub const LEADING_LENGTH_INFO_TYPE: Self = Self(0);
  pub const MIN_MAX_LENGTH_TYPE: Self = Self(1);
  pub const PARAM_LENGTH_INFO_TYPE: Self = Self(2);
  pub const STANDARD_LENGTH_TYPE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEADING_LENGTH_INFO_TYPE,
    Self::MIN_MAX_LENGTH_TYPE,
    Self::PARAM_LENGTH_INFO_TYPE,
    Self::STANDARD_LENGTH_TYPE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEADING_LENGTH_INFO_TYPE => Some("LEADING_LENGTH_INFO_TYPE"),
      Self::MIN_MAX_LENGTH_TYPE => Some("MIN_MAX_LENGTH_TYPE"),
      Self::PARAM_LENGTH_INFO_TYPE => Some("PARAM_LENGTH_INFO_TYPE"),
      Self::STANDARD_LENGTH_TYPE => Some("STANDARD_LENGTH_TYPE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DiagCodedTypeName {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DiagCodedTypeName {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DiagCodedTypeName {
    type Output = DiagCodedTypeName;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DiagCodedTypeName {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DiagCodedTypeName {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DiagCodedTypeName {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TERMINATION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TERMINATION: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TERMINATION: [Termination; 3] = [
  Termination::END_OF_PDU,
  Termination::ZERO,
  Termination::HEX_FF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Termination(pub i8);
#[allow(non_upper_case_globals)]
impl Termination {
  pub const END_OF_PDU: Self = Self(0);
  pub const ZERO: Self = Self(1);
  pub const HEX_FF: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::END_OF_PDU,
    Self::ZERO,
    Self::HEX_FF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::END_OF_PDU => Some("END_OF_PDU"),
      Self::ZERO => Some("ZERO"),
      Self::HEX_FF => Some("HEX_FF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Termination {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Termination {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for Termination {
    type Output = Termination;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Termination {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Termination {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Termination {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 8] = [
  DataType::A_INT_32,
  DataType::A_UINT_32,
  DataType::A_FLOAT_32,
  DataType::A_ASCIISTRING,
  DataType::A_UTF_8_STRING,
  DataType::A_UNICODE_2_STRING,
  DataType::A_BYTEFIELD,
  DataType::A_FLOAT_64,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i8);
#[allow(non_upper_case_globals)]
impl DataType {
  pub const A_INT_32: Self = Self(0);
  pub const A_UINT_32: Self = Self(1);
  pub const A_FLOAT_32: Self = Self(2);
  pub const A_ASCIISTRING: Self = Self(3);
  pub const A_UTF_8_STRING: Self = Self(4);
  pub const A_UNICODE_2_STRING: Self = Self(5);
  pub const A_BYTEFIELD: Self = Self(6);
  pub const A_FLOAT_64: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::A_INT_32,
    Self::A_UINT_32,
    Self::A_FLOAT_32,
    Self::A_ASCIISTRING,
    Self::A_UTF_8_STRING,
    Self::A_UNICODE_2_STRING,
    Self::A_BYTEFIELD,
    Self::A_FLOAT_64,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::A_INT_32 => Some("A_INT_32"),
      Self::A_UINT_32 => Some("A_UINT_32"),
      Self::A_FLOAT_32 => Some("A_FLOAT_32"),
      Self::A_ASCIISTRING => Some("A_ASCIISTRING"),
      Self::A_UTF_8_STRING => Some("A_UTF_8_STRING"),
      Self::A_UNICODE_2_STRING => Some("A_UNICODE_2_STRING"),
      Self::A_BYTEFIELD => Some("A_BYTEFIELD"),
      Self::A_FLOAT_64 => Some("A_FLOAT_64"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DataType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPECIFIC_DATA_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPECIFIC_DATA_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPECIFIC_DATA_TYPE: [SpecificDataType; 5] = [
  SpecificDataType::NONE,
  SpecificDataType::LeadingLengthInfoType,
  SpecificDataType::MinMaxLengthType,
  SpecificDataType::ParamLengthInfoType,
  SpecificDataType::StandardLengthType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpecificDataType(pub u8);
#[allow(non_upper_case_globals)]
impl SpecificDataType {
  pub const NONE: Self = Self(0);
  pub const LeadingLengthInfoType: Self = Self(1);
  pub const MinMaxLengthType: Self = Self(2);
  pub const ParamLengthInfoType: Self = Self(3);
  pub const StandardLengthType: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::LeadingLengthInfoType,
    Self::MinMaxLengthType,
    Self::ParamLengthInfoType,
    Self::StandardLengthType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::LeadingLengthInfoType => Some("LeadingLengthInfoType"),
      Self::MinMaxLengthType => Some("MinMaxLengthType"),
      Self::ParamLengthInfoType => Some("ParamLengthInfoType"),
      Self::StandardLengthType => Some("StandardLengthType"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_leading_length_info_type(
    o: flatbuffers::WIPOffset<LeadingLengthInfoType>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDataTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::LeadingLengthInfoType, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_min_max_length_type(
    o: flatbuffers::WIPOffset<MinMaxLengthType>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDataTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::MinMaxLengthType, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_param_length_info_type(
    o: flatbuffers::WIPOffset<ParamLengthInfoType>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDataTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::ParamLengthInfoType, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_standard_length_type(
    o: flatbuffers::WIPOffset<StandardLengthType>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDataTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::StandardLengthType, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for SpecificDataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpecificDataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SpecificDataType {
    type Output = SpecificDataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SpecificDataType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpecificDataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpecificDataType {}

impl From<SpecificDataType> for u8 {
  #[inline]
  fn from(v: SpecificDataType) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for SpecificDataType {
  type VectorBuilder = SpecificDataTypeVectorBuilder<'a, 'b>;
}

pub struct SpecificDataTypeVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> SpecificDataTypeVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<SpecificDataTypeUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, SpecificDataTypeUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_leading_length_info_type(&mut self, o: flatbuffers::WIPOffset<LeadingLengthInfoType>) {
    self.fbb.push_union_vector_item(SpecificDataType::tag_as_leading_length_info_type(o));
  }

  #[inline]
  pub fn push_as_min_max_length_type(&mut self, o: flatbuffers::WIPOffset<MinMaxLengthType>) {
    self.fbb.push_union_vector_item(SpecificDataType::tag_as_min_max_length_type(o));
  }

  #[inline]
  pub fn push_as_param_length_info_type(&mut self, o: flatbuffers::WIPOffset<ParamLengthInfoType>) {
    self.fbb.push_union_vector_item(SpecificDataType::tag_as_param_length_info_type(o));
  }

  #[inline]
  pub fn push_as_standard_length_type(&mut self, o: flatbuffers::WIPOffset<StandardLengthType>) {
    self.fbb.push_union_vector_item(SpecificDataType::tag_as_standard_length_type(o));
  }

}

pub struct SpecificDataTypeUnionValue {}

impl flatbuffers::TaggedUnion for SpecificDataTypeUnionValue {
  type Tag = SpecificDataType;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for SpecificDataTypeUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      SpecificDataType::LeadingLengthInfoType => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<LeadingLengthInfoType>>(
          "SpecificDataType::LeadingLengthInfoType",
          pos,
        ),
      SpecificDataType::MinMaxLengthType => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<MinMaxLengthType>>(
          "SpecificDataType::MinMaxLengthType",
          pos,
        ),
      SpecificDataType::ParamLengthInfoType => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<ParamLengthInfoType>>(
          "SpecificDataType::ParamLengthInfoType",
          pos,
        ),
      SpecificDataType::StandardLengthType => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<StandardLengthType>>(
          "SpecificDataType::StandardLengthType",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERVAL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERVAL_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERVAL_TYPE: [IntervalType; 3] = [
  IntervalType::OPEN,
  IntervalType::CLOSED,
  IntervalType::INFINITE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IntervalType(pub i8);
#[allow(non_upper_case_globals)]
impl IntervalType {
  pub const OPEN: Self = Self(0);
  pub const CLOSED: Self = Self(1);
  pub const INFINITE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPEN,
    Self::CLOSED,
    Self::INFINITE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPEN => Some("OPEN"),
      Self::CLOSED => Some("CLOSED"),
      Self::INFINITE => Some("INFINITE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IntervalType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IntervalType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for IntervalType {
    type Output = IntervalType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for IntervalType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IntervalType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IntervalType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMPU_CATEGORY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMPU_CATEGORY: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPU_CATEGORY: [CompuCategory; 8] = [
  CompuCategory::IDENTICAL,
  CompuCategory::LINEAR,
  CompuCategory::SCALE_LINEAR,
  CompuCategory::TEXT_TABLE,
  CompuCategory::COMPU_CODE,
  CompuCategory::TAB_INTP,
  CompuCategory::RAT_FUNC,
  CompuCategory::SCALE_RAT_FUNC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CompuCategory(pub i8);
#[allow(non_upper_case_globals)]
impl CompuCategory {
  pub const IDENTICAL: Self = Self(0);
  pub const LINEAR: Self = Self(1);
  pub const SCALE_LINEAR: Self = Self(2);
  pub const TEXT_TABLE: Self = Self(3);
  pub const COMPU_CODE: Self = Self(4);
  pub const TAB_INTP: Self = Self(5);
  pub const RAT_FUNC: Self = Self(6);
  pub const SCALE_RAT_FUNC: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IDENTICAL,
    Self::LINEAR,
    Self::SCALE_LINEAR,
    Self::TEXT_TABLE,
    Self::COMPU_CODE,
    Self::TAB_INTP,
    Self::RAT_FUNC,
    Self::SCALE_RAT_FUNC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::IDENTICAL => Some("IDENTICAL"),
      Self::LINEAR => Some("LINEAR"),
      Self::SCALE_LINEAR => Some("SCALE_LINEAR"),
      Self::TEXT_TABLE => Some("TEXT_TABLE"),
      Self::COMPU_CODE => Some("COMPU_CODE"),
      Self::TAB_INTP => Some("TAB_INTP"),
      Self::RAT_FUNC => Some("RAT_FUNC"),
      Self::SCALE_RAT_FUNC => Some("SCALE_RAT_FUNC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CompuCategory {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CompuCategory {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for CompuCategory {
    type Output = CompuCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for CompuCategory {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CompuCategory {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CompuCategory {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PHYSICAL_TYPE_DATA_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PHYSICAL_TYPE_DATA_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PHYSICAL_TYPE_DATA_TYPE: [PhysicalTypeDataType; 8] = [
  PhysicalTypeDataType::A_INT_32,
  PhysicalTypeDataType::A_UINT_32,
  PhysicalTypeDataType::A_FLOAT_32,
  PhysicalTypeDataType::A_ASCIISTRING,
  PhysicalTypeDataType::A_UTF_8_STRING,
  PhysicalTypeDataType::A_UNICODE_2_STRING,
  PhysicalTypeDataType::A_BYTEFIELD,
  PhysicalTypeDataType::A_FLOAT_64,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PhysicalTypeDataType(pub i8);
#[allow(non_upper_case_globals)]
impl PhysicalTypeDataType {
  pub const A_INT_32: Self = Self(0);
  pub const A_UINT_32: Self = Self(1);
  pub const A_FLOAT_32: Self = Self(2);
  pub const A_ASCIISTRING: Self = Self(3);
  pub const A_UTF_8_STRING: Self = Self(4);
  pub const A_UNICODE_2_STRING: Self = Self(5);
  pub const A_BYTEFIELD: Self = Self(6);
  pub const A_FLOAT_64: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::A_INT_32,
    Self::A_UINT_32,
    Self::A_FLOAT_32,
    Self::A_ASCIISTRING,
    Self::A_UTF_8_STRING,
    Self::A_UNICODE_2_STRING,
    Self::A_BYTEFIELD,
    Self::A_FLOAT_64,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::A_INT_32 => Some("A_INT_32"),
      Self::A_UINT_32 => Some("A_UINT_32"),
      Self::A_FLOAT_32 => Some("A_FLOAT_32"),
      Self::A_ASCIISTRING => Some("A_ASCIISTRING"),
      Self::A_UTF_8_STRING => Some("A_UTF_8_STRING"),
      Self::A_UNICODE_2_STRING => Some("A_UNICODE_2_STRING"),
      Self::A_BYTEFIELD => Some("A_BYTEFIELD"),
      Self::A_FLOAT_64 => Some("A_FLOAT_64"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PhysicalTypeDataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PhysicalTypeDataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for PhysicalTypeDataType {
    type Output = PhysicalTypeDataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for PhysicalTypeDataType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PhysicalTypeDataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PhysicalTypeDataType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RADIX: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RADIX: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RADIX: [Radix; 4] = [
  Radix::HEX,
  Radix::DEC,
  Radix::BIN,
  Radix::OCT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Radix(pub i8);
#[allow(non_upper_case_globals)]
impl Radix {
  pub const HEX: Self = Self(0);
  pub const DEC: Self = Self(1);
  pub const BIN: Self = Self(2);
  pub const OCT: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HEX,
    Self::DEC,
    Self::BIN,
    Self::OCT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HEX => Some("HEX"),
      Self::DEC => Some("DEC"),
      Self::BIN => Some("BIN"),
      Self::OCT => Some("OCT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Radix {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Radix {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for Radix {
    type Output = Radix;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Radix {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Radix {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Radix {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALID_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALID_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALID_TYPE: [ValidType; 4] = [
  ValidType::VALID,
  ValidType::NOT_VALID,
  ValidType::NOT_DEFINED,
  ValidType::NOT_AVAILABLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ValidType(pub i8);
#[allow(non_upper_case_globals)]
impl ValidType {
  pub const VALID: Self = Self(0);
  pub const NOT_VALID: Self = Self(1);
  pub const NOT_DEFINED: Self = Self(2);
  pub const NOT_AVAILABLE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::VALID,
    Self::NOT_VALID,
    Self::NOT_DEFINED,
    Self::NOT_AVAILABLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::VALID => Some("VALID"),
      Self::NOT_VALID => Some("NOT_VALID"),
      Self::NOT_DEFINED => Some("NOT_DEFINED"),
      Self::NOT_AVAILABLE => Some("NOT_AVAILABLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ValidType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ValidType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ValidType {
    type Output = ValidType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ValidType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ValidType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ValidType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DOPTYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DOPTYPE: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DOPTYPE: [DOPType; 10] = [
  DOPType::REGULAR,
  DOPType::ENV_DATA_DESC,
  DOPType::MUX,
  DOPType::DYNAMIC_END_MARKER_FIELD,
  DOPType::DYNAMIC_LENGTH_FIELD,
  DOPType::END_OF_PDU_FIELD,
  DOPType::STATIC_FIELD,
  DOPType::ENV_DATA,
  DOPType::STRUCTURE,
  DOPType::DTC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DOPType(pub i8);
#[allow(non_upper_case_globals)]
impl DOPType {
  pub const REGULAR: Self = Self(0);
  pub const ENV_DATA_DESC: Self = Self(1);
  pub const MUX: Self = Self(2);
  pub const DYNAMIC_END_MARKER_FIELD: Self = Self(3);
  pub const DYNAMIC_LENGTH_FIELD: Self = Self(4);
  pub const END_OF_PDU_FIELD: Self = Self(5);
  pub const STATIC_FIELD: Self = Self(6);
  pub const ENV_DATA: Self = Self(7);
  pub const STRUCTURE: Self = Self(8);
  pub const DTC: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REGULAR,
    Self::ENV_DATA_DESC,
    Self::MUX,
    Self::DYNAMIC_END_MARKER_FIELD,
    Self::DYNAMIC_LENGTH_FIELD,
    Self::END_OF_PDU_FIELD,
    Self::STATIC_FIELD,
    Self::ENV_DATA,
    Self::STRUCTURE,
    Self::DTC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REGULAR => Some("REGULAR"),
      Self::ENV_DATA_DESC => Some("ENV_DATA_DESC"),
      Self::MUX => Some("MUX"),
      Self::DYNAMIC_END_MARKER_FIELD => Some("DYNAMIC_END_MARKER_FIELD"),
      Self::DYNAMIC_LENGTH_FIELD => Some("DYNAMIC_LENGTH_FIELD"),
      Self::END_OF_PDU_FIELD => Some("END_OF_PDU_FIELD"),
      Self::STATIC_FIELD => Some("STATIC_FIELD"),
      Self::ENV_DATA => Some("ENV_DATA"),
      Self::STRUCTURE => Some("STRUCTURE"),
      Self::DTC => Some("DTC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DOPType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DOPType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DOPType {
    type Output = DOPType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DOPType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DOPType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DOPType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPECIFIC_DOPDATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPECIFIC_DOPDATA: u8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPECIFIC_DOPDATA: [SpecificDOPData; 10] = [
  SpecificDOPData::NONE,
  SpecificDOPData::NormalDOP,
  SpecificDOPData::EndOfPduField,
  SpecificDOPData::StaticField,
  SpecificDOPData::EnvDataDesc,
  SpecificDOPData::EnvData,
  SpecificDOPData::DTCDOP,
  SpecificDOPData::Structure,
  SpecificDOPData::MUXDOP,
  SpecificDOPData::DynamicLengthField,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpecificDOPData(pub u8);
#[allow(non_upper_case_globals)]
impl SpecificDOPData {
  pub const NONE: Self = Self(0);
  pub const NormalDOP: Self = Self(1);
  pub const EndOfPduField: Self = Self(2);
  pub const StaticField: Self = Self(3);
  pub const EnvDataDesc: Self = Self(4);
  pub const EnvData: Self = Self(5);
  pub const DTCDOP: Self = Self(6);
  pub const Structure: Self = Self(7);
  pub const MUXDOP: Self = Self(8);
  pub const DynamicLengthField: Self = Self(9);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::NormalDOP,
    Self::EndOfPduField,
    Self::StaticField,
    Self::EnvDataDesc,
    Self::EnvData,
    Self::DTCDOP,
    Self::Structure,
    Self::MUXDOP,
    Self::DynamicLengthField,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::NormalDOP => Some("NormalDOP"),
      Self::EndOfPduField => Some("EndOfPduField"),
      Self::StaticField => Some("StaticField"),
      Self::EnvDataDesc => Some("EnvDataDesc"),
      Self::EnvData => Some("EnvData"),
      Self::DTCDOP => Some("DTCDOP"),
      Self::Structure => Some("Structure"),
      Self::MUXDOP => Some("MUXDOP"),
      Self::DynamicLengthField => Some("DynamicLengthField"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_normal_dop(
    o: flatbuffers::WIPOffset<NormalDOP>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::NormalDOP, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_end_of_pdu_field(
    o: flatbuffers::WIPOffset<EndOfPduField>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::EndOfPduField, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_static_field(
    o: flatbuffers::WIPOffset<StaticField>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::StaticField, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_env_data_desc(
    o: flatbuffers::WIPOffset<EnvDataDesc>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::EnvDataDesc, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_env_data(
    o: flatbuffers::WIPOffset<EnvData>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::EnvData, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_dtcdop(
    o: flatbuffers::WIPOffset<DTCDOP>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::DTCDOP, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_structure(
    o: flatbuffers::WIPOffset<Structure>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Structure, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_muxdop(
    o: flatbuffers::WIPOffset<MUXDOP>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::MUXDOP, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_dynamic_length_field(
    o: flatbuffers::WIPOffset<DynamicLengthField>,
  ) -> flatbuffers::UnionWIPOffset<SpecificDOPDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::DynamicLengthField, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for SpecificDOPData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpecificDOPData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SpecificDOPData {
    type Output = SpecificDOPData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SpecificDOPData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpecificDOPData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpecificDOPData {}

impl From<SpecificDOPData> for u8 {
  #[inline]
  fn from(v: SpecificDOPData) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for SpecificDOPData {
  type VectorBuilder = SpecificDOPDataVectorBuilder<'a, 'b>;
}

pub struct SpecificDOPDataVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> SpecificDOPDataVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<SpecificDOPDataUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, SpecificDOPDataUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_normal_dop(&mut self, o: flatbuffers::WIPOffset<NormalDOP>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_normal_dop(o));
  }

  #[inline]
  pub fn push_as_end_of_pdu_field(&mut self, o: flatbuffers::WIPOffset<EndOfPduField>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_end_of_pdu_field(o));
  }

  #[inline]
  pub fn push_as_static_field(&mut self, o: flatbuffers::WIPOffset<StaticField>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_static_field(o));
  }

  #[inline]
  pub fn push_as_env_data_desc(&mut self, o: flatbuffers::WIPOffset<EnvDataDesc>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_env_data_desc(o));
  }

  #[inline]
  pub fn push_as_env_data(&mut self, o: flatbuffers::WIPOffset<EnvData>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_env_data(o));
  }

  #[inline]
  pub fn push_as_dtcdop(&mut self, o: flatbuffers::WIPOffset<DTCDOP>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_dtcdop(o));
  }

  #[inline]
  pub fn push_as_structure(&mut self, o: flatbuffers::WIPOffset<Structure>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_structure(o));
  }

  #[inline]
  pub fn push_as_muxdop(&mut self, o: flatbuffers::WIPOffset<MUXDOP>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_muxdop(o));
  }

  #[inline]
  pub fn push_as_dynamic_length_field(&mut self, o: flatbuffers::WIPOffset<DynamicLengthField>) {
    self.fbb.push_union_vector_item(SpecificDOPData::tag_as_dynamic_length_field(o));
  }

}

pub struct SpecificDOPDataUnionValue {}

impl flatbuffers::TaggedUnion for SpecificDOPDataUnionValue {
  type Tag = SpecificDOPData;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for SpecificDOPDataUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      SpecificDOPData::NormalDOP => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<NormalDOP>>(
          "SpecificDOPData::NormalDOP",
          pos,
        ),
      SpecificDOPData::EndOfPduField => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<EndOfPduField>>(
          "SpecificDOPData::EndOfPduField",
          pos,
        ),
      SpecificDOPData::StaticField => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<StaticField>>(
          "SpecificDOPData::StaticField",
          pos,
        ),
      SpecificDOPData::EnvDataDesc => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<EnvDataDesc>>(
          "SpecificDOPData::EnvDataDesc",
          pos,
        ),
      SpecificDOPData::EnvData => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<EnvData>>(
          "SpecificDOPData::EnvData",
          pos,
        ),
      SpecificDOPData::DTCDOP => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<DTCDOP>>(
          "SpecificDOPData::DTCDOP",
          pos,
        ),
      SpecificDOPData::Structure => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Structure>>(
          "SpecificDOPData::Structure",
          pos,
        ),
      SpecificDOPData::MUXDOP => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<MUXDOP>>(
          "SpecificDOPData::MUXDOP",
          pos,
        ),
      SpecificDOPData::DynamicLengthField => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<DynamicLengthField>>(
          "SpecificDOPData::DynamicLengthField",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIAG_SERVICE_OR_JOB: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIAG_SERVICE_OR_JOB: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIAG_SERVICE_OR_JOB: [DiagServiceOrJob; 3] = [
  DiagServiceOrJob::NONE,
  DiagServiceOrJob::DiagService,
  DiagServiceOrJob::SingleEcuJob,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DiagServiceOrJob(pub u8);
#[allow(non_upper_case_globals)]
impl DiagServiceOrJob {
  pub const NONE: Self = Self(0);
  pub const DiagService: Self = Self(1);
  pub const SingleEcuJob: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DiagService,
    Self::SingleEcuJob,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DiagService => Some("DiagService"),
      Self::SingleEcuJob => Some("SingleEcuJob"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_diag_service(
    o: flatbuffers::WIPOffset<DiagService>,
  ) -> flatbuffers::UnionWIPOffset<DiagServiceOrJobUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::DiagService, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_single_ecu_job(
    o: flatbuffers::WIPOffset<SingleEcuJob>,
  ) -> flatbuffers::UnionWIPOffset<DiagServiceOrJobUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::SingleEcuJob, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for DiagServiceOrJob {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DiagServiceOrJob {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DiagServiceOrJob {
    type Output = DiagServiceOrJob;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DiagServiceOrJob {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DiagServiceOrJob {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DiagServiceOrJob {}

impl From<DiagServiceOrJob> for u8 {
  #[inline]
  fn from(v: DiagServiceOrJob) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for DiagServiceOrJob {
  type VectorBuilder = DiagServiceOrJobVectorBuilder<'a, 'b>;
}

pub struct DiagServiceOrJobVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> DiagServiceOrJobVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<DiagServiceOrJobUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, DiagServiceOrJobUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_diag_service(&mut self, o: flatbuffers::WIPOffset<DiagService>) {
    self.fbb.push_union_vector_item(DiagServiceOrJob::tag_as_diag_service(o));
  }

  #[inline]
  pub fn push_as_single_ecu_job(&mut self, o: flatbuffers::WIPOffset<SingleEcuJob>) {
    self.fbb.push_union_vector_item(DiagServiceOrJob::tag_as_single_ecu_job(o));
  }

}

pub struct DiagServiceOrJobUnionValue {}

impl flatbuffers::TaggedUnion for DiagServiceOrJobUnionValue {
  type Tag = DiagServiceOrJob;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for DiagServiceOrJobUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      DiagServiceOrJob::DiagService => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<DiagService>>(
          "DiagServiceOrJob::DiagService",
          pos,
        ),
      DiagServiceOrJob::SingleEcuJob => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<SingleEcuJob>>(
          "DiagServiceOrJob::SingleEcuJob",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARAM_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARAM_TYPE: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARAM_TYPE: [ParamType; 12] = [
  ParamType::CODED_CONST,
  ParamType::DYNAMIC,
  ParamType::LENGTH_KEY,
  ParamType::MATCHING_REQUEST_PARAM,
  ParamType::NRC_CONST,
  ParamType::PHYS_CONST,
  ParamType::RESERVED,
  ParamType::SYSTEM,
  ParamType::TABLE_ENTRY,
  ParamType::TABLE_KEY,
  ParamType::TABLE_STRUCT,
  ParamType::VALUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParamType(pub i8);
#[allow(non_upper_case_globals)]
impl ParamType {
  pub const CODED_CONST: Self = Self(0);
  pub const DYNAMIC: Self = Self(1);
  pub const LENGTH_KEY: Self = Self(2);
  pub const MATCHING_REQUEST_PARAM: Self = Self(3);
  pub const NRC_CONST: Self = Self(4);
  pub const PHYS_CONST: Self = Self(5);
  pub const RESERVED: Self = Self(6);
  pub const SYSTEM: Self = Self(7);
  pub const TABLE_ENTRY: Self = Self(8);
  pub const TABLE_KEY: Self = Self(9);
  pub const TABLE_STRUCT: Self = Self(10);
  pub const VALUE: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CODED_CONST,
    Self::DYNAMIC,
    Self::LENGTH_KEY,
    Self::MATCHING_REQUEST_PARAM,
    Self::NRC_CONST,
    Self::PHYS_CONST,
    Self::RESERVED,
    Self::SYSTEM,
    Self::TABLE_ENTRY,
    Self::TABLE_KEY,
    Self::TABLE_STRUCT,
    Self::VALUE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CODED_CONST => Some("CODED_CONST"),
      Self::DYNAMIC => Some("DYNAMIC"),
      Self::LENGTH_KEY => Some("LENGTH_KEY"),
      Self::MATCHING_REQUEST_PARAM => Some("MATCHING_REQUEST_PARAM"),
      Self::NRC_CONST => Some("NRC_CONST"),
      Self::PHYS_CONST => Some("PHYS_CONST"),
      Self::RESERVED => Some("RESERVED"),
      Self::SYSTEM => Some("SYSTEM"),
      Self::TABLE_ENTRY => Some("TABLE_ENTRY"),
      Self::TABLE_KEY => Some("TABLE_KEY"),
      Self::TABLE_STRUCT => Some("TABLE_STRUCT"),
      Self::VALUE => Some("VALUE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ParamType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParamType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ParamType {
    type Output = ParamType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ParamType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParamType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParamType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_ENTRY_ROW_FRAGMENT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_ENTRY_ROW_FRAGMENT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_ENTRY_ROW_FRAGMENT: [TableEntryRowFragment; 2] = [
  TableEntryRowFragment::KEY,
  TableEntryRowFragment::STRUCT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TableEntryRowFragment(pub i8);
#[allow(non_upper_case_globals)]
impl TableEntryRowFragment {
  pub const KEY: Self = Self(0);
  pub const STRUCT: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::KEY,
    Self::STRUCT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::KEY => Some("KEY"),
      Self::STRUCT => Some("STRUCT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TableEntryRowFragment {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TableEntryRowFragment {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for TableEntryRowFragment {
    type Output = TableEntryRowFragment;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for TableEntryRowFragment {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TableEntryRowFragment {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TableEntryRowFragment {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_KEY_REFERENCE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_KEY_REFERENCE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_KEY_REFERENCE: [TableKeyReference; 3] = [
  TableKeyReference::NONE,
  TableKeyReference::TableDop,
  TableKeyReference::TableRow,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TableKeyReference(pub u8);
#[allow(non_upper_case_globals)]
impl TableKeyReference {
  pub const NONE: Self = Self(0);
  pub const TableDop: Self = Self(1);
  pub const TableRow: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TableDop,
    Self::TableRow,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TableDop => Some("TableDop"),
      Self::TableRow => Some("TableRow"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_table_dop(
    o: flatbuffers::WIPOffset<TableDop>,
  ) -> flatbuffers::UnionWIPOffset<TableKeyReferenceUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableDop, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_table_row(
    o: flatbuffers::WIPOffset<TableRow>,
  ) -> flatbuffers::UnionWIPOffset<TableKeyReferenceUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableRow, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for TableKeyReference {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TableKeyReference {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for TableKeyReference {
    type Output = TableKeyReference;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for TableKeyReference {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TableKeyReference {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TableKeyReference {}

impl From<TableKeyReference> for u8 {
  #[inline]
  fn from(v: TableKeyReference) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for TableKeyReference {
  type VectorBuilder = TableKeyReferenceVectorBuilder<'a, 'b>;
}

pub struct TableKeyReferenceVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> TableKeyReferenceVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<TableKeyReferenceUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, TableKeyReferenceUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_table_dop(&mut self, o: flatbuffers::WIPOffset<TableDop>) {
    self.fbb.push_union_vector_item(TableKeyReference::tag_as_table_dop(o));
  }

  #[inline]
  pub fn push_as_table_row(&mut self, o: flatbuffers::WIPOffset<TableRow>) {
    self.fbb.push_union_vector_item(TableKeyReference::tag_as_table_row(o));
  }

}

pub struct TableKeyReferenceUnionValue {}

impl flatbuffers::TaggedUnion for TableKeyReferenceUnionValue {
  type Tag = TableKeyReference;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for TableKeyReferenceUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      TableKeyReference::TableDop => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableDop>>(
          "TableKeyReference::TableDop",
          pos,
        ),
      TableKeyReference::TableRow => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableRow>>(
          "TableKeyReference::TableRow",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARAM_SPECIFIC_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARAM_SPECIFIC_DATA: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARAM_SPECIFIC_DATA: [ParamSpecificData; 13] = [
  ParamSpecificData::NONE,
  ParamSpecificData::CodedConst,
  ParamSpecificData::Dynamic,
  ParamSpecificData::MatchingRequestParam,
  ParamSpecificData::NrcConst,
  ParamSpecificData::PhysConst,
  ParamSpecificData::Reserved,
  ParamSpecificData::Value,
  ParamSpecificData::TableEntry,
  ParamSpecificData::TableKey,
  ParamSpecificData::TableStruct,
  ParamSpecificData::System,
  ParamSpecificData::LengthKeyRef,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParamSpecificData(pub u8);
#[allow(non_upper_case_globals)]
impl ParamSpecificData {
  pub const NONE: Self = Self(0);
  pub const CodedConst: Self = Self(1);
  pub const Dynamic: Self = Self(2);
  pub const MatchingRequestParam: Self = Self(3);
  pub const NrcConst: Self = Self(4);
  pub const PhysConst: Self = Self(5);
  pub const Reserved: Self = Self(6);
  pub const Value: Self = Self(7);
  pub const TableEntry: Self = Self(8);
  pub const TableKey: Self = Self(9);
  pub const TableStruct: Self = Self(10);
  pub const System: Self = Self(11);
  pub const LengthKeyRef: Self = Self(12);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CodedConst,
    Self::Dynamic,
    Self::MatchingRequestParam,
    Self::NrcConst,
    Self::PhysConst,
    Self::Reserved,
    Self::Value,
    Self::TableEntry,
    Self::TableKey,
    Self::TableStruct,
    Self::System,
    Self::LengthKeyRef,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CodedConst => Some("CodedConst"),
      Self::Dynamic => Some("Dynamic"),
      Self::MatchingRequestParam => Some("MatchingRequestParam"),
      Self::NrcConst => Some("NrcConst"),
      Self::PhysConst => Some("PhysConst"),
      Self::Reserved => Some("Reserved"),
      Self::Value => Some("Value"),
      Self::TableEntry => Some("TableEntry"),
      Self::TableKey => Some("TableKey"),
      Self::TableStruct => Some("TableStruct"),
      Self::System => Some("System"),
      Self::LengthKeyRef => Some("LengthKeyRef"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_coded_const(
    o: flatbuffers::WIPOffset<CodedConst>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::CodedConst, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_dynamic(
    o: flatbuffers::WIPOffset<Dynamic>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Dynamic, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_matching_request_param(
    o: flatbuffers::WIPOffset<MatchingRequestParam>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::MatchingRequestParam, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_nrc_const(
    o: flatbuffers::WIPOffset<NrcConst>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::NrcConst, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_phys_const(
    o: flatbuffers::WIPOffset<PhysConst>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::PhysConst, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_reserved(
    o: flatbuffers::WIPOffset<Reserved>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Reserved, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_value(
    o: flatbuffers::WIPOffset<Value>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Value, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_table_entry(
    o: flatbuffers::WIPOffset<TableEntry>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableEntry, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_table_key(
    o: flatbuffers::WIPOffset<TableKey>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableKey, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_table_struct(
    o: flatbuffers::WIPOffset<TableStruct>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableStruct, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_system(
    o: flatbuffers::WIPOffset<System>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::System, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_length_key_ref(
    o: flatbuffers::WIPOffset<LengthKeyRef>,
  ) -> flatbuffers::UnionWIPOffset<ParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::LengthKeyRef, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for ParamSpecificData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParamSpecificData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ParamSpecificData {
    type Output = ParamSpecificData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ParamSpecificData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParamSpecificData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParamSpecificData {}

impl From<ParamSpecificData> for u8 {
  #[inline]
  fn from(v: ParamSpecificData) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for ParamSpecificData {
  type VectorBuilder = ParamSpecificDataVectorBuilder<'a, 'b>;
}

pub struct ParamSpecificDataVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> ParamSpecificDataVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<ParamSpecificDataUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, ParamSpecificDataUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_coded_const(&mut self, o: flatbuffers::WIPOffset<CodedConst>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_coded_const(o));
  }

  #[inline]
  pub fn push_as_dynamic(&mut self, o: flatbuffers::WIPOffset<Dynamic>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_dynamic(o));
  }

  #[inline]
  pub fn push_as_matching_request_param(&mut self, o: flatbuffers::WIPOffset<MatchingRequestParam>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_matching_request_param(o));
  }

  #[inline]
  pub fn push_as_nrc_const(&mut self, o: flatbuffers::WIPOffset<NrcConst>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_nrc_const(o));
  }

  #[inline]
  pub fn push_as_phys_const(&mut self, o: flatbuffers::WIPOffset<PhysConst>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_phys_const(o));
  }

  #[inline]
  pub fn push_as_reserved(&mut self, o: flatbuffers::WIPOffset<Reserved>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_reserved(o));
  }

  #[inline]
  pub fn push_as_value(&mut self, o: flatbuffers::WIPOffset<Value>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_value(o));
  }

  #[inline]
  pub fn push_as_table_entry(&mut self, o: flatbuffers::WIPOffset<TableEntry>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_table_entry(o));
  }

  #[inline]
  pub fn push_as_table_key(&mut self, o: flatbuffers::WIPOffset<TableKey>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_table_key(o));
  }

  #[inline]
  pub fn push_as_table_struct(&mut self, o: flatbuffers::WIPOffset<TableStruct>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_table_struct(o));
  }

  #[inline]
  pub fn push_as_system(&mut self, o: flatbuffers::WIPOffset<System>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_system(o));
  }

  #[inline]
  pub fn push_as_length_key_ref(&mut self, o: flatbuffers::WIPOffset<LengthKeyRef>) {
    self.fbb.push_union_vector_item(ParamSpecificData::tag_as_length_key_ref(o));
  }

}

pub struct ParamSpecificDataUnionValue {}

impl flatbuffers::TaggedUnion for ParamSpecificDataUnionValue {
  type Tag = ParamSpecificData;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for ParamSpecificDataUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      ParamSpecificData::CodedConst => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<CodedConst>>(
          "ParamSpecificData::CodedConst",
          pos,
        ),
      ParamSpecificData::Dynamic => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Dynamic>>(
          "ParamSpecificData::Dynamic",
          pos,
        ),
      ParamSpecificData::MatchingRequestParam => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<MatchingRequestParam>>(
          "ParamSpecificData::MatchingRequestParam",
          pos,
        ),
      ParamSpecificData::NrcConst => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<NrcConst>>(
          "ParamSpecificData::NrcConst",
          pos,
        ),
      ParamSpecificData::PhysConst => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<PhysConst>>(
          "ParamSpecificData::PhysConst",
          pos,
        ),
      ParamSpecificData::Reserved => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Reserved>>(
          "ParamSpecificData::Reserved",
          pos,
        ),
      ParamSpecificData::Value => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Value>>(
          "ParamSpecificData::Value",
          pos,
        ),
      ParamSpecificData::TableEntry => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableEntry>>(
          "ParamSpecificData::TableEntry",
          pos,
        ),
      ParamSpecificData::TableKey => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableKey>>(
          "ParamSpecificData::TableKey",
          pos,
        ),
      ParamSpecificData::TableStruct => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableStruct>>(
          "ParamSpecificData::TableStruct",
          pos,
        ),
      ParamSpecificData::System => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<System>>(
          "ParamSpecificData::System",
          pos,
        ),
      ParamSpecificData::LengthKeyRef => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<LengthKeyRef>>(
          "ParamSpecificData::LengthKeyRef",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_TYPE: [ResponseType; 3] = [
  ResponseType::POS_RESPONSE,
  ResponseType::NEG_RESPONSE,
  ResponseType::GLOBAL_NEG_RESPONSE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponseType(pub i8);
#[allow(non_upper_case_globals)]
impl ResponseType {
  pub const POS_RESPONSE: Self = Self(0);
  pub const NEG_RESPONSE: Self = Self(1);
  pub const GLOBAL_NEG_RESPONSE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POS_RESPONSE,
    Self::NEG_RESPONSE,
    Self::GLOBAL_NEG_RESPONSE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POS_RESPONSE => Some("POS_RESPONSE"),
      Self::NEG_RESPONSE => Some("NEG_RESPONSE"),
      Self::GLOBAL_NEG_RESPONSE => Some("GLOBAL_NEG_RESPONSE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ResponseType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ResponseType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ResponseType {
    type Output = ResponseType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ResponseType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ResponseType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ResponseType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIAG_CLASS_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIAG_CLASS_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIAG_CLASS_TYPE: [DiagClassType; 6] = [
  DiagClassType::START_COMM,
  DiagClassType::STOP_COMM,
  DiagClassType::VARIANT_IDENTIFICATION,
  DiagClassType::READ_DYN_DEF_MESSAGE,
  DiagClassType::DYN_DEF_MESSAGE,
  DiagClassType::CLEAR_DYN_DEF_MESSAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DiagClassType(pub i8);
#[allow(non_upper_case_globals)]
impl DiagClassType {
  pub const START_COMM: Self = Self(0);
  pub const STOP_COMM: Self = Self(1);
  pub const VARIANT_IDENTIFICATION: Self = Self(2);
  pub const READ_DYN_DEF_MESSAGE: Self = Self(3);
  pub const DYN_DEF_MESSAGE: Self = Self(4);
  pub const CLEAR_DYN_DEF_MESSAGE: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::START_COMM,
    Self::STOP_COMM,
    Self::VARIANT_IDENTIFICATION,
    Self::READ_DYN_DEF_MESSAGE,
    Self::DYN_DEF_MESSAGE,
    Self::CLEAR_DYN_DEF_MESSAGE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::START_COMM => Some("START_COMM"),
      Self::STOP_COMM => Some("STOP_COMM"),
      Self::VARIANT_IDENTIFICATION => Some("VARIANT_IDENTIFICATION"),
      Self::READ_DYN_DEF_MESSAGE => Some("READ_DYN_DEF_MESSAGE"),
      Self::DYN_DEF_MESSAGE => Some("DYN_DEF_MESSAGE"),
      Self::CLEAR_DYN_DEF_MESSAGE => Some("CLEAR_DYN_DEF_MESSAGE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DiagClassType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DiagClassType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DiagClassType {
    type Output = DiagClassType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DiagClassType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DiagClassType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DiagClassType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRANSMISSION_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRANSMISSION_MODE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSMISSION_MODE: [TransmissionMode; 4] = [
  TransmissionMode::SEND_ONLY,
  TransmissionMode::RECEIVE_ONLY,
  TransmissionMode::SEND_AND_RECEIVE,
  TransmissionMode::SEND_OR_RECEIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TransmissionMode(pub i8);
#[allow(non_upper_case_globals)]
impl TransmissionMode {
  pub const SEND_ONLY: Self = Self(0);
  pub const RECEIVE_ONLY: Self = Self(1);
  pub const SEND_AND_RECEIVE: Self = Self(2);
  pub const SEND_OR_RECEIVE: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SEND_ONLY,
    Self::RECEIVE_ONLY,
    Self::SEND_AND_RECEIVE,
    Self::SEND_OR_RECEIVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SEND_ONLY => Some("SEND_ONLY"),
      Self::RECEIVE_ONLY => Some("RECEIVE_ONLY"),
      Self::SEND_AND_RECEIVE => Some("SEND_AND_RECEIVE"),
      Self::SEND_OR_RECEIVE => Some("SEND_OR_RECEIVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TransmissionMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TransmissionMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for TransmissionMode {
    type Output = TransmissionMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for TransmissionMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TransmissionMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TransmissionMode {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ADDRESSING: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ADDRESSING: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ADDRESSING: [Addressing; 3] = [
  Addressing::FUNCTIONAL,
  Addressing::PHYSICAL,
  Addressing::FUNCTIONAL_OR_PHYSICAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Addressing(pub i8);
#[allow(non_upper_case_globals)]
impl Addressing {
  pub const FUNCTIONAL: Self = Self(0);
  pub const PHYSICAL: Self = Self(1);
  pub const FUNCTIONAL_OR_PHYSICAL: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FUNCTIONAL,
    Self::PHYSICAL,
    Self::FUNCTIONAL_OR_PHYSICAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FUNCTIONAL => Some("FUNCTIONAL"),
      Self::PHYSICAL => Some("PHYSICAL"),
      Self::FUNCTIONAL_OR_PHYSICAL => Some("FUNCTIONAL_OR_PHYSICAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Addressing {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Addressing {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for Addressing {
    type Output = Addressing;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Addressing {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Addressing {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Addressing {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARENT_REF_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARENT_REF_TYPE: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARENT_REF_TYPE: [ParentRefType; 6] = [
  ParentRefType::NONE,
  ParentRefType::Variant,
  ParentRefType::Protocol,
  ParentRefType::FunctionalGroup,
  ParentRefType::TableDop,
  ParentRefType::EcuSharedData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ParentRefType(pub u8);
#[allow(non_upper_case_globals)]
impl ParentRefType {
  pub const NONE: Self = Self(0);
  pub const Variant: Self = Self(1);
  pub const Protocol: Self = Self(2);
  pub const FunctionalGroup: Self = Self(3);
  pub const TableDop: Self = Self(4);
  pub const EcuSharedData: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Variant,
    Self::Protocol,
    Self::FunctionalGroup,
    Self::TableDop,
    Self::EcuSharedData,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Variant => Some("Variant"),
      Self::Protocol => Some("Protocol"),
      Self::FunctionalGroup => Some("FunctionalGroup"),
      Self::TableDop => Some("TableDop"),
      Self::EcuSharedData => Some("EcuSharedData"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_variant(
    o: flatbuffers::WIPOffset<Variant>,
  ) -> flatbuffers::UnionWIPOffset<ParentRefTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Variant, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_protocol(
    o: flatbuffers::WIPOffset<Protocol>,
  ) -> flatbuffers::UnionWIPOffset<ParentRefTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::Protocol, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_functional_group(
    o: flatbuffers::WIPOffset<FunctionalGroup>,
  ) -> flatbuffers::UnionWIPOffset<ParentRefTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::FunctionalGroup, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_table_dop(
    o: flatbuffers::WIPOffset<TableDop>,
  ) -> flatbuffers::UnionWIPOffset<ParentRefTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::TableDop, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_ecu_shared_data(
    o: flatbuffers::WIPOffset<EcuSharedData>,
  ) -> flatbuffers::UnionWIPOffset<ParentRefTypeUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::EcuSharedData, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for ParentRefType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ParentRefType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ParentRefType {
    type Output = ParentRefType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ParentRefType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ParentRefType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ParentRefType {}

impl From<ParentRefType> for u8 {
  #[inline]
  fn from(v: ParentRefType) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for ParentRefType {
  type VectorBuilder = ParentRefTypeVectorBuilder<'a, 'b>;
}

pub struct ParentRefTypeVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> ParentRefTypeVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<ParentRefTypeUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, ParentRefTypeUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_variant(&mut self, o: flatbuffers::WIPOffset<Variant>) {
    self.fbb.push_union_vector_item(ParentRefType::tag_as_variant(o));
  }

  #[inline]
  pub fn push_as_protocol(&mut self, o: flatbuffers::WIPOffset<Protocol>) {
    self.fbb.push_union_vector_item(ParentRefType::tag_as_protocol(o));
  }

  #[inline]
  pub fn push_as_functional_group(&mut self, o: flatbuffers::WIPOffset<FunctionalGroup>) {
    self.fbb.push_union_vector_item(ParentRefType::tag_as_functional_group(o));
  }

  #[inline]
  pub fn push_as_table_dop(&mut self, o: flatbuffers::WIPOffset<TableDop>) {
    self.fbb.push_union_vector_item(ParentRefType::tag_as_table_dop(o));
  }

  #[inline]
  pub fn push_as_ecu_shared_data(&mut self, o: flatbuffers::WIPOffset<EcuSharedData>) {
    self.fbb.push_union_vector_item(ParentRefType::tag_as_ecu_shared_data(o));
  }

}

pub struct ParentRefTypeUnionValue {}

impl flatbuffers::TaggedUnion for ParentRefTypeUnionValue {
  type Tag = ParentRefType;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for ParentRefTypeUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      ParentRefType::Variant => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Variant>>(
          "ParentRefType::Variant",
          pos,
        ),
      ParentRefType::Protocol => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<Protocol>>(
          "ParentRefType::Protocol",
          pos,
        ),
      ParentRefType::FunctionalGroup => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<FunctionalGroup>>(
          "ParentRefType::FunctionalGroup",
          pos,
        ),
      ParentRefType::TableDop => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<TableDop>>(
          "ParentRefType::TableDop",
          pos,
        ),
      ParentRefType::EcuSharedData => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<EcuSharedData>>(
          "ParentRefType::EcuSharedData",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SIMPLE_OR_COMPLEX_VALUE_ENTRY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SIMPLE_OR_COMPLEX_VALUE_ENTRY: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SIMPLE_OR_COMPLEX_VALUE_ENTRY: [SimpleOrComplexValueEntry; 3] = [
  SimpleOrComplexValueEntry::NONE,
  SimpleOrComplexValueEntry::SimpleValue,
  SimpleOrComplexValueEntry::ComplexValue,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SimpleOrComplexValueEntry(pub u8);
#[allow(non_upper_case_globals)]
impl SimpleOrComplexValueEntry {
  pub const NONE: Self = Self(0);
  pub const SimpleValue: Self = Self(1);
  pub const ComplexValue: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SimpleValue,
    Self::ComplexValue,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SimpleValue => Some("SimpleValue"),
      Self::ComplexValue => Some("ComplexValue"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_simple_value(
    o: flatbuffers::WIPOffset<SimpleValue>,
  ) -> flatbuffers::UnionWIPOffset<SimpleOrComplexValueEntryUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::SimpleValue, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_complex_value(
    o: flatbuffers::WIPOffset<ComplexValue>,
  ) -> flatbuffers::UnionWIPOffset<SimpleOrComplexValueEntryUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::ComplexValue, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for SimpleOrComplexValueEntry {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SimpleOrComplexValueEntry {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SimpleOrComplexValueEntry {
    type Output = SimpleOrComplexValueEntry;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SimpleOrComplexValueEntry {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SimpleOrComplexValueEntry {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SimpleOrComplexValueEntry {}

impl From<SimpleOrComplexValueEntry> for u8 {
  #[inline]
  fn from(v: SimpleOrComplexValueEntry) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for SimpleOrComplexValueEntry {
  type VectorBuilder = SimpleOrComplexValueEntryVectorBuilder<'a, 'b>;
}

pub struct SimpleOrComplexValueEntryVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> SimpleOrComplexValueEntryVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<SimpleOrComplexValueEntryUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, SimpleOrComplexValueEntryUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_simple_value(&mut self, o: flatbuffers::WIPOffset<SimpleValue>) {
    self.fbb.push_union_vector_item(SimpleOrComplexValueEntry::tag_as_simple_value(o));
  }

  #[inline]
  pub fn push_as_complex_value(&mut self, o: flatbuffers::WIPOffset<ComplexValue>) {
    self.fbb.push_union_vector_item(SimpleOrComplexValueEntry::tag_as_complex_value(o));
  }

}

pub struct SimpleOrComplexValueEntryUnionValue {}

impl flatbuffers::TaggedUnion for SimpleOrComplexValueEntryUnionValue {
  type Tag = SimpleOrComplexValueEntry;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for SimpleOrComplexValueEntryUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      SimpleOrComplexValueEntry::SimpleValue => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<SimpleValue>>(
          "SimpleOrComplexValueEntry::SimpleValue",
          pos,
        ),
      SimpleOrComplexValueEntry::ComplexValue => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<ComplexValue>>(
          "SimpleOrComplexValueEntry::ComplexValue",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COM_PARAM_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COM_PARAM_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COM_PARAM_TYPE: [ComParamType; 2] = [
  ComParamType::REGULAR,
  ComParamType::COMPLEX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComParamType(pub i8);
#[allow(non_upper_case_globals)]
impl ComParamType {
  pub const REGULAR: Self = Self(0);
  pub const COMPLEX: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REGULAR,
    Self::COMPLEX,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REGULAR => Some("REGULAR"),
      Self::COMPLEX => Some("COMPLEX"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ComParamType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComParamType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ComParamType {
    type Output = ComParamType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ComParamType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComParamType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComParamType {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COM_PARAM_STANDARDISATION_LEVEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COM_PARAM_STANDARDISATION_LEVEL: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COM_PARAM_STANDARDISATION_LEVEL: [ComParamStandardisationLevel; 4] = [
  ComParamStandardisationLevel::STANDARD,
  ComParamStandardisationLevel::OEM_SPECIFIC,
  ComParamStandardisationLevel::OPTIONAL,
  ComParamStandardisationLevel::OEM_OPTIONAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComParamStandardisationLevel(pub i8);
#[allow(non_upper_case_globals)]
impl ComParamStandardisationLevel {
  pub const STANDARD: Self = Self(0);
  pub const OEM_SPECIFIC: Self = Self(1);
  pub const OPTIONAL: Self = Self(2);
  pub const OEM_OPTIONAL: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STANDARD,
    Self::OEM_SPECIFIC,
    Self::OPTIONAL,
    Self::OEM_OPTIONAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STANDARD => Some("STANDARD"),
      Self::OEM_SPECIFIC => Some("OEM_SPECIFIC"),
      Self::OPTIONAL => Some("OPTIONAL"),
      Self::OEM_OPTIONAL => Some("OEM_OPTIONAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ComParamStandardisationLevel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComParamStandardisationLevel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ComParamStandardisationLevel {
    type Output = ComParamStandardisationLevel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ComParamStandardisationLevel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComParamStandardisationLevel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComParamStandardisationLevel {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COM_PARAM_USAGE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COM_PARAM_USAGE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COM_PARAM_USAGE: [ComParamUsage; 4] = [
  ComParamUsage::ECU_SOFTWARE,
  ComParamUsage::ECU_COMM,
  ComParamUsage::APPLICATION,
  ComParamUsage::TESTER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComParamUsage(pub i8);
#[allow(non_upper_case_globals)]
impl ComParamUsage {
  pub const ECU_SOFTWARE: Self = Self(0);
  pub const ECU_COMM: Self = Self(1);
  pub const APPLICATION: Self = Self(2);
  pub const TESTER: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ECU_SOFTWARE,
    Self::ECU_COMM,
    Self::APPLICATION,
    Self::TESTER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ECU_SOFTWARE => Some("ECU_SOFTWARE"),
      Self::ECU_COMM => Some("ECU_COMM"),
      Self::APPLICATION => Some("APPLICATION"),
      Self::TESTER => Some("TESTER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ComParamUsage {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComParamUsage {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ComParamUsage {
    type Output = ComParamUsage;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ComParamUsage {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComParamUsage {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComParamUsage {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COM_PARAM_SPECIFIC_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COM_PARAM_SPECIFIC_DATA: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COM_PARAM_SPECIFIC_DATA: [ComParamSpecificData; 3] = [
  ComParamSpecificData::NONE,
  ComParamSpecificData::RegularComParam,
  ComParamSpecificData::ComplexComParam,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComParamSpecificData(pub u8);
#[allow(non_upper_case_globals)]
impl ComParamSpecificData {
  pub const NONE: Self = Self(0);
  pub const RegularComParam: Self = Self(1);
  pub const ComplexComParam: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::RegularComParam,
    Self::ComplexComParam,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::RegularComParam => Some("RegularComParam"),
      Self::ComplexComParam => Some("ComplexComParam"),
      _ => None,
    }
  }

  #[inline]
  pub fn tag_as_regular_com_param(
    o: flatbuffers::WIPOffset<RegularComParam>,
  ) -> flatbuffers::UnionWIPOffset<ComParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::RegularComParam, flatbuffers::WIPOffset::new(o.value()))
  }

  #[inline]
  pub fn tag_as_complex_com_param(
    o: flatbuffers::WIPOffset<ComplexComParam>,
  ) -> flatbuffers::UnionWIPOffset<ComParamSpecificDataUnionValue> {
    flatbuffers::UnionWIPOffset::new(Self::ComplexComParam, flatbuffers::WIPOffset::new(o.value()))
  }

}
impl core::fmt::Debug for ComParamSpecificData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComParamSpecificData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ComParamSpecificData {
    type Output = ComParamSpecificData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ComParamSpecificData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComParamSpecificData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComParamSpecificData {}

impl From<ComParamSpecificData> for u8 {
  #[inline]
  fn from(v: ComParamSpecificData) -> u8 {
    v.0
  }
}

impl<'a: 'b, 'b> flatbuffers::BuildVector<'a, 'b> for ComParamSpecificData {
  type VectorBuilder = ComParamSpecificDataVectorBuilder<'a, 'b>;
}

pub struct ComParamSpecificDataVectorBuilder<'a: 'b, 'b> {
  fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  num_items: usize,
}

impl<'a: 'b, 'b> ComParamSpecificDataVectorBuilder<'a, 'b> {
  #[inline]
  pub fn new(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, num_items: usize) -> Self {
    fbb.start_union_vector::<ComParamSpecificDataUnionValue>(num_items);
    Self { fbb, num_items }
  }

  #[inline]
  pub fn finish(&mut self) -> flatbuffers::UnionVectorWIPOffsets<'a, ComParamSpecificDataUnionValue> {
    self.fbb.end_union_vector(self.num_items)
  }

  #[inline]
  pub fn push_as_regular_com_param(&mut self, o: flatbuffers::WIPOffset<RegularComParam>) {
    self.fbb.push_union_vector_item(ComParamSpecificData::tag_as_regular_com_param(o));
  }

  #[inline]
  pub fn push_as_complex_com_param(&mut self, o: flatbuffers::WIPOffset<ComplexComParam>) {
    self.fbb.push_union_vector_item(ComParamSpecificData::tag_as_complex_com_param(o));
  }

}

pub struct ComParamSpecificDataUnionValue {}

impl flatbuffers::TaggedUnion for ComParamSpecificDataUnionValue {
  type Tag = ComParamSpecificData;
}

impl<'a> flatbuffers::UnionVerifiable<'a> for ComParamSpecificDataUnionValue {
  fn run_union_verifier(
    v: &mut flatbuffers::Verifier,
    tag: <<Self as flatbuffers::TaggedUnion>::Tag as flatbuffers::Follow<'a>>::Inner,
    pos: usize,
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    match tag {
      ComParamSpecificData::RegularComParam => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<RegularComParam>>(
          "ComParamSpecificData::RegularComParam",
          pos,
        ),
      ComParamSpecificData::ComplexComParam => v
        .verify_union_variant::<flatbuffers::ForwardsUOffset<ComplexComParam>>(
          "ComParamSpecificData::ComplexComParam",
          pos,
        ),
      _ => Ok(()),
    }
  }
}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UNIT_GROUP_CATEGORY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UNIT_GROUP_CATEGORY: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UNIT_GROUP_CATEGORY: [UnitGroupCategory; 2] = [
  UnitGroupCategory::COUNTRY,
  UnitGroupCategory::EQUIV_UNITS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UnitGroupCategory(pub i8);
#[allow(non_upper_case_globals)]
impl UnitGroupCategory {
  pub const COUNTRY: Self = Self(0);
  pub const EQUIV_UNITS: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COUNTRY,
    Self::EQUIV_UNITS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::COUNTRY => Some("COUNTRY"),
      Self::EQUIV_UNITS => Some("EQUIV_UNITS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UnitGroupCategory {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UnitGroupCategory {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for UnitGroupCategory {
    type Output = UnitGroupCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for UnitGroupCategory {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UnitGroupCategory {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UnitGroupCategory {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FEATURE_FLAG: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FEATURE_FLAG: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FEATURE_FLAG: [FeatureFlag; 1] = [
  FeatureFlag::RESERVED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FeatureFlag(pub i8);
#[allow(non_upper_case_globals)]
impl FeatureFlag {
  pub const RESERVED: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RESERVED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RESERVED => Some("RESERVED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FeatureFlag {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FeatureFlag {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for FeatureFlag {
    type Output = FeatureFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for FeatureFlag {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FeatureFlag {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FeatureFlag {}

pub enum SDOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SD<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SD<'a> {
  type Inner = SD<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SD<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_SI: flatbuffers::VOffsetT = 6;
  pub const VT_TI: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SD { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDArgs<'args>
  ) -> flatbuffers::WIPOffset<SD<'bldr>> {
    let mut builder = SDBuilder::new(_fbb);
    if let Some(x) = args.ti { builder.add_ti(x); }
    if let Some(x) = args.si { builder.add_si(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SD::VT_VALUE, None)}
  }
  #[inline]
  pub fn si(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SD::VT_SI, None)}
  }
  #[inline]
  pub fn ti(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SD::VT_TI, None)}
  }
}

impl flatbuffers::Verifiable for SD<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("si", Self::VT_SI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ti", Self::VT_TI, false)?
     .finish();
    Ok(())
  }
}
pub struct SDArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub si: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ti: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SDArgs<'a> {
  #[inline]
  fn default() -> Self {
    SDArgs {
      value: None,
      si: None,
      ti: None,
    }
  }
}

pub struct SDBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SD::VT_VALUE, value);
  }
  #[inline]
  pub fn add_si(&mut self, si: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SD::VT_SI, si);
  }
  #[inline]
  pub fn add_ti(&mut self, ti: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SD::VT_TI, ti);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SD<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SD<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SD");
      ds.field("value", &self.value());
      ds.field("si", &self.si());
      ds.field("ti", &self.ti());
      ds.finish()
  }
}
pub enum SDOrSDGOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SDOrSDG<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SDOrSDG<'a> {
  type Inner = SDOrSDG<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SDOrSDG<'a> {
  pub const VT_SD_OR_SDG_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SD_OR_SDG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SDOrSDG { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDOrSDGArgs
  ) -> flatbuffers::WIPOffset<SDOrSDG<'bldr>> {
    let mut builder = SDOrSDGBuilder::new(_fbb);
    if let Some(x) = args.sd_or_sdg { builder.add_sd_or_sdg(x); }
    builder.add_sd_or_sdg_type(args.sd_or_sdg_type);
    builder.finish()
  }


  #[inline]
  pub fn sd_or_sdg_type(&self) -> SDxorSDG {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SDxorSDG>(SDOrSDG::VT_SD_OR_SDG_TYPE, Some(SDxorSDG::NONE)).unwrap()}
  }
  #[inline]
  pub fn sd_or_sdg(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SDOrSDG::VT_SD_OR_SDG, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn sd_or_sdg_as_sd(&self) -> Option<SD<'a>> {
    if self.sd_or_sdg_type() == SDxorSDG::SD {
      self.sd_or_sdg().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SD::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn sd_or_sdg_as_sdg(&self) -> Option<SDG<'a>> {
    if self.sd_or_sdg_type() == SDxorSDG::SDG {
      self.sd_or_sdg().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SDG::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SDOrSDG<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<SDxorSDGUnionValue>("sd_or_sdg_type", Self::VT_SD_OR_SDG_TYPE, "sd_or_sdg", Self::VT_SD_OR_SDG, false)?
     .finish();
    Ok(())
  }
}
pub struct SDOrSDGArgs {
    pub sd_or_sdg_type: SDxorSDG,
    pub sd_or_sdg: Option<flatbuffers::WIPOffset<SDxorSDGUnionValue>>,
}
impl<'a> Default for SDOrSDGArgs {
  #[inline]
  fn default() -> Self {
    SDOrSDGArgs {
      sd_or_sdg_type: SDxorSDG::NONE,
      sd_or_sdg: None,
    }
  }
}

pub struct SDOrSDGBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDOrSDGBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sd_or_sdg_type(&mut self, sd_or_sdg_type: SDxorSDG) {
    self.fbb_.push_slot::<SDxorSDG>(SDOrSDG::VT_SD_OR_SDG_TYPE, sd_or_sdg_type, SDxorSDG::NONE);
  }
  #[inline]
  pub fn add_sd_or_sdg(&mut self, sd_or_sdg: flatbuffers::WIPOffset<SDxorSDGUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDOrSDG::VT_SD_OR_SDG, sd_or_sdg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDOrSDGBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDOrSDGBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SDOrSDG<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SDOrSDG<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SDOrSDG");
      ds.field("sd_or_sdg_type", &self.sd_or_sdg_type());
      match self.sd_or_sdg_type() {
        SDxorSDG::SD => {
          if let Some(x) = self.sd_or_sdg_as_sd() {
            ds.field("sd_or_sdg", &x)
          } else {
            ds.field("sd_or_sdg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SDxorSDG::SDG => {
          if let Some(x) = self.sd_or_sdg_as_sdg() {
            ds.field("sd_or_sdg", &x)
          } else {
            ds.field("sd_or_sdg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("sd_or_sdg", &x)
        },
      };
      ds.finish()
  }
}
pub enum SDGCaptionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SDGCaption<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SDGCaption<'a> {
  type Inner = SDGCaption<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SDGCaption<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SDGCaption { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDGCaptionArgs<'args>
  ) -> flatbuffers::WIPOffset<SDGCaption<'bldr>> {
    let mut builder = SDGCaptionBuilder::new(_fbb);
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SDGCaption::VT_SHORT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for SDGCaption<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct SDGCaptionArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SDGCaptionArgs<'a> {
  #[inline]
  fn default() -> Self {
    SDGCaptionArgs {
      short_name: None,
    }
  }
}

pub struct SDGCaptionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDGCaptionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDGCaption::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDGCaptionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDGCaptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SDGCaption<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SDGCaption<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SDGCaption");
      ds.field("short_name", &self.short_name());
      ds.finish()
  }
}
pub enum SDGOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SDG<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SDG<'a> {
  type Inner = SDG<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SDG<'a> {
  pub const VT_CAPTION: flatbuffers::VOffsetT = 4;
  pub const VT_SDS: flatbuffers::VOffsetT = 6;
  pub const VT_SI: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SDG { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDGArgs<'args>
  ) -> flatbuffers::WIPOffset<SDG<'bldr>> {
    let mut builder = SDGBuilder::new(_fbb);
    if let Some(x) = args.si { builder.add_si(x); }
    if let Some(x) = args.sds { builder.add_sds(x); }
    if let Some(x) = args.caption { builder.add_caption(x); }
    builder.finish()
  }


  #[inline]
  pub fn caption(&self) -> Option<SDGCaption<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGCaption>>(SDG::VT_CAPTION, None)}
  }
  #[inline]
  pub fn sds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDOrSDG<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDOrSDG>>>>(SDG::VT_SDS, None)}
  }
  #[inline]
  pub fn si(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SDG::VT_SI, None)}
  }
}

impl flatbuffers::Verifiable for SDG<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGCaption>>("caption", Self::VT_CAPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SDOrSDG>>>>("sds", Self::VT_SDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("si", Self::VT_SI, false)?
     .finish();
    Ok(())
  }
}
pub struct SDGArgs<'a> {
    pub caption: Option<flatbuffers::WIPOffset<SDGCaption<'a>>>,
    pub sds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDOrSDG<'a>>>>>,
    pub si: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SDGArgs<'a> {
  #[inline]
  fn default() -> Self {
    SDGArgs {
      caption: None,
      sds: None,
      si: None,
    }
  }
}

pub struct SDGBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDGBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_caption(&mut self, caption: flatbuffers::WIPOffset<SDGCaption<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGCaption>>(SDG::VT_CAPTION, caption);
  }
  #[inline]
  pub fn add_sds(&mut self, sds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SDOrSDG<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDG::VT_SDS, sds);
  }
  #[inline]
  pub fn add_si(&mut self, si: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDG::VT_SI, si);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDGBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDGBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SDG<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SDG<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SDG");
      ds.field("caption", &self.caption());
      ds.field("sds", &self.sds());
      ds.field("si", &self.si());
      ds.finish()
  }
}
pub enum SDGSOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SDGS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SDGS<'a> {
  type Inner = SDGS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SDGS<'a> {
  pub const VT_SDGS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SDGS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDGSArgs<'args>
  ) -> flatbuffers::WIPOffset<SDGS<'bldr>> {
    let mut builder = SDGSBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    builder.finish()
  }


  #[inline]
  pub fn sdgs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDG<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDG>>>>(SDGS::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for SDGS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SDG>>>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct SDGSArgs<'a> {
    pub sdgs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SDG<'a>>>>>,
}
impl<'a> Default for SDGSArgs<'a> {
  #[inline]
  fn default() -> Self {
    SDGSArgs {
      sdgs: None,
    }
  }
}

pub struct SDGSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDGSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SDG<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDGS::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDGSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDGSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SDGS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SDGS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SDGS");
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum AudienceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Audience<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Audience<'a> {
  type Inner = Audience<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Audience<'a> {
  pub const VT_ENABLED_AUDIENCES: flatbuffers::VOffsetT = 4;
  pub const VT_DISABLED_AUDIENCES: flatbuffers::VOffsetT = 6;
  pub const VT_IS_SUPPLIER: flatbuffers::VOffsetT = 8;
  pub const VT_IS_DEVELOPMENT: flatbuffers::VOffsetT = 10;
  pub const VT_IS_MANUFACTURING: flatbuffers::VOffsetT = 12;
  pub const VT_IS_AFTER_SALES: flatbuffers::VOffsetT = 14;
  pub const VT_IS_AFTER_MARKET: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Audience { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AudienceArgs<'args>
  ) -> flatbuffers::WIPOffset<Audience<'bldr>> {
    let mut builder = AudienceBuilder::new(_fbb);
    if let Some(x) = args.disabled_audiences { builder.add_disabled_audiences(x); }
    if let Some(x) = args.enabled_audiences { builder.add_enabled_audiences(x); }
    builder.add_is_after_market(args.is_after_market);
    builder.add_is_after_sales(args.is_after_sales);
    builder.add_is_manufacturing(args.is_manufacturing);
    builder.add_is_development(args.is_development);
    builder.add_is_supplier(args.is_supplier);
    builder.finish()
  }


  #[inline]
  pub fn enabled_audiences(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>(Audience::VT_ENABLED_AUDIENCES, None)}
  }
  #[inline]
  pub fn disabled_audiences(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>(Audience::VT_DISABLED_AUDIENCES, None)}
  }
  #[inline]
  pub fn is_supplier(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Audience::VT_IS_SUPPLIER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_development(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Audience::VT_IS_DEVELOPMENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_manufacturing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Audience::VT_IS_MANUFACTURING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_after_sales(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Audience::VT_IS_AFTER_SALES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_after_market(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Audience::VT_IS_AFTER_MARKET, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Audience<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>("enabled_audiences", Self::VT_ENABLED_AUDIENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>("disabled_audiences", Self::VT_DISABLED_AUDIENCES, false)?
     .visit_field::<bool>("is_supplier", Self::VT_IS_SUPPLIER, false)?
     .visit_field::<bool>("is_development", Self::VT_IS_DEVELOPMENT, false)?
     .visit_field::<bool>("is_manufacturing", Self::VT_IS_MANUFACTURING, false)?
     .visit_field::<bool>("is_after_sales", Self::VT_IS_AFTER_SALES, false)?
     .visit_field::<bool>("is_after_market", Self::VT_IS_AFTER_MARKET, false)?
     .finish();
    Ok(())
  }
}
pub struct AudienceArgs<'a> {
    pub enabled_audiences: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>>>,
    pub disabled_audiences: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>>>,
    pub is_supplier: bool,
    pub is_development: bool,
    pub is_manufacturing: bool,
    pub is_after_sales: bool,
    pub is_after_market: bool,
}
impl<'a> Default for AudienceArgs<'a> {
  #[inline]
  fn default() -> Self {
    AudienceArgs {
      enabled_audiences: None,
      disabled_audiences: None,
      is_supplier: false,
      is_development: false,
      is_manufacturing: false,
      is_after_sales: false,
      is_after_market: false,
    }
  }
}

pub struct AudienceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AudienceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_enabled_audiences(&mut self, enabled_audiences: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AdditionalAudience<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Audience::VT_ENABLED_AUDIENCES, enabled_audiences);
  }
  #[inline]
  pub fn add_disabled_audiences(&mut self, disabled_audiences: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AdditionalAudience<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Audience::VT_DISABLED_AUDIENCES, disabled_audiences);
  }
  #[inline]
  pub fn add_is_supplier(&mut self, is_supplier: bool) {
    self.fbb_.push_slot::<bool>(Audience::VT_IS_SUPPLIER, is_supplier, false);
  }
  #[inline]
  pub fn add_is_development(&mut self, is_development: bool) {
    self.fbb_.push_slot::<bool>(Audience::VT_IS_DEVELOPMENT, is_development, false);
  }
  #[inline]
  pub fn add_is_manufacturing(&mut self, is_manufacturing: bool) {
    self.fbb_.push_slot::<bool>(Audience::VT_IS_MANUFACTURING, is_manufacturing, false);
  }
  #[inline]
  pub fn add_is_after_sales(&mut self, is_after_sales: bool) {
    self.fbb_.push_slot::<bool>(Audience::VT_IS_AFTER_SALES, is_after_sales, false);
  }
  #[inline]
  pub fn add_is_after_market(&mut self, is_after_market: bool) {
    self.fbb_.push_slot::<bool>(Audience::VT_IS_AFTER_MARKET, is_after_market, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AudienceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AudienceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Audience<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Audience<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Audience");
      ds.field("enabled_audiences", &self.enabled_audiences());
      ds.field("disabled_audiences", &self.disabled_audiences());
      ds.field("is_supplier", &self.is_supplier());
      ds.field("is_development", &self.is_development());
      ds.field("is_manufacturing", &self.is_manufacturing());
      ds.field("is_after_sales", &self.is_after_sales());
      ds.field("is_after_market", &self.is_after_market());
      ds.finish()
  }
}
pub enum LeadingLengthInfoTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeadingLengthInfoType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeadingLengthInfoType<'a> {
  type Inner = LeadingLengthInfoType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> LeadingLengthInfoType<'a> {
  pub const VT_BIT_LENGTH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeadingLengthInfoType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LeadingLengthInfoTypeArgs
  ) -> flatbuffers::WIPOffset<LeadingLengthInfoType<'bldr>> {
    let mut builder = LeadingLengthInfoTypeBuilder::new(_fbb);
    builder.add_bit_length(args.bit_length);
    builder.finish()
  }


  #[inline]
  pub fn bit_length(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(LeadingLengthInfoType::VT_BIT_LENGTH, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LeadingLengthInfoType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("bit_length", Self::VT_BIT_LENGTH, false)?
     .finish();
    Ok(())
  }
}
pub struct LeadingLengthInfoTypeArgs {
    pub bit_length: u32,
}
impl<'a> Default for LeadingLengthInfoTypeArgs {
  #[inline]
  fn default() -> Self {
    LeadingLengthInfoTypeArgs {
      bit_length: 0,
    }
  }
}

pub struct LeadingLengthInfoTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeadingLengthInfoTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_bit_length(&mut self, bit_length: u32) {
    self.fbb_.push_slot::<u32>(LeadingLengthInfoType::VT_BIT_LENGTH, bit_length, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LeadingLengthInfoTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LeadingLengthInfoTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeadingLengthInfoType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeadingLengthInfoType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeadingLengthInfoType");
      ds.field("bit_length", &self.bit_length());
      ds.finish()
  }
}
pub enum MinMaxLengthTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MinMaxLengthType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MinMaxLengthType<'a> {
  type Inner = MinMaxLengthType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> MinMaxLengthType<'a> {
  pub const VT_MIN_LENGTH: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_LENGTH: flatbuffers::VOffsetT = 6;
  pub const VT_TERMINATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MinMaxLengthType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MinMaxLengthTypeArgs
  ) -> flatbuffers::WIPOffset<MinMaxLengthType<'bldr>> {
    let mut builder = MinMaxLengthTypeBuilder::new(_fbb);
    if let Some(x) = args.max_length { builder.add_max_length(x); }
    builder.add_min_length(args.min_length);
    builder.add_termination(args.termination);
    builder.finish()
  }


  #[inline]
  pub fn min_length(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MinMaxLengthType::VT_MIN_LENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_length(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MinMaxLengthType::VT_MAX_LENGTH, None)}
  }
  #[inline]
  pub fn termination(&self) -> Termination {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Termination>(MinMaxLengthType::VT_TERMINATION, Some(Termination::END_OF_PDU)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MinMaxLengthType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("min_length", Self::VT_MIN_LENGTH, false)?
     .visit_field::<u32>("max_length", Self::VT_MAX_LENGTH, false)?
     .visit_field::<Termination>("termination", Self::VT_TERMINATION, false)?
     .finish();
    Ok(())
  }
}
pub struct MinMaxLengthTypeArgs {
    pub min_length: u32,
    pub max_length: Option<u32>,
    pub termination: Termination,
}
impl<'a> Default for MinMaxLengthTypeArgs {
  #[inline]
  fn default() -> Self {
    MinMaxLengthTypeArgs {
      min_length: 0,
      max_length: None,
      termination: Termination::END_OF_PDU,
    }
  }
}

pub struct MinMaxLengthTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MinMaxLengthTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_min_length(&mut self, min_length: u32) {
    self.fbb_.push_slot::<u32>(MinMaxLengthType::VT_MIN_LENGTH, min_length, 0);
  }
  #[inline]
  pub fn add_max_length(&mut self, max_length: u32) {
    self.fbb_.push_slot_always::<u32>(MinMaxLengthType::VT_MAX_LENGTH, max_length);
  }
  #[inline]
  pub fn add_termination(&mut self, termination: Termination) {
    self.fbb_.push_slot::<Termination>(MinMaxLengthType::VT_TERMINATION, termination, Termination::END_OF_PDU);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MinMaxLengthTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MinMaxLengthTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MinMaxLengthType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MinMaxLengthType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MinMaxLengthType");
      ds.field("min_length", &self.min_length());
      ds.field("max_length", &self.max_length());
      ds.field("termination", &self.termination());
      ds.finish()
  }
}
pub enum ParamLengthInfoTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParamLengthInfoType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParamLengthInfoType<'a> {
  type Inner = ParamLengthInfoType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ParamLengthInfoType<'a> {
  pub const VT_LENGTH_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParamLengthInfoType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParamLengthInfoTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<ParamLengthInfoType<'bldr>> {
    let mut builder = ParamLengthInfoTypeBuilder::new(_fbb);
    if let Some(x) = args.length_key { builder.add_length_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn length_key(&self) -> Option<Param<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Param>>(ParamLengthInfoType::VT_LENGTH_KEY, None)}
  }
}

impl flatbuffers::Verifiable for ParamLengthInfoType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Param>>("length_key", Self::VT_LENGTH_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct ParamLengthInfoTypeArgs<'a> {
    pub length_key: Option<flatbuffers::WIPOffset<Param<'a>>>,
}
impl<'a> Default for ParamLengthInfoTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParamLengthInfoTypeArgs {
      length_key: None,
    }
  }
}

pub struct ParamLengthInfoTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParamLengthInfoTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_length_key(&mut self, length_key: flatbuffers::WIPOffset<Param<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Param>>(ParamLengthInfoType::VT_LENGTH_KEY, length_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParamLengthInfoTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParamLengthInfoTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParamLengthInfoType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParamLengthInfoType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParamLengthInfoType");
      ds.field("length_key", &self.length_key());
      ds.finish()
  }
}
pub enum StandardLengthTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardLengthType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardLengthType<'a> {
  type Inner = StandardLengthType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StandardLengthType<'a> {
  pub const VT_BIT_LENGTH: flatbuffers::VOffsetT = 4;
  pub const VT_BIT_MASK: flatbuffers::VOffsetT = 6;
  pub const VT_CONDENSED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardLengthType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardLengthTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardLengthType<'bldr>> {
    let mut builder = StandardLengthTypeBuilder::new(_fbb);
    if let Some(x) = args.bit_mask { builder.add_bit_mask(x); }
    builder.add_bit_length(args.bit_length);
    builder.add_condensed(args.condensed);
    builder.finish()
  }


  #[inline]
  pub fn bit_length(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StandardLengthType::VT_BIT_LENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bit_mask(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StandardLengthType::VT_BIT_MASK, None)}
  }
  #[inline]
  pub fn condensed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StandardLengthType::VT_CONDENSED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StandardLengthType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("bit_length", Self::VT_BIT_LENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bit_mask", Self::VT_BIT_MASK, false)?
     .visit_field::<bool>("condensed", Self::VT_CONDENSED, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardLengthTypeArgs<'a> {
    pub bit_length: u32,
    pub bit_mask: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub condensed: bool,
}
impl<'a> Default for StandardLengthTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardLengthTypeArgs {
      bit_length: 0,
      bit_mask: None,
      condensed: false,
    }
  }
}

pub struct StandardLengthTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardLengthTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_bit_length(&mut self, bit_length: u32) {
    self.fbb_.push_slot::<u32>(StandardLengthType::VT_BIT_LENGTH, bit_length, 0);
  }
  #[inline]
  pub fn add_bit_mask(&mut self, bit_mask: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardLengthType::VT_BIT_MASK, bit_mask);
  }
  #[inline]
  pub fn add_condensed(&mut self, condensed: bool) {
    self.fbb_.push_slot::<bool>(StandardLengthType::VT_CONDENSED, condensed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardLengthTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardLengthTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardLengthType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardLengthType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardLengthType");
      ds.field("bit_length", &self.bit_length());
      ds.field("bit_mask", &self.bit_mask());
      ds.field("condensed", &self.condensed());
      ds.finish()
  }
}
pub enum DiagCodedTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DiagCodedType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DiagCodedType<'a> {
  type Inner = DiagCodedType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DiagCodedType<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BASE_TYPE_ENCODING: flatbuffers::VOffsetT = 6;
  pub const VT_BASE_DATA_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_HIGH_LOW_BYTE_ORDER: flatbuffers::VOffsetT = 10;
  pub const VT_SPECIFIC_DATA_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_SPECIFIC_DATA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DiagCodedType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DiagCodedTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<DiagCodedType<'bldr>> {
    let mut builder = DiagCodedTypeBuilder::new(_fbb);
    if let Some(x) = args.specific_data { builder.add_specific_data(x); }
    if let Some(x) = args.base_type_encoding { builder.add_base_type_encoding(x); }
    builder.add_specific_data_type(args.specific_data_type);
    builder.add_is_high_low_byte_order(args.is_high_low_byte_order);
    builder.add_base_data_type(args.base_data_type);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> DiagCodedTypeName {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DiagCodedTypeName>(DiagCodedType::VT_TYPE_, Some(DiagCodedTypeName::LEADING_LENGTH_INFO_TYPE)).unwrap()}
  }
  #[inline]
  pub fn base_type_encoding(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiagCodedType::VT_BASE_TYPE_ENCODING, None)}
  }
  #[inline]
  pub fn base_data_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(DiagCodedType::VT_BASE_DATA_TYPE, Some(DataType::A_INT_32)).unwrap()}
  }
  #[inline]
  pub fn is_high_low_byte_order(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagCodedType::VT_IS_HIGH_LOW_BYTE_ORDER, Some(true)).unwrap()}
  }
  #[inline]
  pub fn specific_data_type(&self) -> SpecificDataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpecificDataType>(DiagCodedType::VT_SPECIFIC_DATA_TYPE, Some(SpecificDataType::NONE)).unwrap()}
  }
  #[inline]
  pub fn specific_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DiagCodedType::VT_SPECIFIC_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_leading_length_info_type(&self) -> Option<LeadingLengthInfoType<'a>> {
    if self.specific_data_type() == SpecificDataType::LeadingLengthInfoType {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LeadingLengthInfoType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_min_max_length_type(&self) -> Option<MinMaxLengthType<'a>> {
    if self.specific_data_type() == SpecificDataType::MinMaxLengthType {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MinMaxLengthType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_param_length_info_type(&self) -> Option<ParamLengthInfoType<'a>> {
    if self.specific_data_type() == SpecificDataType::ParamLengthInfoType {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ParamLengthInfoType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_standard_length_type(&self) -> Option<StandardLengthType<'a>> {
    if self.specific_data_type() == SpecificDataType::StandardLengthType {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StandardLengthType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DiagCodedType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DiagCodedTypeName>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("base_type_encoding", Self::VT_BASE_TYPE_ENCODING, false)?
     .visit_field::<DataType>("base_data_type", Self::VT_BASE_DATA_TYPE, false)?
     .visit_field::<bool>("is_high_low_byte_order", Self::VT_IS_HIGH_LOW_BYTE_ORDER, false)?
     .visit_union::<SpecificDataTypeUnionValue>("specific_data_type", Self::VT_SPECIFIC_DATA_TYPE, "specific_data", Self::VT_SPECIFIC_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct DiagCodedTypeArgs<'a> {
    pub type_: DiagCodedTypeName,
    pub base_type_encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub base_data_type: DataType,
    pub is_high_low_byte_order: bool,
    pub specific_data_type: SpecificDataType,
    pub specific_data: Option<flatbuffers::WIPOffset<SpecificDataTypeUnionValue>>,
}
impl<'a> Default for DiagCodedTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    DiagCodedTypeArgs {
      type_: DiagCodedTypeName::LEADING_LENGTH_INFO_TYPE,
      base_type_encoding: None,
      base_data_type: DataType::A_INT_32,
      is_high_low_byte_order: true,
      specific_data_type: SpecificDataType::NONE,
      specific_data: None,
    }
  }
}

pub struct DiagCodedTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiagCodedTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: DiagCodedTypeName) {
    self.fbb_.push_slot::<DiagCodedTypeName>(DiagCodedType::VT_TYPE_, type_, DiagCodedTypeName::LEADING_LENGTH_INFO_TYPE);
  }
  #[inline]
  pub fn add_base_type_encoding(&mut self, base_type_encoding: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagCodedType::VT_BASE_TYPE_ENCODING, base_type_encoding);
  }
  #[inline]
  pub fn add_base_data_type(&mut self, base_data_type: DataType) {
    self.fbb_.push_slot::<DataType>(DiagCodedType::VT_BASE_DATA_TYPE, base_data_type, DataType::A_INT_32);
  }
  #[inline]
  pub fn add_is_high_low_byte_order(&mut self, is_high_low_byte_order: bool) {
    self.fbb_.push_slot::<bool>(DiagCodedType::VT_IS_HIGH_LOW_BYTE_ORDER, is_high_low_byte_order, true);
  }
  #[inline]
  pub fn add_specific_data_type(&mut self, specific_data_type: SpecificDataType) {
    self.fbb_.push_slot::<SpecificDataType>(DiagCodedType::VT_SPECIFIC_DATA_TYPE, specific_data_type, SpecificDataType::NONE);
  }
  #[inline]
  pub fn add_specific_data(&mut self, specific_data: flatbuffers::WIPOffset<SpecificDataTypeUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagCodedType::VT_SPECIFIC_DATA, specific_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DiagCodedTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DiagCodedTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DiagCodedType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DiagCodedType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DiagCodedType");
      ds.field("type_", &self.type_());
      ds.field("base_type_encoding", &self.base_type_encoding());
      ds.field("base_data_type", &self.base_data_type());
      ds.field("is_high_low_byte_order", &self.is_high_low_byte_order());
      ds.field("specific_data_type", &self.specific_data_type());
      match self.specific_data_type() {
        SpecificDataType::LeadingLengthInfoType => {
          if let Some(x) = self.specific_data_as_leading_length_info_type() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDataType::MinMaxLengthType => {
          if let Some(x) = self.specific_data_as_min_max_length_type() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDataType::ParamLengthInfoType => {
          if let Some(x) = self.specific_data_as_param_length_info_type() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDataType::StandardLengthType => {
          if let Some(x) = self.specific_data_as_standard_length_type() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("specific_data", &x)
        },
      };
      ds.finish()
  }
}
pub enum TextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Text<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Text<'a> {
  type Inner = Text<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Text<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_TI: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Text { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextArgs<'args>
  ) -> flatbuffers::WIPOffset<Text<'bldr>> {
    let mut builder = TextBuilder::new(_fbb);
    if let Some(x) = args.ti { builder.add_ti(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_VALUE, None)}
  }
  #[inline]
  pub fn ti(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_TI, None)}
  }
}

impl flatbuffers::Verifiable for Text<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ti", Self::VT_TI, false)?
     .finish();
    Ok(())
  }
}
pub struct TextArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ti: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TextArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextArgs {
      value: None,
      ti: None,
    }
  }
}

pub struct TextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Text::VT_VALUE, value);
  }
  #[inline]
  pub fn add_ti(&mut self, ti: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Text::VT_TI, ti);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Text<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Text<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Text");
      ds.field("value", &self.value());
      ds.field("ti", &self.ti());
      ds.finish()
  }
}
pub enum LimitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Limit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Limit<'a> {
  type Inner = Limit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Limit<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_INTERVAL_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Limit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LimitArgs<'args>
  ) -> flatbuffers::WIPOffset<Limit<'bldr>> {
    let mut builder = LimitBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_interval_type(args.interval_type);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Limit::VT_VALUE, None)}
  }
  #[inline]
  pub fn interval_type(&self) -> IntervalType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IntervalType>(Limit::VT_INTERVAL_TYPE, Some(IntervalType::OPEN)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Limit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<IntervalType>("interval_type", Self::VT_INTERVAL_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct LimitArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub interval_type: IntervalType,
}
impl<'a> Default for LimitArgs<'a> {
  #[inline]
  fn default() -> Self {
    LimitArgs {
      value: None,
      interval_type: IntervalType::OPEN,
    }
  }
}

pub struct LimitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LimitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Limit::VT_VALUE, value);
  }
  #[inline]
  pub fn add_interval_type(&mut self, interval_type: IntervalType) {
    self.fbb_.push_slot::<IntervalType>(Limit::VT_INTERVAL_TYPE, interval_type, IntervalType::OPEN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LimitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LimitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Limit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Limit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Limit");
      ds.field("value", &self.value());
      ds.field("interval_type", &self.interval_type());
      ds.finish()
  }
}
pub enum CompuValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuValues<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuValues<'a> {
  type Inner = CompuValues<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuValues<'a> {
  pub const VT_V: flatbuffers::VOffsetT = 4;
  pub const VT_VT: flatbuffers::VOffsetT = 6;
  pub const VT_VT_TI: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuValues { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuValuesArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuValues<'bldr>> {
    let mut builder = CompuValuesBuilder::new(_fbb);
    if let Some(x) = args.v { builder.add_v(x); }
    if let Some(x) = args.vt_ti { builder.add_vt_ti(x); }
    if let Some(x) = args.vt { builder.add_vt(x); }
    builder.finish()
  }


  #[inline]
  pub fn v(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CompuValues::VT_V, None)}
  }
  #[inline]
  pub fn vt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CompuValues::VT_VT, None)}
  }
  #[inline]
  pub fn vt_ti(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CompuValues::VT_VT_TI, None)}
  }
}

impl flatbuffers::Verifiable for CompuValues<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("v", Self::VT_V, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vt", Self::VT_VT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("vt_ti", Self::VT_VT_TI, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuValuesArgs<'a> {
    pub v: Option<f64>,
    pub vt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vt_ti: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CompuValuesArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuValuesArgs {
      v: None,
      vt: None,
      vt_ti: None,
    }
  }
}

pub struct CompuValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuValuesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_v(&mut self, v: f64) {
    self.fbb_.push_slot_always::<f64>(CompuValues::VT_V, v);
  }
  #[inline]
  pub fn add_vt(&mut self, vt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuValues::VT_VT, vt);
  }
  #[inline]
  pub fn add_vt_ti(&mut self, vt_ti: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuValues::VT_VT_TI, vt_ti);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuValuesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuValues<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuValues<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuValues");
      ds.field("v", &self.v());
      ds.field("vt", &self.vt());
      ds.field("vt_ti", &self.vt_ti());
      ds.finish()
  }
}
pub enum CompuRationalCoEffsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuRationalCoEffs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuRationalCoEffs<'a> {
  type Inner = CompuRationalCoEffs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuRationalCoEffs<'a> {
  pub const VT_NUMERATOR: flatbuffers::VOffsetT = 4;
  pub const VT_DENOMINATOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuRationalCoEffs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuRationalCoEffsArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuRationalCoEffs<'bldr>> {
    let mut builder = CompuRationalCoEffsBuilder::new(_fbb);
    if let Some(x) = args.denominator { builder.add_denominator(x); }
    if let Some(x) = args.numerator { builder.add_numerator(x); }
    builder.finish()
  }


  #[inline]
  pub fn numerator(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CompuRationalCoEffs::VT_NUMERATOR, None)}
  }
  #[inline]
  pub fn denominator(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CompuRationalCoEffs::VT_DENOMINATOR, None)}
  }
}

impl flatbuffers::Verifiable for CompuRationalCoEffs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("numerator", Self::VT_NUMERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("denominator", Self::VT_DENOMINATOR, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuRationalCoEffsArgs<'a> {
    pub numerator: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub denominator: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for CompuRationalCoEffsArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuRationalCoEffsArgs {
      numerator: None,
      denominator: None,
    }
  }
}

pub struct CompuRationalCoEffsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuRationalCoEffsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_numerator(&mut self, numerator: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuRationalCoEffs::VT_NUMERATOR, numerator);
  }
  #[inline]
  pub fn add_denominator(&mut self, denominator: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuRationalCoEffs::VT_DENOMINATOR, denominator);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuRationalCoEffsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuRationalCoEffsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuRationalCoEffs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuRationalCoEffs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuRationalCoEffs");
      ds.field("numerator", &self.numerator());
      ds.field("denominator", &self.denominator());
      ds.finish()
  }
}
pub enum CompuScaleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuScale<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuScale<'a> {
  type Inner = CompuScale<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuScale<'a> {
  pub const VT_SHORT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_LOWER_LIMIT: flatbuffers::VOffsetT = 6;
  pub const VT_UPPER_LIMIT: flatbuffers::VOffsetT = 8;
  pub const VT_INVERSE_VALUES: flatbuffers::VOffsetT = 10;
  pub const VT_CONSTS: flatbuffers::VOffsetT = 12;
  pub const VT_RATIONAL_CO_EFFS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuScale { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuScaleArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuScale<'bldr>> {
    let mut builder = CompuScaleBuilder::new(_fbb);
    if let Some(x) = args.rational_co_effs { builder.add_rational_co_effs(x); }
    if let Some(x) = args.consts { builder.add_consts(x); }
    if let Some(x) = args.inverse_values { builder.add_inverse_values(x); }
    if let Some(x) = args.upper_limit { builder.add_upper_limit(x); }
    if let Some(x) = args.lower_limit { builder.add_lower_limit(x); }
    if let Some(x) = args.short_label { builder.add_short_label(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_label(&self) -> Option<Text<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Text>>(CompuScale::VT_SHORT_LABEL, None)}
  }
  #[inline]
  pub fn lower_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(CompuScale::VT_LOWER_LIMIT, None)}
  }
  #[inline]
  pub fn upper_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(CompuScale::VT_UPPER_LIMIT, None)}
  }
  #[inline]
  pub fn inverse_values(&self) -> Option<CompuValues<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuValues>>(CompuScale::VT_INVERSE_VALUES, None)}
  }
  #[inline]
  pub fn consts(&self) -> Option<CompuValues<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuValues>>(CompuScale::VT_CONSTS, None)}
  }
  #[inline]
  pub fn rational_co_effs(&self) -> Option<CompuRationalCoEffs<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuRationalCoEffs>>(CompuScale::VT_RATIONAL_CO_EFFS, None)}
  }
}

impl flatbuffers::Verifiable for CompuScale<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Text>>("short_label", Self::VT_SHORT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("lower_limit", Self::VT_LOWER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("upper_limit", Self::VT_UPPER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuValues>>("inverse_values", Self::VT_INVERSE_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuValues>>("consts", Self::VT_CONSTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuRationalCoEffs>>("rational_co_effs", Self::VT_RATIONAL_CO_EFFS, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuScaleArgs<'a> {
    pub short_label: Option<flatbuffers::WIPOffset<Text<'a>>>,
    pub lower_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub upper_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub inverse_values: Option<flatbuffers::WIPOffset<CompuValues<'a>>>,
    pub consts: Option<flatbuffers::WIPOffset<CompuValues<'a>>>,
    pub rational_co_effs: Option<flatbuffers::WIPOffset<CompuRationalCoEffs<'a>>>,
}
impl<'a> Default for CompuScaleArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuScaleArgs {
      short_label: None,
      lower_limit: None,
      upper_limit: None,
      inverse_values: None,
      consts: None,
      rational_co_effs: None,
    }
  }
}

pub struct CompuScaleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuScaleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_label(&mut self, short_label: flatbuffers::WIPOffset<Text<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Text>>(CompuScale::VT_SHORT_LABEL, short_label);
  }
  #[inline]
  pub fn add_lower_limit(&mut self, lower_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(CompuScale::VT_LOWER_LIMIT, lower_limit);
  }
  #[inline]
  pub fn add_upper_limit(&mut self, upper_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(CompuScale::VT_UPPER_LIMIT, upper_limit);
  }
  #[inline]
  pub fn add_inverse_values(&mut self, inverse_values: flatbuffers::WIPOffset<CompuValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuValues>>(CompuScale::VT_INVERSE_VALUES, inverse_values);
  }
  #[inline]
  pub fn add_consts(&mut self, consts: flatbuffers::WIPOffset<CompuValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuValues>>(CompuScale::VT_CONSTS, consts);
  }
  #[inline]
  pub fn add_rational_co_effs(&mut self, rational_co_effs: flatbuffers::WIPOffset<CompuRationalCoEffs<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuRationalCoEffs>>(CompuScale::VT_RATIONAL_CO_EFFS, rational_co_effs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuScaleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuScaleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuScale<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuScale<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuScale");
      ds.field("short_label", &self.short_label());
      ds.field("lower_limit", &self.lower_limit());
      ds.field("upper_limit", &self.upper_limit());
      ds.field("inverse_values", &self.inverse_values());
      ds.field("consts", &self.consts());
      ds.field("rational_co_effs", &self.rational_co_effs());
      ds.finish()
  }
}
pub enum CompuDefaultValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuDefaultValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuDefaultValue<'a> {
  type Inner = CompuDefaultValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuDefaultValue<'a> {
  pub const VT_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_INVERSE_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuDefaultValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuDefaultValueArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuDefaultValue<'bldr>> {
    let mut builder = CompuDefaultValueBuilder::new(_fbb);
    if let Some(x) = args.inverse_values { builder.add_inverse_values(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn values(&self) -> Option<CompuValues<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuValues>>(CompuDefaultValue::VT_VALUES, None)}
  }
  #[inline]
  pub fn inverse_values(&self) -> Option<CompuValues<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuValues>>(CompuDefaultValue::VT_INVERSE_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for CompuDefaultValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuValues>>("values", Self::VT_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuValues>>("inverse_values", Self::VT_INVERSE_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuDefaultValueArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<CompuValues<'a>>>,
    pub inverse_values: Option<flatbuffers::WIPOffset<CompuValues<'a>>>,
}
impl<'a> Default for CompuDefaultValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuDefaultValueArgs {
      values: None,
      inverse_values: None,
    }
  }
}

pub struct CompuDefaultValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuDefaultValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<CompuValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuValues>>(CompuDefaultValue::VT_VALUES, values);
  }
  #[inline]
  pub fn add_inverse_values(&mut self, inverse_values: flatbuffers::WIPOffset<CompuValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuValues>>(CompuDefaultValue::VT_INVERSE_VALUES, inverse_values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuDefaultValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuDefaultValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuDefaultValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuDefaultValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuDefaultValue");
      ds.field("values", &self.values());
      ds.field("inverse_values", &self.inverse_values());
      ds.finish()
  }
}
pub enum CompuInternalToPhysOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuInternalToPhys<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuInternalToPhys<'a> {
  type Inner = CompuInternalToPhys<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuInternalToPhys<'a> {
  pub const VT_COMPU_SCALES: flatbuffers::VOffsetT = 4;
  pub const VT_PROG_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_COMPU_DEFAULT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuInternalToPhys { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuInternalToPhysArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuInternalToPhys<'bldr>> {
    let mut builder = CompuInternalToPhysBuilder::new(_fbb);
    if let Some(x) = args.compu_default_value { builder.add_compu_default_value(x); }
    if let Some(x) = args.prog_code { builder.add_prog_code(x); }
    if let Some(x) = args.compu_scales { builder.add_compu_scales(x); }
    builder.finish()
  }


  #[inline]
  pub fn compu_scales(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale>>>>(CompuInternalToPhys::VT_COMPU_SCALES, None)}
  }
  #[inline]
  pub fn prog_code(&self) -> Option<ProgCode<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProgCode>>(CompuInternalToPhys::VT_PROG_CODE, None)}
  }
  #[inline]
  pub fn compu_default_value(&self) -> Option<CompuDefaultValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuDefaultValue>>(CompuInternalToPhys::VT_COMPU_DEFAULT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for CompuInternalToPhys<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompuScale>>>>("compu_scales", Self::VT_COMPU_SCALES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProgCode>>("prog_code", Self::VT_PROG_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuDefaultValue>>("compu_default_value", Self::VT_COMPU_DEFAULT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuInternalToPhysArgs<'a> {
    pub compu_scales: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale<'a>>>>>,
    pub prog_code: Option<flatbuffers::WIPOffset<ProgCode<'a>>>,
    pub compu_default_value: Option<flatbuffers::WIPOffset<CompuDefaultValue<'a>>>,
}
impl<'a> Default for CompuInternalToPhysArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuInternalToPhysArgs {
      compu_scales: None,
      prog_code: None,
      compu_default_value: None,
    }
  }
}

pub struct CompuInternalToPhysBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuInternalToPhysBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_compu_scales(&mut self, compu_scales: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CompuScale<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuInternalToPhys::VT_COMPU_SCALES, compu_scales);
  }
  #[inline]
  pub fn add_prog_code(&mut self, prog_code: flatbuffers::WIPOffset<ProgCode<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProgCode>>(CompuInternalToPhys::VT_PROG_CODE, prog_code);
  }
  #[inline]
  pub fn add_compu_default_value(&mut self, compu_default_value: flatbuffers::WIPOffset<CompuDefaultValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuDefaultValue>>(CompuInternalToPhys::VT_COMPU_DEFAULT_VALUE, compu_default_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuInternalToPhysBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuInternalToPhysBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuInternalToPhys<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuInternalToPhys<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuInternalToPhys");
      ds.field("compu_scales", &self.compu_scales());
      ds.field("prog_code", &self.prog_code());
      ds.field("compu_default_value", &self.compu_default_value());
      ds.finish()
  }
}
pub enum CompuPhysToInternalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuPhysToInternal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuPhysToInternal<'a> {
  type Inner = CompuPhysToInternal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuPhysToInternal<'a> {
  pub const VT_PROG_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_COMPU_SCALES: flatbuffers::VOffsetT = 6;
  pub const VT_COMPU_DEFAULT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuPhysToInternal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuPhysToInternalArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuPhysToInternal<'bldr>> {
    let mut builder = CompuPhysToInternalBuilder::new(_fbb);
    if let Some(x) = args.compu_default_value { builder.add_compu_default_value(x); }
    if let Some(x) = args.compu_scales { builder.add_compu_scales(x); }
    if let Some(x) = args.prog_code { builder.add_prog_code(x); }
    builder.finish()
  }


  #[inline]
  pub fn prog_code(&self) -> Option<ProgCode<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProgCode>>(CompuPhysToInternal::VT_PROG_CODE, None)}
  }
  #[inline]
  pub fn compu_scales(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale>>>>(CompuPhysToInternal::VT_COMPU_SCALES, None)}
  }
  #[inline]
  pub fn compu_default_value(&self) -> Option<CompuDefaultValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuDefaultValue>>(CompuPhysToInternal::VT_COMPU_DEFAULT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for CompuPhysToInternal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProgCode>>("prog_code", Self::VT_PROG_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CompuScale>>>>("compu_scales", Self::VT_COMPU_SCALES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuDefaultValue>>("compu_default_value", Self::VT_COMPU_DEFAULT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuPhysToInternalArgs<'a> {
    pub prog_code: Option<flatbuffers::WIPOffset<ProgCode<'a>>>,
    pub compu_scales: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CompuScale<'a>>>>>,
    pub compu_default_value: Option<flatbuffers::WIPOffset<CompuDefaultValue<'a>>>,
}
impl<'a> Default for CompuPhysToInternalArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuPhysToInternalArgs {
      prog_code: None,
      compu_scales: None,
      compu_default_value: None,
    }
  }
}

pub struct CompuPhysToInternalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuPhysToInternalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_prog_code(&mut self, prog_code: flatbuffers::WIPOffset<ProgCode<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProgCode>>(CompuPhysToInternal::VT_PROG_CODE, prog_code);
  }
  #[inline]
  pub fn add_compu_scales(&mut self, compu_scales: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CompuScale<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompuPhysToInternal::VT_COMPU_SCALES, compu_scales);
  }
  #[inline]
  pub fn add_compu_default_value(&mut self, compu_default_value: flatbuffers::WIPOffset<CompuDefaultValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuDefaultValue>>(CompuPhysToInternal::VT_COMPU_DEFAULT_VALUE, compu_default_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuPhysToInternalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuPhysToInternalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuPhysToInternal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuPhysToInternal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuPhysToInternal");
      ds.field("prog_code", &self.prog_code());
      ds.field("compu_scales", &self.compu_scales());
      ds.field("compu_default_value", &self.compu_default_value());
      ds.finish()
  }
}
pub enum CompuMethodOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CompuMethod<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompuMethod<'a> {
  type Inner = CompuMethod<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CompuMethod<'a> {
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 4;
  pub const VT_INTERNAL_TO_PHYS: flatbuffers::VOffsetT = 6;
  pub const VT_PHYS_TO_INTERNAL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CompuMethod { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CompuMethodArgs<'args>
  ) -> flatbuffers::WIPOffset<CompuMethod<'bldr>> {
    let mut builder = CompuMethodBuilder::new(_fbb);
    if let Some(x) = args.phys_to_internal { builder.add_phys_to_internal(x); }
    if let Some(x) = args.internal_to_phys { builder.add_internal_to_phys(x); }
    builder.add_category(args.category);
    builder.finish()
  }


  #[inline]
  pub fn category(&self) -> CompuCategory {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CompuCategory>(CompuMethod::VT_CATEGORY, Some(CompuCategory::IDENTICAL)).unwrap()}
  }
  #[inline]
  pub fn internal_to_phys(&self) -> Option<CompuInternalToPhys<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuInternalToPhys>>(CompuMethod::VT_INTERNAL_TO_PHYS, None)}
  }
  #[inline]
  pub fn phys_to_internal(&self) -> Option<CompuPhysToInternal<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuPhysToInternal>>(CompuMethod::VT_PHYS_TO_INTERNAL, None)}
  }
}

impl flatbuffers::Verifiable for CompuMethod<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CompuCategory>("category", Self::VT_CATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuInternalToPhys>>("internal_to_phys", Self::VT_INTERNAL_TO_PHYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuPhysToInternal>>("phys_to_internal", Self::VT_PHYS_TO_INTERNAL, false)?
     .finish();
    Ok(())
  }
}
pub struct CompuMethodArgs<'a> {
    pub category: CompuCategory,
    pub internal_to_phys: Option<flatbuffers::WIPOffset<CompuInternalToPhys<'a>>>,
    pub phys_to_internal: Option<flatbuffers::WIPOffset<CompuPhysToInternal<'a>>>,
}
impl<'a> Default for CompuMethodArgs<'a> {
  #[inline]
  fn default() -> Self {
    CompuMethodArgs {
      category: CompuCategory::IDENTICAL,
      internal_to_phys: None,
      phys_to_internal: None,
    }
  }
}

pub struct CompuMethodBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CompuMethodBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_category(&mut self, category: CompuCategory) {
    self.fbb_.push_slot::<CompuCategory>(CompuMethod::VT_CATEGORY, category, CompuCategory::IDENTICAL);
  }
  #[inline]
  pub fn add_internal_to_phys(&mut self, internal_to_phys: flatbuffers::WIPOffset<CompuInternalToPhys<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuInternalToPhys>>(CompuMethod::VT_INTERNAL_TO_PHYS, internal_to_phys);
  }
  #[inline]
  pub fn add_phys_to_internal(&mut self, phys_to_internal: flatbuffers::WIPOffset<CompuPhysToInternal<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuPhysToInternal>>(CompuMethod::VT_PHYS_TO_INTERNAL, phys_to_internal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CompuMethodBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CompuMethodBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompuMethod<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CompuMethod<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CompuMethod");
      ds.field("category", &self.category());
      ds.field("internal_to_phys", &self.internal_to_phys());
      ds.field("phys_to_internal", &self.phys_to_internal());
      ds.finish()
  }
}
pub enum PhysicalTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PhysicalType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PhysicalType<'a> {
  type Inner = PhysicalType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PhysicalType<'a> {
  pub const VT_PRECISION: flatbuffers::VOffsetT = 4;
  pub const VT_BASE_DATA_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DISPLAY_RADIX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PhysicalType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PhysicalTypeArgs
  ) -> flatbuffers::WIPOffset<PhysicalType<'bldr>> {
    let mut builder = PhysicalTypeBuilder::new(_fbb);
    if let Some(x) = args.precision { builder.add_precision(x); }
    builder.add_display_radix(args.display_radix);
    builder.add_base_data_type(args.base_data_type);
    builder.finish()
  }


  #[inline]
  pub fn precision(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PhysicalType::VT_PRECISION, None)}
  }
  #[inline]
  pub fn base_data_type(&self) -> PhysicalTypeDataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PhysicalTypeDataType>(PhysicalType::VT_BASE_DATA_TYPE, Some(PhysicalTypeDataType::A_INT_32)).unwrap()}
  }
  #[inline]
  pub fn display_radix(&self) -> Radix {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Radix>(PhysicalType::VT_DISPLAY_RADIX, Some(Radix::HEX)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PhysicalType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("precision", Self::VT_PRECISION, false)?
     .visit_field::<PhysicalTypeDataType>("base_data_type", Self::VT_BASE_DATA_TYPE, false)?
     .visit_field::<Radix>("display_radix", Self::VT_DISPLAY_RADIX, false)?
     .finish();
    Ok(())
  }
}
pub struct PhysicalTypeArgs {
    pub precision: Option<u32>,
    pub base_data_type: PhysicalTypeDataType,
    pub display_radix: Radix,
}
impl<'a> Default for PhysicalTypeArgs {
  #[inline]
  fn default() -> Self {
    PhysicalTypeArgs {
      precision: None,
      base_data_type: PhysicalTypeDataType::A_INT_32,
      display_radix: Radix::HEX,
    }
  }
}

pub struct PhysicalTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PhysicalTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_precision(&mut self, precision: u32) {
    self.fbb_.push_slot_always::<u32>(PhysicalType::VT_PRECISION, precision);
  }
  #[inline]
  pub fn add_base_data_type(&mut self, base_data_type: PhysicalTypeDataType) {
    self.fbb_.push_slot::<PhysicalTypeDataType>(PhysicalType::VT_BASE_DATA_TYPE, base_data_type, PhysicalTypeDataType::A_INT_32);
  }
  #[inline]
  pub fn add_display_radix(&mut self, display_radix: Radix) {
    self.fbb_.push_slot::<Radix>(PhysicalType::VT_DISPLAY_RADIX, display_radix, Radix::HEX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PhysicalTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PhysicalTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PhysicalType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PhysicalType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PhysicalType");
      ds.field("precision", &self.precision());
      ds.field("base_data_type", &self.base_data_type());
      ds.field("display_radix", &self.display_radix());
      ds.finish()
  }
}
pub enum UnitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unit<'a> {
  type Inner = Unit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Unit<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DISPLAY_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_FACTORSITOUNIT: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSETITOUNIT: flatbuffers::VOffsetT = 10;
  pub const VT_PHYSICAL_DIMENSION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnitArgs<'args>
  ) -> flatbuffers::WIPOffset<Unit<'bldr>> {
    let mut builder = UnitBuilder::new(_fbb);
    if let Some(x) = args.offsetitounit { builder.add_offsetitounit(x); }
    if let Some(x) = args.factorsitounit { builder.add_factorsitounit(x); }
    if let Some(x) = args.physical_dimension { builder.add_physical_dimension(x); }
    if let Some(x) = args.display_name { builder.add_display_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unit::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn display_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unit::VT_DISPLAY_NAME, None)}
  }
  #[inline]
  pub fn factorsitounit(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Unit::VT_FACTORSITOUNIT, None)}
  }
  #[inline]
  pub fn offsetitounit(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Unit::VT_OFFSETITOUNIT, None)}
  }
  #[inline]
  pub fn physical_dimension(&self) -> Option<PhysicalDimension<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PhysicalDimension>>(Unit::VT_PHYSICAL_DIMENSION, None)}
  }
}

impl flatbuffers::Verifiable for Unit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name", Self::VT_DISPLAY_NAME, false)?
     .visit_field::<f64>("factorsitounit", Self::VT_FACTORSITOUNIT, false)?
     .visit_field::<f64>("offsetitounit", Self::VT_OFFSETITOUNIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PhysicalDimension>>("physical_dimension", Self::VT_PHYSICAL_DIMENSION, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub factorsitounit: Option<f64>,
    pub offsetitounit: Option<f64>,
    pub physical_dimension: Option<flatbuffers::WIPOffset<PhysicalDimension<'a>>>,
}
impl<'a> Default for UnitArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnitArgs {
      short_name: None,
      display_name: None,
      factorsitounit: None,
      offsetitounit: None,
      physical_dimension: None,
    }
  }
}

pub struct UnitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unit::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_display_name(&mut self, display_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unit::VT_DISPLAY_NAME, display_name);
  }
  #[inline]
  pub fn add_factorsitounit(&mut self, factorsitounit: f64) {
    self.fbb_.push_slot_always::<f64>(Unit::VT_FACTORSITOUNIT, factorsitounit);
  }
  #[inline]
  pub fn add_offsetitounit(&mut self, offsetitounit: f64) {
    self.fbb_.push_slot_always::<f64>(Unit::VT_OFFSETITOUNIT, offsetitounit);
  }
  #[inline]
  pub fn add_physical_dimension(&mut self, physical_dimension: flatbuffers::WIPOffset<PhysicalDimension<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PhysicalDimension>>(Unit::VT_PHYSICAL_DIMENSION, physical_dimension);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unit");
      ds.field("short_name", &self.short_name());
      ds.field("display_name", &self.display_name());
      ds.field("factorsitounit", &self.factorsitounit());
      ds.field("offsetitounit", &self.offsetitounit());
      ds.field("physical_dimension", &self.physical_dimension());
      ds.finish()
  }
}
pub enum ScaleConstrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScaleConstr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScaleConstr<'a> {
  type Inner = ScaleConstr<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ScaleConstr<'a> {
  pub const VT_SHORT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_LOWER_LIMIT: flatbuffers::VOffsetT = 6;
  pub const VT_UPPER_LIMIT: flatbuffers::VOffsetT = 8;
  pub const VT_VALIDITY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScaleConstr { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScaleConstrArgs<'args>
  ) -> flatbuffers::WIPOffset<ScaleConstr<'bldr>> {
    let mut builder = ScaleConstrBuilder::new(_fbb);
    if let Some(x) = args.upper_limit { builder.add_upper_limit(x); }
    if let Some(x) = args.lower_limit { builder.add_lower_limit(x); }
    if let Some(x) = args.short_label { builder.add_short_label(x); }
    builder.add_validity(args.validity);
    builder.finish()
  }


  #[inline]
  pub fn short_label(&self) -> Option<Text<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Text>>(ScaleConstr::VT_SHORT_LABEL, None)}
  }
  #[inline]
  pub fn lower_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(ScaleConstr::VT_LOWER_LIMIT, None)}
  }
  #[inline]
  pub fn upper_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(ScaleConstr::VT_UPPER_LIMIT, None)}
  }
  #[inline]
  pub fn validity(&self) -> ValidType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValidType>(ScaleConstr::VT_VALIDITY, Some(ValidType::VALID)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScaleConstr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Text>>("short_label", Self::VT_SHORT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("lower_limit", Self::VT_LOWER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("upper_limit", Self::VT_UPPER_LIMIT, false)?
     .visit_field::<ValidType>("validity", Self::VT_VALIDITY, false)?
     .finish();
    Ok(())
  }
}
pub struct ScaleConstrArgs<'a> {
    pub short_label: Option<flatbuffers::WIPOffset<Text<'a>>>,
    pub lower_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub upper_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub validity: ValidType,
}
impl<'a> Default for ScaleConstrArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScaleConstrArgs {
      short_label: None,
      lower_limit: None,
      upper_limit: None,
      validity: ValidType::VALID,
    }
  }
}

pub struct ScaleConstrBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScaleConstrBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_label(&mut self, short_label: flatbuffers::WIPOffset<Text<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Text>>(ScaleConstr::VT_SHORT_LABEL, short_label);
  }
  #[inline]
  pub fn add_lower_limit(&mut self, lower_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(ScaleConstr::VT_LOWER_LIMIT, lower_limit);
  }
  #[inline]
  pub fn add_upper_limit(&mut self, upper_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(ScaleConstr::VT_UPPER_LIMIT, upper_limit);
  }
  #[inline]
  pub fn add_validity(&mut self, validity: ValidType) {
    self.fbb_.push_slot::<ValidType>(ScaleConstr::VT_VALIDITY, validity, ValidType::VALID);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScaleConstrBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScaleConstrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScaleConstr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScaleConstr<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScaleConstr");
      ds.field("short_label", &self.short_label());
      ds.field("lower_limit", &self.lower_limit());
      ds.field("upper_limit", &self.upper_limit());
      ds.field("validity", &self.validity());
      ds.finish()
  }
}
pub enum InternalConstrOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InternalConstr<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InternalConstr<'a> {
  type Inner = InternalConstr<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> InternalConstr<'a> {
  pub const VT_LOWER_LIMIT: flatbuffers::VOffsetT = 4;
  pub const VT_UPPER_LIMIT: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE_CONSTR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InternalConstr { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InternalConstrArgs<'args>
  ) -> flatbuffers::WIPOffset<InternalConstr<'bldr>> {
    let mut builder = InternalConstrBuilder::new(_fbb);
    if let Some(x) = args.scale_constr { builder.add_scale_constr(x); }
    if let Some(x) = args.upper_limit { builder.add_upper_limit(x); }
    if let Some(x) = args.lower_limit { builder.add_lower_limit(x); }
    builder.finish()
  }


  #[inline]
  pub fn lower_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(InternalConstr::VT_LOWER_LIMIT, None)}
  }
  #[inline]
  pub fn upper_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(InternalConstr::VT_UPPER_LIMIT, None)}
  }
  #[inline]
  pub fn scale_constr(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScaleConstr<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScaleConstr>>>>(InternalConstr::VT_SCALE_CONSTR, None)}
  }
}

impl flatbuffers::Verifiable for InternalConstr<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("lower_limit", Self::VT_LOWER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("upper_limit", Self::VT_UPPER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ScaleConstr>>>>("scale_constr", Self::VT_SCALE_CONSTR, false)?
     .finish();
    Ok(())
  }
}
pub struct InternalConstrArgs<'a> {
    pub lower_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub upper_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub scale_constr: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ScaleConstr<'a>>>>>,
}
impl<'a> Default for InternalConstrArgs<'a> {
  #[inline]
  fn default() -> Self {
    InternalConstrArgs {
      lower_limit: None,
      upper_limit: None,
      scale_constr: None,
    }
  }
}

pub struct InternalConstrBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InternalConstrBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lower_limit(&mut self, lower_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(InternalConstr::VT_LOWER_LIMIT, lower_limit);
  }
  #[inline]
  pub fn add_upper_limit(&mut self, upper_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(InternalConstr::VT_UPPER_LIMIT, upper_limit);
  }
  #[inline]
  pub fn add_scale_constr(&mut self, scale_constr: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ScaleConstr<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InternalConstr::VT_SCALE_CONSTR, scale_constr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InternalConstrBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InternalConstrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InternalConstr<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InternalConstr<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InternalConstr");
      ds.field("lower_limit", &self.lower_limit());
      ds.field("upper_limit", &self.upper_limit());
      ds.field("scale_constr", &self.scale_constr());
      ds.finish()
  }
}
pub enum DTCOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DTC<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DTC<'a> {
  type Inner = DTC<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DTC<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TROUBLE_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_DISPLAY_TROUBLE_CODE: flatbuffers::VOffsetT = 8;
  pub const VT_TEXT: flatbuffers::VOffsetT = 10;
  pub const VT_LEVEL: flatbuffers::VOffsetT = 12;
  pub const VT_SDGS: flatbuffers::VOffsetT = 14;
  pub const VT_IS_TEMPORARY: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DTC { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DTCArgs<'args>
  ) -> flatbuffers::WIPOffset<DTC<'bldr>> {
    let mut builder = DTCBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.level { builder.add_level(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.display_trouble_code { builder.add_display_trouble_code(x); }
    builder.add_trouble_code(args.trouble_code);
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_is_temporary(args.is_temporary);
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DTC::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn trouble_code(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DTC::VT_TROUBLE_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn display_trouble_code(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DTC::VT_DISPLAY_TROUBLE_CODE, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<Text<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Text>>(DTC::VT_TEXT, None)}
  }
  #[inline]
  pub fn level(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DTC::VT_LEVEL, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(DTC::VT_SDGS, None)}
  }
  #[inline]
  pub fn is_temporary(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DTC::VT_IS_TEMPORARY, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DTC<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<u32>("trouble_code", Self::VT_TROUBLE_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_trouble_code", Self::VT_DISPLAY_TROUBLE_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Text>>("text", Self::VT_TEXT, false)?
     .visit_field::<u32>("level", Self::VT_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .visit_field::<bool>("is_temporary", Self::VT_IS_TEMPORARY, false)?
     .finish();
    Ok(())
  }
}
pub struct DTCArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trouble_code: u32,
    pub display_trouble_code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<Text<'a>>>,
    pub level: Option<u32>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
    pub is_temporary: bool,
}
impl<'a> Default for DTCArgs<'a> {
  #[inline]
  fn default() -> Self {
    DTCArgs {
      short_name: None,
      trouble_code: 0,
      display_trouble_code: None,
      text: None,
      level: None,
      sdgs: None,
      is_temporary: false,
    }
  }
}

pub struct DTCBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DTCBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DTC::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_trouble_code(&mut self, trouble_code: u32) {
    self.fbb_.push_slot::<u32>(DTC::VT_TROUBLE_CODE, trouble_code, 0);
  }
  #[inline]
  pub fn add_display_trouble_code(&mut self, display_trouble_code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DTC::VT_DISPLAY_TROUBLE_CODE, display_trouble_code);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<Text<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Text>>(DTC::VT_TEXT, text);
  }
  #[inline]
  pub fn add_level(&mut self, level: u32) {
    self.fbb_.push_slot_always::<u32>(DTC::VT_LEVEL, level);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(DTC::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn add_is_temporary(&mut self, is_temporary: bool) {
    self.fbb_.push_slot::<bool>(DTC::VT_IS_TEMPORARY, is_temporary, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DTCBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DTCBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DTC<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DTC<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DTC");
      ds.field("short_name", &self.short_name());
      ds.field("trouble_code", &self.trouble_code());
      ds.field("display_trouble_code", &self.display_trouble_code());
      ds.field("text", &self.text());
      ds.field("level", &self.level());
      ds.field("sdgs", &self.sdgs());
      ds.field("is_temporary", &self.is_temporary());
      ds.finish()
  }
}
pub enum NormalDOPOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NormalDOP<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NormalDOP<'a> {
  type Inner = NormalDOP<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> NormalDOP<'a> {
  pub const VT_COMPU_METHOD: flatbuffers::VOffsetT = 4;
  pub const VT_DIAG_CODED_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_PHYSICAL_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_INTERNAL_CONSTR: flatbuffers::VOffsetT = 10;
  pub const VT_UNIT_REF: flatbuffers::VOffsetT = 12;
  pub const VT_PHYS_CONSTR: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NormalDOP { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NormalDOPArgs<'args>
  ) -> flatbuffers::WIPOffset<NormalDOP<'bldr>> {
    let mut builder = NormalDOPBuilder::new(_fbb);
    if let Some(x) = args.phys_constr { builder.add_phys_constr(x); }
    if let Some(x) = args.unit_ref { builder.add_unit_ref(x); }
    if let Some(x) = args.internal_constr { builder.add_internal_constr(x); }
    if let Some(x) = args.physical_type { builder.add_physical_type(x); }
    if let Some(x) = args.diag_coded_type { builder.add_diag_coded_type(x); }
    if let Some(x) = args.compu_method { builder.add_compu_method(x); }
    builder.finish()
  }


  #[inline]
  pub fn compu_method(&self) -> Option<CompuMethod<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuMethod>>(NormalDOP::VT_COMPU_METHOD, None)}
  }
  #[inline]
  pub fn diag_coded_type(&self) -> Option<DiagCodedType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagCodedType>>(NormalDOP::VT_DIAG_CODED_TYPE, None)}
  }
  #[inline]
  pub fn physical_type(&self) -> Option<PhysicalType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PhysicalType>>(NormalDOP::VT_PHYSICAL_TYPE, None)}
  }
  #[inline]
  pub fn internal_constr(&self) -> Option<InternalConstr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<InternalConstr>>(NormalDOP::VT_INTERNAL_CONSTR, None)}
  }
  #[inline]
  pub fn unit_ref(&self) -> Option<Unit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Unit>>(NormalDOP::VT_UNIT_REF, None)}
  }
  #[inline]
  pub fn phys_constr(&self) -> Option<InternalConstr<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<InternalConstr>>(NormalDOP::VT_PHYS_CONSTR, None)}
  }
}

impl flatbuffers::Verifiable for NormalDOP<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuMethod>>("compu_method", Self::VT_COMPU_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagCodedType>>("diag_coded_type", Self::VT_DIAG_CODED_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PhysicalType>>("physical_type", Self::VT_PHYSICAL_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<InternalConstr>>("internal_constr", Self::VT_INTERNAL_CONSTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Unit>>("unit_ref", Self::VT_UNIT_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<InternalConstr>>("phys_constr", Self::VT_PHYS_CONSTR, false)?
     .finish();
    Ok(())
  }
}
pub struct NormalDOPArgs<'a> {
    pub compu_method: Option<flatbuffers::WIPOffset<CompuMethod<'a>>>,
    pub diag_coded_type: Option<flatbuffers::WIPOffset<DiagCodedType<'a>>>,
    pub physical_type: Option<flatbuffers::WIPOffset<PhysicalType<'a>>>,
    pub internal_constr: Option<flatbuffers::WIPOffset<InternalConstr<'a>>>,
    pub unit_ref: Option<flatbuffers::WIPOffset<Unit<'a>>>,
    pub phys_constr: Option<flatbuffers::WIPOffset<InternalConstr<'a>>>,
}
impl<'a> Default for NormalDOPArgs<'a> {
  #[inline]
  fn default() -> Self {
    NormalDOPArgs {
      compu_method: None,
      diag_coded_type: None,
      physical_type: None,
      internal_constr: None,
      unit_ref: None,
      phys_constr: None,
    }
  }
}

pub struct NormalDOPBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NormalDOPBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_compu_method(&mut self, compu_method: flatbuffers::WIPOffset<CompuMethod<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuMethod>>(NormalDOP::VT_COMPU_METHOD, compu_method);
  }
  #[inline]
  pub fn add_diag_coded_type(&mut self, diag_coded_type: flatbuffers::WIPOffset<DiagCodedType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagCodedType>>(NormalDOP::VT_DIAG_CODED_TYPE, diag_coded_type);
  }
  #[inline]
  pub fn add_physical_type(&mut self, physical_type: flatbuffers::WIPOffset<PhysicalType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PhysicalType>>(NormalDOP::VT_PHYSICAL_TYPE, physical_type);
  }
  #[inline]
  pub fn add_internal_constr(&mut self, internal_constr: flatbuffers::WIPOffset<InternalConstr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<InternalConstr>>(NormalDOP::VT_INTERNAL_CONSTR, internal_constr);
  }
  #[inline]
  pub fn add_unit_ref(&mut self, unit_ref: flatbuffers::WIPOffset<Unit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Unit>>(NormalDOP::VT_UNIT_REF, unit_ref);
  }
  #[inline]
  pub fn add_phys_constr(&mut self, phys_constr: flatbuffers::WIPOffset<InternalConstr<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<InternalConstr>>(NormalDOP::VT_PHYS_CONSTR, phys_constr);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NormalDOPBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NormalDOPBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NormalDOP<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NormalDOP<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NormalDOP");
      ds.field("compu_method", &self.compu_method());
      ds.field("diag_coded_type", &self.diag_coded_type());
      ds.field("physical_type", &self.physical_type());
      ds.field("internal_constr", &self.internal_constr());
      ds.field("unit_ref", &self.unit_ref());
      ds.field("phys_constr", &self.phys_constr());
      ds.finish()
  }
}
pub enum FieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
  type Inner = Field<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Field<'a> {
  pub const VT_BASIC_STRUCTURE: flatbuffers::VOffsetT = 4;
  pub const VT_ENV_DATA_DESC: flatbuffers::VOffsetT = 6;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Field { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Field<'bldr>> {
    let mut builder = FieldBuilder::new(_fbb);
    if let Some(x) = args.env_data_desc { builder.add_env_data_desc(x); }
    if let Some(x) = args.basic_structure { builder.add_basic_structure(x); }
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn basic_structure(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(Field::VT_BASIC_STRUCTURE, None)}
  }
  #[inline]
  pub fn env_data_desc(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(Field::VT_ENV_DATA_DESC, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_IS_VISIBLE, Some(true)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Field<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("basic_structure", Self::VT_BASIC_STRUCTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("env_data_desc", Self::VT_ENV_DATA_DESC, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldArgs<'a> {
    pub basic_structure: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub env_data_desc: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub is_visible: bool,
}
impl<'a> Default for FieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldArgs {
      basic_structure: None,
      env_data_desc: None,
      is_visible: true,
    }
  }
}

pub struct FieldBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FieldBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_basic_structure(&mut self, basic_structure: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(Field::VT_BASIC_STRUCTURE, basic_structure);
  }
  #[inline]
  pub fn add_env_data_desc(&mut self, env_data_desc: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(Field::VT_ENV_DATA_DESC, env_data_desc);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_IS_VISIBLE, is_visible, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FieldBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Field<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Field");
      ds.field("basic_structure", &self.basic_structure());
      ds.field("env_data_desc", &self.env_data_desc());
      ds.field("is_visible", &self.is_visible());
      ds.finish()
  }
}
pub enum StaticFieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StaticField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StaticField<'a> {
  type Inner = StaticField<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StaticField<'a> {
  pub const VT_FIXED_NUMBER_OF_ITEMS: flatbuffers::VOffsetT = 4;
  pub const VT_ITEM_BYTE_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_FIELD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StaticField { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StaticFieldArgs<'args>
  ) -> flatbuffers::WIPOffset<StaticField<'bldr>> {
    let mut builder = StaticFieldBuilder::new(_fbb);
    if let Some(x) = args.field { builder.add_field(x); }
    builder.add_item_byte_size(args.item_byte_size);
    builder.add_fixed_number_of_items(args.fixed_number_of_items);
    builder.finish()
  }


  #[inline]
  pub fn fixed_number_of_items(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StaticField::VT_FIXED_NUMBER_OF_ITEMS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn item_byte_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(StaticField::VT_ITEM_BYTE_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn field(&self) -> Option<Field<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Field>>(StaticField::VT_FIELD, None)}
  }
}

impl flatbuffers::Verifiable for StaticField<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("fixed_number_of_items", Self::VT_FIXED_NUMBER_OF_ITEMS, false)?
     .visit_field::<u32>("item_byte_size", Self::VT_ITEM_BYTE_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Field>>("field", Self::VT_FIELD, false)?
     .finish();
    Ok(())
  }
}
pub struct StaticFieldArgs<'a> {
    pub fixed_number_of_items: u32,
    pub item_byte_size: u32,
    pub field: Option<flatbuffers::WIPOffset<Field<'a>>>,
}
impl<'a> Default for StaticFieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    StaticFieldArgs {
      fixed_number_of_items: 0,
      item_byte_size: 0,
      field: None,
    }
  }
}

pub struct StaticFieldBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StaticFieldBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_fixed_number_of_items(&mut self, fixed_number_of_items: u32) {
    self.fbb_.push_slot::<u32>(StaticField::VT_FIXED_NUMBER_OF_ITEMS, fixed_number_of_items, 0);
  }
  #[inline]
  pub fn add_item_byte_size(&mut self, item_byte_size: u32) {
    self.fbb_.push_slot::<u32>(StaticField::VT_ITEM_BYTE_SIZE, item_byte_size, 0);
  }
  #[inline]
  pub fn add_field(&mut self, field: flatbuffers::WIPOffset<Field<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Field>>(StaticField::VT_FIELD, field);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StaticFieldBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StaticFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StaticField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StaticField<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StaticField");
      ds.field("fixed_number_of_items", &self.fixed_number_of_items());
      ds.field("item_byte_size", &self.item_byte_size());
      ds.field("field", &self.field());
      ds.finish()
  }
}
pub enum EndOfPduFieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EndOfPduField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EndOfPduField<'a> {
  type Inner = EndOfPduField<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> EndOfPduField<'a> {
  pub const VT_MAX_NUMBER_OF_ITEMS: flatbuffers::VOffsetT = 4;
  pub const VT_MIN_NUMBER_OF_ITEMS: flatbuffers::VOffsetT = 6;
  pub const VT_FIELD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EndOfPduField { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EndOfPduFieldArgs<'args>
  ) -> flatbuffers::WIPOffset<EndOfPduField<'bldr>> {
    let mut builder = EndOfPduFieldBuilder::new(_fbb);
    if let Some(x) = args.field { builder.add_field(x); }
    if let Some(x) = args.min_number_of_items { builder.add_min_number_of_items(x); }
    if let Some(x) = args.max_number_of_items { builder.add_max_number_of_items(x); }
    builder.finish()
  }


  #[inline]
  pub fn max_number_of_items(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EndOfPduField::VT_MAX_NUMBER_OF_ITEMS, None)}
  }
  #[inline]
  pub fn min_number_of_items(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EndOfPduField::VT_MIN_NUMBER_OF_ITEMS, None)}
  }
  #[inline]
  pub fn field(&self) -> Option<Field<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Field>>(EndOfPduField::VT_FIELD, None)}
  }
}

impl flatbuffers::Verifiable for EndOfPduField<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("max_number_of_items", Self::VT_MAX_NUMBER_OF_ITEMS, false)?
     .visit_field::<u32>("min_number_of_items", Self::VT_MIN_NUMBER_OF_ITEMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Field>>("field", Self::VT_FIELD, false)?
     .finish();
    Ok(())
  }
}
pub struct EndOfPduFieldArgs<'a> {
    pub max_number_of_items: Option<u32>,
    pub min_number_of_items: Option<u32>,
    pub field: Option<flatbuffers::WIPOffset<Field<'a>>>,
}
impl<'a> Default for EndOfPduFieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    EndOfPduFieldArgs {
      max_number_of_items: None,
      min_number_of_items: None,
      field: None,
    }
  }
}

pub struct EndOfPduFieldBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EndOfPduFieldBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_max_number_of_items(&mut self, max_number_of_items: u32) {
    self.fbb_.push_slot_always::<u32>(EndOfPduField::VT_MAX_NUMBER_OF_ITEMS, max_number_of_items);
  }
  #[inline]
  pub fn add_min_number_of_items(&mut self, min_number_of_items: u32) {
    self.fbb_.push_slot_always::<u32>(EndOfPduField::VT_MIN_NUMBER_OF_ITEMS, min_number_of_items);
  }
  #[inline]
  pub fn add_field(&mut self, field: flatbuffers::WIPOffset<Field<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Field>>(EndOfPduField::VT_FIELD, field);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EndOfPduFieldBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EndOfPduFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EndOfPduField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EndOfPduField<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EndOfPduField");
      ds.field("max_number_of_items", &self.max_number_of_items());
      ds.field("min_number_of_items", &self.min_number_of_items());
      ds.field("field", &self.field());
      ds.finish()
  }
}
pub enum EnvDataDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EnvDataDesc<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnvDataDesc<'a> {
  type Inner = EnvDataDesc<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> EnvDataDesc<'a> {
  pub const VT_PARAM_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PARAM_PATH_SHORT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ENV_DATAS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnvDataDesc { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnvDataDescArgs<'args>
  ) -> flatbuffers::WIPOffset<EnvDataDesc<'bldr>> {
    let mut builder = EnvDataDescBuilder::new(_fbb);
    if let Some(x) = args.env_datas { builder.add_env_datas(x); }
    if let Some(x) = args.param_path_short_name { builder.add_param_path_short_name(x); }
    if let Some(x) = args.param_short_name { builder.add_param_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn param_short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnvDataDesc::VT_PARAM_SHORT_NAME, None)}
  }
  #[inline]
  pub fn param_path_short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnvDataDesc::VT_PARAM_PATH_SHORT_NAME, None)}
  }
  #[inline]
  pub fn env_datas(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP>>>>(EnvDataDesc::VT_ENV_DATAS, None)}
  }
}

impl flatbuffers::Verifiable for EnvDataDesc<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param_short_name", Self::VT_PARAM_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param_path_short_name", Self::VT_PARAM_PATH_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DOP>>>>("env_datas", Self::VT_ENV_DATAS, false)?
     .finish();
    Ok(())
  }
}
pub struct EnvDataDescArgs<'a> {
    pub param_short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param_path_short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub env_datas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP<'a>>>>>,
}
impl<'a> Default for EnvDataDescArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnvDataDescArgs {
      param_short_name: None,
      param_path_short_name: None,
      env_datas: None,
    }
  }
}

pub struct EnvDataDescBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvDataDescBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_param_short_name(&mut self, param_short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnvDataDesc::VT_PARAM_SHORT_NAME, param_short_name);
  }
  #[inline]
  pub fn add_param_path_short_name(&mut self, param_path_short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnvDataDesc::VT_PARAM_PATH_SHORT_NAME, param_path_short_name);
  }
  #[inline]
  pub fn add_env_datas(&mut self, env_datas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DOP<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnvDataDesc::VT_ENV_DATAS, env_datas);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnvDataDescBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnvDataDescBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnvDataDesc<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnvDataDesc<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnvDataDesc");
      ds.field("param_short_name", &self.param_short_name());
      ds.field("param_path_short_name", &self.param_path_short_name());
      ds.field("env_datas", &self.env_datas());
      ds.finish()
  }
}
pub enum EnvDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EnvData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnvData<'a> {
  type Inner = EnvData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> EnvData<'a> {
  pub const VT_DTC_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnvData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnvDataArgs<'args>
  ) -> flatbuffers::WIPOffset<EnvData<'bldr>> {
    let mut builder = EnvDataBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.dtc_values { builder.add_dtc_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn dtc_values(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(EnvData::VT_DTC_VALUES, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param>>>>(EnvData::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for EnvData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("dtc_values", Self::VT_DTC_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct EnvDataArgs<'a> {
    pub dtc_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>>>,
}
impl<'a> Default for EnvDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnvDataArgs {
      dtc_values: None,
      params: None,
    }
  }
}

pub struct EnvDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dtc_values(&mut self, dtc_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnvData::VT_DTC_VALUES, dtc_values);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Param<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnvData::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnvDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnvDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnvData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnvData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnvData");
      ds.field("dtc_values", &self.dtc_values());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum StructureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Structure<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Structure<'a> {
  type Inner = Structure<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Structure<'a> {
  pub const VT_PARAMS: flatbuffers::VOffsetT = 4;
  pub const VT_BYTE_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Structure { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StructureArgs<'args>
  ) -> flatbuffers::WIPOffset<Structure<'bldr>> {
    let mut builder = StructureBuilder::new(_fbb);
    if let Some(x) = args.byte_size { builder.add_byte_size(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param>>>>(Structure::VT_PARAMS, None)}
  }
  #[inline]
  pub fn byte_size(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Structure::VT_BYTE_SIZE, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Structure::VT_IS_VISIBLE, Some(true)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Structure<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .visit_field::<u32>("byte_size", Self::VT_BYTE_SIZE, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct StructureArgs<'a> {
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>>>,
    pub byte_size: Option<u32>,
    pub is_visible: bool,
}
impl<'a> Default for StructureArgs<'a> {
  #[inline]
  fn default() -> Self {
    StructureArgs {
      params: None,
      byte_size: None,
      is_visible: true,
    }
  }
}

pub struct StructureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StructureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Param<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Structure::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_byte_size(&mut self, byte_size: u32) {
    self.fbb_.push_slot_always::<u32>(Structure::VT_BYTE_SIZE, byte_size);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(Structure::VT_IS_VISIBLE, is_visible, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StructureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StructureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Structure<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Structure<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Structure");
      ds.field("params", &self.params());
      ds.field("byte_size", &self.byte_size());
      ds.field("is_visible", &self.is_visible());
      ds.finish()
  }
}
pub enum DTCDOPOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DTCDOP<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DTCDOP<'a> {
  type Inner = DTCDOP<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DTCDOP<'a> {
  pub const VT_DIAG_CODED_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_PHYSICAL_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_COMPU_METHOD: flatbuffers::VOffsetT = 8;
  pub const VT_DTCS: flatbuffers::VOffsetT = 10;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DTCDOP { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DTCDOPArgs<'args>
  ) -> flatbuffers::WIPOffset<DTCDOP<'bldr>> {
    let mut builder = DTCDOPBuilder::new(_fbb);
    if let Some(x) = args.dtcs { builder.add_dtcs(x); }
    if let Some(x) = args.compu_method { builder.add_compu_method(x); }
    if let Some(x) = args.physical_type { builder.add_physical_type(x); }
    if let Some(x) = args.diag_coded_type { builder.add_diag_coded_type(x); }
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn diag_coded_type(&self) -> Option<DiagCodedType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagCodedType>>(DTCDOP::VT_DIAG_CODED_TYPE, None)}
  }
  #[inline]
  pub fn physical_type(&self) -> Option<PhysicalType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PhysicalType>>(DTCDOP::VT_PHYSICAL_TYPE, None)}
  }
  #[inline]
  pub fn compu_method(&self) -> Option<CompuMethod<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CompuMethod>>(DTCDOP::VT_COMPU_METHOD, None)}
  }
  #[inline]
  pub fn dtcs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC>>>>(DTCDOP::VT_DTCS, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DTCDOP::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DTCDOP<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagCodedType>>("diag_coded_type", Self::VT_DIAG_CODED_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PhysicalType>>("physical_type", Self::VT_PHYSICAL_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CompuMethod>>("compu_method", Self::VT_COMPU_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DTC>>>>("dtcs", Self::VT_DTCS, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DTCDOPArgs<'a> {
    pub diag_coded_type: Option<flatbuffers::WIPOffset<DiagCodedType<'a>>>,
    pub physical_type: Option<flatbuffers::WIPOffset<PhysicalType<'a>>>,
    pub compu_method: Option<flatbuffers::WIPOffset<CompuMethod<'a>>>,
    pub dtcs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC<'a>>>>>,
    pub is_visible: bool,
}
impl<'a> Default for DTCDOPArgs<'a> {
  #[inline]
  fn default() -> Self {
    DTCDOPArgs {
      diag_coded_type: None,
      physical_type: None,
      compu_method: None,
      dtcs: None,
      is_visible: false,
    }
  }
}

pub struct DTCDOPBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DTCDOPBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_coded_type(&mut self, diag_coded_type: flatbuffers::WIPOffset<DiagCodedType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagCodedType>>(DTCDOP::VT_DIAG_CODED_TYPE, diag_coded_type);
  }
  #[inline]
  pub fn add_physical_type(&mut self, physical_type: flatbuffers::WIPOffset<PhysicalType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PhysicalType>>(DTCDOP::VT_PHYSICAL_TYPE, physical_type);
  }
  #[inline]
  pub fn add_compu_method(&mut self, compu_method: flatbuffers::WIPOffset<CompuMethod<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CompuMethod>>(DTCDOP::VT_COMPU_METHOD, compu_method);
  }
  #[inline]
  pub fn add_dtcs(&mut self, dtcs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DTC<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DTCDOP::VT_DTCS, dtcs);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(DTCDOP::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DTCDOPBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DTCDOPBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DTCDOP<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DTCDOP<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DTCDOP");
      ds.field("diag_coded_type", &self.diag_coded_type());
      ds.field("physical_type", &self.physical_type());
      ds.field("compu_method", &self.compu_method());
      ds.field("dtcs", &self.dtcs());
      ds.field("is_visible", &self.is_visible());
      ds.finish()
  }
}
pub enum LongNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LongName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LongName<'a> {
  type Inner = LongName<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> LongName<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_TI: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LongName { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LongNameArgs<'args>
  ) -> flatbuffers::WIPOffset<LongName<'bldr>> {
    let mut builder = LongNameBuilder::new(_fbb);
    if let Some(x) = args.ti { builder.add_ti(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LongName::VT_VALUE, None)}
  }
  #[inline]
  pub fn ti(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LongName::VT_TI, None)}
  }
}

impl flatbuffers::Verifiable for LongName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ti", Self::VT_TI, false)?
     .finish();
    Ok(())
  }
}
pub struct LongNameArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ti: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LongNameArgs<'a> {
  #[inline]
  fn default() -> Self {
    LongNameArgs {
      value: None,
      ti: None,
    }
  }
}

pub struct LongNameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LongNameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LongName::VT_VALUE, value);
  }
  #[inline]
  pub fn add_ti(&mut self, ti: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LongName::VT_TI, ti);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LongNameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LongNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LongName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LongName<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LongName");
      ds.field("value", &self.value());
      ds.field("ti", &self.ti());
      ds.finish()
  }
}
pub enum SwitchKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SwitchKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SwitchKey<'a> {
  type Inner = SwitchKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SwitchKey<'a> {
  pub const VT_BYTE_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_BIT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_DOP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SwitchKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SwitchKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<SwitchKey<'bldr>> {
    let mut builder = SwitchKeyBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    if let Some(x) = args.bit_position { builder.add_bit_position(x); }
    builder.add_byte_position(args.byte_position);
    builder.finish()
  }


  #[inline]
  pub fn byte_position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SwitchKey::VT_BYTE_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bit_position(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SwitchKey::VT_BIT_POSITION, None)}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(SwitchKey::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for SwitchKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("byte_position", Self::VT_BYTE_POSITION, false)?
     .visit_field::<u32>("bit_position", Self::VT_BIT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct SwitchKeyArgs<'a> {
    pub byte_position: u32,
    pub bit_position: Option<u32>,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for SwitchKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    SwitchKeyArgs {
      byte_position: 0,
      bit_position: None,
      dop: None,
    }
  }
}

pub struct SwitchKeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SwitchKeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_byte_position(&mut self, byte_position: u32) {
    self.fbb_.push_slot::<u32>(SwitchKey::VT_BYTE_POSITION, byte_position, 0);
  }
  #[inline]
  pub fn add_bit_position(&mut self, bit_position: u32) {
    self.fbb_.push_slot_always::<u32>(SwitchKey::VT_BIT_POSITION, bit_position);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(SwitchKey::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SwitchKeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SwitchKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SwitchKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SwitchKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SwitchKey");
      ds.field("byte_position", &self.byte_position());
      ds.field("bit_position", &self.bit_position());
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum DefaultCaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DefaultCase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DefaultCase<'a> {
  type Inner = DefaultCase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DefaultCase<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_STRUCTURE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DefaultCase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DefaultCaseArgs<'args>
  ) -> flatbuffers::WIPOffset<DefaultCase<'bldr>> {
    let mut builder = DefaultCaseBuilder::new(_fbb);
    if let Some(x) = args.structure { builder.add_structure(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DefaultCase::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(DefaultCase::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn structure(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(DefaultCase::VT_STRUCTURE, None)}
  }
}

impl flatbuffers::Verifiable for DefaultCase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("structure", Self::VT_STRUCTURE, false)?
     .finish();
    Ok(())
  }
}
pub struct DefaultCaseArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub structure: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for DefaultCaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    DefaultCaseArgs {
      short_name: None,
      long_name: None,
      structure: None,
    }
  }
}

pub struct DefaultCaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DefaultCaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DefaultCase::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(DefaultCase::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_structure(&mut self, structure: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(DefaultCase::VT_STRUCTURE, structure);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DefaultCaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DefaultCaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DefaultCase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DefaultCase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DefaultCase");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("structure", &self.structure());
      ds.finish()
  }
}
pub enum CaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Case<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Case<'a> {
  type Inner = Case<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Case<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_STRUCTURE: flatbuffers::VOffsetT = 8;
  pub const VT_LOWER_LIMIT: flatbuffers::VOffsetT = 10;
  pub const VT_UPPER_LIMIT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Case { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CaseArgs<'args>
  ) -> flatbuffers::WIPOffset<Case<'bldr>> {
    let mut builder = CaseBuilder::new(_fbb);
    if let Some(x) = args.upper_limit { builder.add_upper_limit(x); }
    if let Some(x) = args.lower_limit { builder.add_lower_limit(x); }
    if let Some(x) = args.structure { builder.add_structure(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Case::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(Case::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn structure(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(Case::VT_STRUCTURE, None)}
  }
  #[inline]
  pub fn lower_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(Case::VT_LOWER_LIMIT, None)}
  }
  #[inline]
  pub fn upper_limit(&self) -> Option<Limit<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Limit>>(Case::VT_UPPER_LIMIT, None)}
  }
}

impl flatbuffers::Verifiable for Case<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("structure", Self::VT_STRUCTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("lower_limit", Self::VT_LOWER_LIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Limit>>("upper_limit", Self::VT_UPPER_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct CaseArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub structure: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub lower_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
    pub upper_limit: Option<flatbuffers::WIPOffset<Limit<'a>>>,
}
impl<'a> Default for CaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CaseArgs {
      short_name: None,
      long_name: None,
      structure: None,
      lower_limit: None,
      upper_limit: None,
    }
  }
}

pub struct CaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Case::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(Case::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_structure(&mut self, structure: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(Case::VT_STRUCTURE, structure);
  }
  #[inline]
  pub fn add_lower_limit(&mut self, lower_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(Case::VT_LOWER_LIMIT, lower_limit);
  }
  #[inline]
  pub fn add_upper_limit(&mut self, upper_limit: flatbuffers::WIPOffset<Limit<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Limit>>(Case::VT_UPPER_LIMIT, upper_limit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Case<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Case<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Case");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("structure", &self.structure());
      ds.field("lower_limit", &self.lower_limit());
      ds.field("upper_limit", &self.upper_limit());
      ds.finish()
  }
}
pub enum MUXDOPOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MUXDOP<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MUXDOP<'a> {
  type Inner = MUXDOP<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> MUXDOP<'a> {
  pub const VT_BYTE_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_SWITCH_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_DEFAULT_CASE: flatbuffers::VOffsetT = 8;
  pub const VT_CASES: flatbuffers::VOffsetT = 10;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MUXDOP { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MUXDOPArgs<'args>
  ) -> flatbuffers::WIPOffset<MUXDOP<'bldr>> {
    let mut builder = MUXDOPBuilder::new(_fbb);
    if let Some(x) = args.cases { builder.add_cases(x); }
    if let Some(x) = args.default_case { builder.add_default_case(x); }
    if let Some(x) = args.switch_key { builder.add_switch_key(x); }
    builder.add_byte_position(args.byte_position);
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn byte_position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MUXDOP::VT_BYTE_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn switch_key(&self) -> Option<SwitchKey<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SwitchKey>>(MUXDOP::VT_SWITCH_KEY, None)}
  }
  #[inline]
  pub fn default_case(&self) -> Option<DefaultCase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultCase>>(MUXDOP::VT_DEFAULT_CASE, None)}
  }
  #[inline]
  pub fn cases(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Case<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Case>>>>(MUXDOP::VT_CASES, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MUXDOP::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MUXDOP<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("byte_position", Self::VT_BYTE_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SwitchKey>>("switch_key", Self::VT_SWITCH_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultCase>>("default_case", Self::VT_DEFAULT_CASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Case>>>>("cases", Self::VT_CASES, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct MUXDOPArgs<'a> {
    pub byte_position: u32,
    pub switch_key: Option<flatbuffers::WIPOffset<SwitchKey<'a>>>,
    pub default_case: Option<flatbuffers::WIPOffset<DefaultCase<'a>>>,
    pub cases: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Case<'a>>>>>,
    pub is_visible: bool,
}
impl<'a> Default for MUXDOPArgs<'a> {
  #[inline]
  fn default() -> Self {
    MUXDOPArgs {
      byte_position: 0,
      switch_key: None,
      default_case: None,
      cases: None,
      is_visible: false,
    }
  }
}

pub struct MUXDOPBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MUXDOPBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_byte_position(&mut self, byte_position: u32) {
    self.fbb_.push_slot::<u32>(MUXDOP::VT_BYTE_POSITION, byte_position, 0);
  }
  #[inline]
  pub fn add_switch_key(&mut self, switch_key: flatbuffers::WIPOffset<SwitchKey<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SwitchKey>>(MUXDOP::VT_SWITCH_KEY, switch_key);
  }
  #[inline]
  pub fn add_default_case(&mut self, default_case: flatbuffers::WIPOffset<DefaultCase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultCase>>(MUXDOP::VT_DEFAULT_CASE, default_case);
  }
  #[inline]
  pub fn add_cases(&mut self, cases: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Case<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MUXDOP::VT_CASES, cases);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(MUXDOP::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MUXDOPBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MUXDOPBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MUXDOP<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MUXDOP<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MUXDOP");
      ds.field("byte_position", &self.byte_position());
      ds.field("switch_key", &self.switch_key());
      ds.field("default_case", &self.default_case());
      ds.field("cases", &self.cases());
      ds.field("is_visible", &self.is_visible());
      ds.finish()
  }
}
pub enum DetermineNumberOfItemsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DetermineNumberOfItems<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DetermineNumberOfItems<'a> {
  type Inner = DetermineNumberOfItems<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DetermineNumberOfItems<'a> {
  pub const VT_BYTE_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_BIT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_DOP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DetermineNumberOfItems { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DetermineNumberOfItemsArgs<'args>
  ) -> flatbuffers::WIPOffset<DetermineNumberOfItems<'bldr>> {
    let mut builder = DetermineNumberOfItemsBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    builder.add_bit_position(args.bit_position);
    builder.add_byte_position(args.byte_position);
    builder.finish()
  }


  #[inline]
  pub fn byte_position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DetermineNumberOfItems::VT_BYTE_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bit_position(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DetermineNumberOfItems::VT_BIT_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(DetermineNumberOfItems::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for DetermineNumberOfItems<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("byte_position", Self::VT_BYTE_POSITION, false)?
     .visit_field::<u32>("bit_position", Self::VT_BIT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct DetermineNumberOfItemsArgs<'a> {
    pub byte_position: u32,
    pub bit_position: u32,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for DetermineNumberOfItemsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DetermineNumberOfItemsArgs {
      byte_position: 0,
      bit_position: 0,
      dop: None,
    }
  }
}

pub struct DetermineNumberOfItemsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DetermineNumberOfItemsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_byte_position(&mut self, byte_position: u32) {
    self.fbb_.push_slot::<u32>(DetermineNumberOfItems::VT_BYTE_POSITION, byte_position, 0);
  }
  #[inline]
  pub fn add_bit_position(&mut self, bit_position: u32) {
    self.fbb_.push_slot::<u32>(DetermineNumberOfItems::VT_BIT_POSITION, bit_position, 0);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(DetermineNumberOfItems::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DetermineNumberOfItemsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DetermineNumberOfItemsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DetermineNumberOfItems<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DetermineNumberOfItems<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DetermineNumberOfItems");
      ds.field("byte_position", &self.byte_position());
      ds.field("bit_position", &self.bit_position());
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum DynamicLengthFieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DynamicLengthField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DynamicLengthField<'a> {
  type Inner = DynamicLengthField<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DynamicLengthField<'a> {
  pub const VT_OFFSET: flatbuffers::VOffsetT = 4;
  pub const VT_FIELD: flatbuffers::VOffsetT = 6;
  pub const VT_DETERMINE_NUMBER_OF_ITEMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DynamicLengthField { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DynamicLengthFieldArgs<'args>
  ) -> flatbuffers::WIPOffset<DynamicLengthField<'bldr>> {
    let mut builder = DynamicLengthFieldBuilder::new(_fbb);
    if let Some(x) = args.determine_number_of_items { builder.add_determine_number_of_items(x); }
    if let Some(x) = args.field { builder.add_field(x); }
    builder.add_offset(args.offset);
    builder.finish()
  }


  #[inline]
  pub fn offset(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DynamicLengthField::VT_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn field(&self) -> Option<Field<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Field>>(DynamicLengthField::VT_FIELD, None)}
  }
  #[inline]
  pub fn determine_number_of_items(&self) -> Option<DetermineNumberOfItems<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DetermineNumberOfItems>>(DynamicLengthField::VT_DETERMINE_NUMBER_OF_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for DynamicLengthField<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Field>>("field", Self::VT_FIELD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DetermineNumberOfItems>>("determine_number_of_items", Self::VT_DETERMINE_NUMBER_OF_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct DynamicLengthFieldArgs<'a> {
    pub offset: u32,
    pub field: Option<flatbuffers::WIPOffset<Field<'a>>>,
    pub determine_number_of_items: Option<flatbuffers::WIPOffset<DetermineNumberOfItems<'a>>>,
}
impl<'a> Default for DynamicLengthFieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    DynamicLengthFieldArgs {
      offset: 0,
      field: None,
      determine_number_of_items: None,
    }
  }
}

pub struct DynamicLengthFieldBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DynamicLengthFieldBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_offset(&mut self, offset: u32) {
    self.fbb_.push_slot::<u32>(DynamicLengthField::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_field(&mut self, field: flatbuffers::WIPOffset<Field<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Field>>(DynamicLengthField::VT_FIELD, field);
  }
  #[inline]
  pub fn add_determine_number_of_items(&mut self, determine_number_of_items: flatbuffers::WIPOffset<DetermineNumberOfItems<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DetermineNumberOfItems>>(DynamicLengthField::VT_DETERMINE_NUMBER_OF_ITEMS, determine_number_of_items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DynamicLengthFieldBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DynamicLengthFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DynamicLengthField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DynamicLengthField<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DynamicLengthField");
      ds.field("offset", &self.offset());
      ds.field("field", &self.field());
      ds.field("determine_number_of_items", &self.determine_number_of_items());
      ds.finish()
  }
}
pub enum DOPOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DOP<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DOP<'a> {
  type Inner = DOP<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DOP<'a> {
  pub const VT_DOP_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SDGS: flatbuffers::VOffsetT = 8;
  pub const VT_SPECIFIC_DATA_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_SPECIFIC_DATA: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DOP { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DOPArgs<'args>
  ) -> flatbuffers::WIPOffset<DOP<'bldr>> {
    let mut builder = DOPBuilder::new(_fbb);
    if let Some(x) = args.specific_data { builder.add_specific_data(x); }
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_specific_data_type(args.specific_data_type);
    builder.add_dop_type(args.dop_type);
    builder.finish()
  }


  #[inline]
  pub fn dop_type(&self) -> DOPType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DOPType>(DOP::VT_DOP_TYPE, Some(DOPType::REGULAR)).unwrap()}
  }
  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DOP::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(DOP::VT_SDGS, None)}
  }
  #[inline]
  pub fn specific_data_type(&self) -> SpecificDOPData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpecificDOPData>(DOP::VT_SPECIFIC_DATA_TYPE, Some(SpecificDOPData::NONE)).unwrap()}
  }
  #[inline]
  pub fn specific_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DOP::VT_SPECIFIC_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_normal_dop(&self) -> Option<NormalDOP<'a>> {
    if self.specific_data_type() == SpecificDOPData::NormalDOP {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NormalDOP::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_end_of_pdu_field(&self) -> Option<EndOfPduField<'a>> {
    if self.specific_data_type() == SpecificDOPData::EndOfPduField {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EndOfPduField::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_static_field(&self) -> Option<StaticField<'a>> {
    if self.specific_data_type() == SpecificDOPData::StaticField {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StaticField::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_env_data_desc(&self) -> Option<EnvDataDesc<'a>> {
    if self.specific_data_type() == SpecificDOPData::EnvDataDesc {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EnvDataDesc::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_env_data(&self) -> Option<EnvData<'a>> {
    if self.specific_data_type() == SpecificDOPData::EnvData {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EnvData::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_dtcdop(&self) -> Option<DTCDOP<'a>> {
    if self.specific_data_type() == SpecificDOPData::DTCDOP {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DTCDOP::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_structure(&self) -> Option<Structure<'a>> {
    if self.specific_data_type() == SpecificDOPData::Structure {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Structure::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_muxdop(&self) -> Option<MUXDOP<'a>> {
    if self.specific_data_type() == SpecificDOPData::MUXDOP {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MUXDOP::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_dynamic_length_field(&self) -> Option<DynamicLengthField<'a>> {
    if self.specific_data_type() == SpecificDOPData::DynamicLengthField {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DynamicLengthField::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DOP<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DOPType>("dop_type", Self::VT_DOP_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .visit_union::<SpecificDOPDataUnionValue>("specific_data_type", Self::VT_SPECIFIC_DATA_TYPE, "specific_data", Self::VT_SPECIFIC_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct DOPArgs<'a> {
    pub dop_type: DOPType,
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
    pub specific_data_type: SpecificDOPData,
    pub specific_data: Option<flatbuffers::WIPOffset<SpecificDOPDataUnionValue>>,
}
impl<'a> Default for DOPArgs<'a> {
  #[inline]
  fn default() -> Self {
    DOPArgs {
      dop_type: DOPType::REGULAR,
      short_name: None,
      sdgs: None,
      specific_data_type: SpecificDOPData::NONE,
      specific_data: None,
    }
  }
}

pub struct DOPBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DOPBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dop_type(&mut self, dop_type: DOPType) {
    self.fbb_.push_slot::<DOPType>(DOP::VT_DOP_TYPE, dop_type, DOPType::REGULAR);
  }
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DOP::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(DOP::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn add_specific_data_type(&mut self, specific_data_type: SpecificDOPData) {
    self.fbb_.push_slot::<SpecificDOPData>(DOP::VT_SPECIFIC_DATA_TYPE, specific_data_type, SpecificDOPData::NONE);
  }
  #[inline]
  pub fn add_specific_data(&mut self, specific_data: flatbuffers::WIPOffset<SpecificDOPDataUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DOP::VT_SPECIFIC_DATA, specific_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DOPBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DOPBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DOP<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DOP<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DOP");
      ds.field("dop_type", &self.dop_type());
      ds.field("short_name", &self.short_name());
      ds.field("sdgs", &self.sdgs());
      ds.field("specific_data_type", &self.specific_data_type());
      match self.specific_data_type() {
        SpecificDOPData::NormalDOP => {
          if let Some(x) = self.specific_data_as_normal_dop() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::EndOfPduField => {
          if let Some(x) = self.specific_data_as_end_of_pdu_field() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::StaticField => {
          if let Some(x) = self.specific_data_as_static_field() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::EnvDataDesc => {
          if let Some(x) = self.specific_data_as_env_data_desc() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::EnvData => {
          if let Some(x) = self.specific_data_as_env_data() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::DTCDOP => {
          if let Some(x) = self.specific_data_as_dtcdop() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::Structure => {
          if let Some(x) = self.specific_data_as_structure() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::MUXDOP => {
          if let Some(x) = self.specific_data_as_muxdop() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificDOPData::DynamicLengthField => {
          if let Some(x) = self.specific_data_as_dynamic_length_field() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("specific_data", &x)
        },
      };
      ds.finish()
  }
}
pub enum StateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct State<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for State<'a> {
  type Inner = State<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> State<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    State { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StateArgs<'args>
  ) -> flatbuffers::WIPOffset<State<'bldr>> {
    let mut builder = StateBuilder::new(_fbb);
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(State::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(State::VT_LONG_NAME, None)}
  }
}

impl flatbuffers::Verifiable for State<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct StateArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
}
impl<'a> Default for StateArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateArgs {
      short_name: None,
      long_name: None,
    }
  }
}

pub struct StateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(State::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(State::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<State<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for State<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("State");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.finish()
  }
}
pub enum StateChartOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateChart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateChart<'a> {
  type Inner = StateChart<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StateChart<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 6;
  pub const VT_STATE_TRANSITIONS: flatbuffers::VOffsetT = 8;
  pub const VT_START_STATE_SHORT_NAME_REF: flatbuffers::VOffsetT = 10;
  pub const VT_STATES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateChart { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StateChartArgs<'args>
  ) -> flatbuffers::WIPOffset<StateChart<'bldr>> {
    let mut builder = StateChartBuilder::new(_fbb);
    if let Some(x) = args.states { builder.add_states(x); }
    if let Some(x) = args.start_state_short_name_ref { builder.add_start_state_short_name_ref(x); }
    if let Some(x) = args.state_transitions { builder.add_state_transitions(x); }
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateChart::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateChart::VT_SEMANTIC, None)}
  }
  #[inline]
  pub fn state_transitions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransition>>>>(StateChart::VT_STATE_TRANSITIONS, None)}
  }
  #[inline]
  pub fn start_state_short_name_ref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateChart::VT_START_STATE_SHORT_NAME_REF, None)}
  }
  #[inline]
  pub fn states(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<State<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<State>>>>(StateChart::VT_STATES, None)}
  }
}

impl flatbuffers::Verifiable for StateChart<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateTransition>>>>("state_transitions", Self::VT_STATE_TRANSITIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start_state_short_name_ref", Self::VT_START_STATE_SHORT_NAME_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<State>>>>("states", Self::VT_STATES, false)?
     .finish();
    Ok(())
  }
}
pub struct StateChartArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state_transitions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransition<'a>>>>>,
    pub start_state_short_name_ref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub states: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<State<'a>>>>>,
}
impl<'a> Default for StateChartArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateChartArgs {
      short_name: None,
      semantic: None,
      state_transitions: None,
      start_state_short_name_ref: None,
      states: None,
    }
  }
}

pub struct StateChartBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateChartBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateChart::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateChart::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn add_state_transitions(&mut self, state_transitions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateTransition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateChart::VT_STATE_TRANSITIONS, state_transitions);
  }
  #[inline]
  pub fn add_start_state_short_name_ref(&mut self, start_state_short_name_ref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateChart::VT_START_STATE_SHORT_NAME_REF, start_state_short_name_ref);
  }
  #[inline]
  pub fn add_states(&mut self, states: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<State<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateChart::VT_STATES, states);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StateChartBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StateChartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateChart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateChart<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateChart");
      ds.field("short_name", &self.short_name());
      ds.field("semantic", &self.semantic());
      ds.field("state_transitions", &self.state_transitions());
      ds.field("start_state_short_name_ref", &self.start_state_short_name_ref());
      ds.field("states", &self.states());
      ds.finish()
  }
}
pub enum StateTransitionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateTransition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateTransition<'a> {
  type Inner = StateTransition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StateTransition<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE_SHORT_NAME_REF: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET_SHORT_NAME_REF: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateTransition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StateTransitionArgs<'args>
  ) -> flatbuffers::WIPOffset<StateTransition<'bldr>> {
    let mut builder = StateTransitionBuilder::new(_fbb);
    if let Some(x) = args.target_short_name_ref { builder.add_target_short_name_ref(x); }
    if let Some(x) = args.source_short_name_ref { builder.add_source_short_name_ref(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateTransition::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn source_short_name_ref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateTransition::VT_SOURCE_SHORT_NAME_REF, None)}
  }
  #[inline]
  pub fn target_short_name_ref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateTransition::VT_TARGET_SHORT_NAME_REF, None)}
  }
}

impl flatbuffers::Verifiable for StateTransition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source_short_name_ref", Self::VT_SOURCE_SHORT_NAME_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_short_name_ref", Self::VT_TARGET_SHORT_NAME_REF, false)?
     .finish();
    Ok(())
  }
}
pub struct StateTransitionArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source_short_name_ref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target_short_name_ref: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StateTransitionArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateTransitionArgs {
      short_name: None,
      source_short_name_ref: None,
      target_short_name_ref: None,
    }
  }
}

pub struct StateTransitionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateTransitionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateTransition::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_source_short_name_ref(&mut self, source_short_name_ref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateTransition::VT_SOURCE_SHORT_NAME_REF, source_short_name_ref);
  }
  #[inline]
  pub fn add_target_short_name_ref(&mut self, target_short_name_ref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateTransition::VT_TARGET_SHORT_NAME_REF, target_short_name_ref);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StateTransitionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StateTransitionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateTransition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateTransition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateTransition");
      ds.field("short_name", &self.short_name());
      ds.field("source_short_name_ref", &self.source_short_name_ref());
      ds.field("target_short_name_ref", &self.target_short_name_ref());
      ds.finish()
  }
}
pub enum StateTransitionRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StateTransitionRef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StateTransitionRef<'a> {
  type Inner = StateTransitionRef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StateTransitionRef<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_STATE_TRANSITION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StateTransitionRef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StateTransitionRefArgs<'args>
  ) -> flatbuffers::WIPOffset<StateTransitionRef<'bldr>> {
    let mut builder = StateTransitionRefBuilder::new(_fbb);
    if let Some(x) = args.state_transition { builder.add_state_transition(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StateTransitionRef::VT_VALUE, None)}
  }
  #[inline]
  pub fn state_transition(&self) -> Option<StateTransition<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StateTransition>>(StateTransitionRef::VT_STATE_TRANSITION, None)}
  }
}

impl flatbuffers::Verifiable for StateTransitionRef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StateTransition>>("state_transition", Self::VT_STATE_TRANSITION, false)?
     .finish();
    Ok(())
  }
}
pub struct StateTransitionRefArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state_transition: Option<flatbuffers::WIPOffset<StateTransition<'a>>>,
}
impl<'a> Default for StateTransitionRefArgs<'a> {
  #[inline]
  fn default() -> Self {
    StateTransitionRefArgs {
      value: None,
      state_transition: None,
    }
  }
}

pub struct StateTransitionRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateTransitionRefBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StateTransitionRef::VT_VALUE, value);
  }
  #[inline]
  pub fn add_state_transition(&mut self, state_transition: flatbuffers::WIPOffset<StateTransition<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StateTransition>>(StateTransitionRef::VT_STATE_TRANSITION, state_transition);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StateTransitionRefBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StateTransitionRefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StateTransitionRef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StateTransitionRef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StateTransitionRef");
      ds.field("value", &self.value());
      ds.field("state_transition", &self.state_transition());
      ds.finish()
  }
}
pub enum PreConditionStateRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PreConditionStateRef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PreConditionStateRef<'a> {
  type Inner = PreConditionStateRef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PreConditionStateRef<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_IN_PARAM_IF_SHORT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_IN_PARAM_PATH_SHORT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_STATE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PreConditionStateRef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PreConditionStateRefArgs<'args>
  ) -> flatbuffers::WIPOffset<PreConditionStateRef<'bldr>> {
    let mut builder = PreConditionStateRefBuilder::new(_fbb);
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.in_param_path_short_name { builder.add_in_param_path_short_name(x); }
    if let Some(x) = args.in_param_if_short_name { builder.add_in_param_if_short_name(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreConditionStateRef::VT_VALUE, None)}
  }
  #[inline]
  pub fn in_param_if_short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreConditionStateRef::VT_IN_PARAM_IF_SHORT_NAME, None)}
  }
  #[inline]
  pub fn in_param_path_short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PreConditionStateRef::VT_IN_PARAM_PATH_SHORT_NAME, None)}
  }
  #[inline]
  pub fn state(&self) -> Option<State<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<State>>(PreConditionStateRef::VT_STATE, None)}
  }
}

impl flatbuffers::Verifiable for PreConditionStateRef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("in_param_if_short_name", Self::VT_IN_PARAM_IF_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("in_param_path_short_name", Self::VT_IN_PARAM_PATH_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<State>>("state", Self::VT_STATE, false)?
     .finish();
    Ok(())
  }
}
pub struct PreConditionStateRefArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub in_param_if_short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub in_param_path_short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub state: Option<flatbuffers::WIPOffset<State<'a>>>,
}
impl<'a> Default for PreConditionStateRefArgs<'a> {
  #[inline]
  fn default() -> Self {
    PreConditionStateRefArgs {
      value: None,
      in_param_if_short_name: None,
      in_param_path_short_name: None,
      state: None,
    }
  }
}

pub struct PreConditionStateRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PreConditionStateRefBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreConditionStateRef::VT_VALUE, value);
  }
  #[inline]
  pub fn add_in_param_if_short_name(&mut self, in_param_if_short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreConditionStateRef::VT_IN_PARAM_IF_SHORT_NAME, in_param_if_short_name);
  }
  #[inline]
  pub fn add_in_param_path_short_name(&mut self, in_param_path_short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PreConditionStateRef::VT_IN_PARAM_PATH_SHORT_NAME, in_param_path_short_name);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<State<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<State>>(PreConditionStateRef::VT_STATE, state);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PreConditionStateRefBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PreConditionStateRefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PreConditionStateRef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PreConditionStateRef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PreConditionStateRef");
      ds.field("value", &self.value());
      ds.field("in_param_if_short_name", &self.in_param_if_short_name());
      ds.field("in_param_path_short_name", &self.in_param_path_short_name());
      ds.field("state", &self.state());
      ds.finish()
  }
}
pub enum TableRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableRow<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableRow<'a> {
  type Inner = TableRow<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableRow<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_DOP: flatbuffers::VOffsetT = 10;
  pub const VT_STRUCTURE: flatbuffers::VOffsetT = 12;
  pub const VT_SDGS: flatbuffers::VOffsetT = 14;
  pub const VT_AUDIENCE: flatbuffers::VOffsetT = 16;
  pub const VT_FUNCT_CLASS_REFS: flatbuffers::VOffsetT = 18;
  pub const VT_STATE_TRANSITION_REFS: flatbuffers::VOffsetT = 20;
  pub const VT_PRE_CONDITION_STATE_REFS: flatbuffers::VOffsetT = 22;
  pub const VT_IS_EXECUTABLE: flatbuffers::VOffsetT = 24;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 26;
  pub const VT_IS_MANDATORY: flatbuffers::VOffsetT = 28;
  pub const VT_IS_FINAL: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableRow { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableRowArgs<'args>
  ) -> flatbuffers::WIPOffset<TableRow<'bldr>> {
    let mut builder = TableRowBuilder::new(_fbb);
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.pre_condition_state_refs { builder.add_pre_condition_state_refs(x); }
    if let Some(x) = args.state_transition_refs { builder.add_state_transition_refs(x); }
    if let Some(x) = args.funct_class_refs { builder.add_funct_class_refs(x); }
    if let Some(x) = args.audience { builder.add_audience(x); }
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.structure { builder.add_structure(x); }
    if let Some(x) = args.dop { builder.add_dop(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_is_final(args.is_final);
    builder.add_is_mandatory(args.is_mandatory);
    builder.add_is_executable(args.is_executable);
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableRow::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(TableRow::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableRow::VT_KEY, None)}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(TableRow::VT_DOP, None)}
  }
  #[inline]
  pub fn structure(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(TableRow::VT_STRUCTURE, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(TableRow::VT_SDGS, None)}
  }
  #[inline]
  pub fn audience(&self) -> Option<Audience<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Audience>>(TableRow::VT_AUDIENCE, None)}
  }
  #[inline]
  pub fn funct_class_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass>>>>(TableRow::VT_FUNCT_CLASS_REFS, None)}
  }
  #[inline]
  pub fn state_transition_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef>>>>(TableRow::VT_STATE_TRANSITION_REFS, None)}
  }
  #[inline]
  pub fn pre_condition_state_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef>>>>(TableRow::VT_PRE_CONDITION_STATE_REFS, None)}
  }
  #[inline]
  pub fn is_executable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TableRow::VT_IS_EXECUTABLE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableRow::VT_SEMANTIC, None)}
  }
  #[inline]
  pub fn is_mandatory(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TableRow::VT_IS_MANDATORY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_final(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TableRow::VT_IS_FINAL, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TableRow<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("structure", Self::VT_STRUCTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Audience>>("audience", Self::VT_AUDIENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctClass>>>>("funct_class_refs", Self::VT_FUNCT_CLASS_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateTransitionRef>>>>("state_transition_refs", Self::VT_STATE_TRANSITION_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PreConditionStateRef>>>>("pre_condition_state_refs", Self::VT_PRE_CONDITION_STATE_REFS, false)?
     .visit_field::<bool>("is_executable", Self::VT_IS_EXECUTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .visit_field::<bool>("is_mandatory", Self::VT_IS_MANDATORY, false)?
     .visit_field::<bool>("is_final", Self::VT_IS_FINAL, false)?
     .finish();
    Ok(())
  }
}
pub struct TableRowArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub structure: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
    pub audience: Option<flatbuffers::WIPOffset<Audience<'a>>>,
    pub funct_class_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>>>,
    pub state_transition_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef<'a>>>>>,
    pub pre_condition_state_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef<'a>>>>>,
    pub is_executable: bool,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_mandatory: bool,
    pub is_final: bool,
}
impl<'a> Default for TableRowArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableRowArgs {
      short_name: None,
      long_name: None,
      key: None,
      dop: None,
      structure: None,
      sdgs: None,
      audience: None,
      funct_class_refs: None,
      state_transition_refs: None,
      pre_condition_state_refs: None,
      is_executable: true,
      semantic: None,
      is_mandatory: false,
      is_final: false,
    }
  }
}

pub struct TableRowBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableRowBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(TableRow::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_KEY, key);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(TableRow::VT_DOP, dop);
  }
  #[inline]
  pub fn add_structure(&mut self, structure: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(TableRow::VT_STRUCTURE, structure);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(TableRow::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn add_audience(&mut self, audience: flatbuffers::WIPOffset<Audience<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Audience>>(TableRow::VT_AUDIENCE, audience);
  }
  #[inline]
  pub fn add_funct_class_refs(&mut self, funct_class_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctClass<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_FUNCT_CLASS_REFS, funct_class_refs);
  }
  #[inline]
  pub fn add_state_transition_refs(&mut self, state_transition_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateTransitionRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_STATE_TRANSITION_REFS, state_transition_refs);
  }
  #[inline]
  pub fn add_pre_condition_state_refs(&mut self, pre_condition_state_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PreConditionStateRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_PRE_CONDITION_STATE_REFS, pre_condition_state_refs);
  }
  #[inline]
  pub fn add_is_executable(&mut self, is_executable: bool) {
    self.fbb_.push_slot::<bool>(TableRow::VT_IS_EXECUTABLE, is_executable, true);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableRow::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn add_is_mandatory(&mut self, is_mandatory: bool) {
    self.fbb_.push_slot::<bool>(TableRow::VT_IS_MANDATORY, is_mandatory, false);
  }
  #[inline]
  pub fn add_is_final(&mut self, is_final: bool) {
    self.fbb_.push_slot::<bool>(TableRow::VT_IS_FINAL, is_final, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableRowBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableRowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableRow<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableRow<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableRow");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("key", &self.key());
      ds.field("dop", &self.dop());
      ds.field("structure", &self.structure());
      ds.field("sdgs", &self.sdgs());
      ds.field("audience", &self.audience());
      ds.field("funct_class_refs", &self.funct_class_refs());
      ds.field("state_transition_refs", &self.state_transition_refs());
      ds.field("pre_condition_state_refs", &self.pre_condition_state_refs());
      ds.field("is_executable", &self.is_executable());
      ds.field("semantic", &self.semantic());
      ds.field("is_mandatory", &self.is_mandatory());
      ds.field("is_final", &self.is_final());
      ds.finish()
  }
}
pub enum TableDiagCommConnectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableDiagCommConnector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableDiagCommConnector<'a> {
  type Inner = TableDiagCommConnector<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableDiagCommConnector<'a> {
  pub const VT_DIAG_COMM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DIAG_COMM: flatbuffers::VOffsetT = 6;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableDiagCommConnector { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableDiagCommConnectorArgs<'args>
  ) -> flatbuffers::WIPOffset<TableDiagCommConnector<'bldr>> {
    let mut builder = TableDiagCommConnectorBuilder::new(_fbb);
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.diag_comm { builder.add_diag_comm(x); }
    builder.add_diag_comm_type(args.diag_comm_type);
    builder.finish()
  }


  #[inline]
  pub fn diag_comm_type(&self) -> DiagServiceOrJob {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DiagServiceOrJob>(TableDiagCommConnector::VT_DIAG_COMM_TYPE, Some(DiagServiceOrJob::NONE)).unwrap()}
  }
  #[inline]
  pub fn diag_comm(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(TableDiagCommConnector::VT_DIAG_COMM, None)}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableDiagCommConnector::VT_SEMANTIC, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn diag_comm_as_diag_service(&self) -> Option<DiagService<'a>> {
    if self.diag_comm_type() == DiagServiceOrJob::DiagService {
      self.diag_comm().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DiagService::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn diag_comm_as_single_ecu_job(&self) -> Option<SingleEcuJob<'a>> {
    if self.diag_comm_type() == DiagServiceOrJob::SingleEcuJob {
      self.diag_comm().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SingleEcuJob::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for TableDiagCommConnector<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<DiagServiceOrJobUnionValue>("diag_comm_type", Self::VT_DIAG_COMM_TYPE, "diag_comm", Self::VT_DIAG_COMM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .finish();
    Ok(())
  }
}
pub struct TableDiagCommConnectorArgs<'a> {
    pub diag_comm_type: DiagServiceOrJob,
    pub diag_comm: Option<flatbuffers::WIPOffset<DiagServiceOrJobUnionValue>>,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TableDiagCommConnectorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableDiagCommConnectorArgs {
      diag_comm_type: DiagServiceOrJob::NONE,
      diag_comm: None,
      semantic: None,
    }
  }
}

pub struct TableDiagCommConnectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableDiagCommConnectorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_comm_type(&mut self, diag_comm_type: DiagServiceOrJob) {
    self.fbb_.push_slot::<DiagServiceOrJob>(TableDiagCommConnector::VT_DIAG_COMM_TYPE, diag_comm_type, DiagServiceOrJob::NONE);
  }
  #[inline]
  pub fn add_diag_comm(&mut self, diag_comm: flatbuffers::WIPOffset<DiagServiceOrJobUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDiagCommConnector::VT_DIAG_COMM, diag_comm);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDiagCommConnector::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableDiagCommConnectorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableDiagCommConnectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableDiagCommConnector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableDiagCommConnector<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableDiagCommConnector");
      ds.field("diag_comm_type", &self.diag_comm_type());
      match self.diag_comm_type() {
        DiagServiceOrJob::DiagService => {
          if let Some(x) = self.diag_comm_as_diag_service() {
            ds.field("diag_comm", &x)
          } else {
            ds.field("diag_comm", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DiagServiceOrJob::SingleEcuJob => {
          if let Some(x) = self.diag_comm_as_single_ecu_job() {
            ds.field("diag_comm", &x)
          } else {
            ds.field("diag_comm", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("diag_comm", &x)
        },
      };
      ds.field("semantic", &self.semantic());
      ds.finish()
  }
}
pub enum TableDopOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableDop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableDop<'a> {
  type Inner = TableDop<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableDop<'a> {
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_KEY_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_STRUCT_LABEL: flatbuffers::VOffsetT = 12;
  pub const VT_KEY_DOP: flatbuffers::VOffsetT = 14;
  pub const VT_ROWS: flatbuffers::VOffsetT = 16;
  pub const VT_DIAG_COMM_CONNECTOR: flatbuffers::VOffsetT = 18;
  pub const VT_SDGS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableDop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableDopArgs<'args>
  ) -> flatbuffers::WIPOffset<TableDop<'bldr>> {
    let mut builder = TableDopBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.diag_comm_connector { builder.add_diag_comm_connector(x); }
    if let Some(x) = args.rows { builder.add_rows(x); }
    if let Some(x) = args.key_dop { builder.add_key_dop(x); }
    if let Some(x) = args.struct_label { builder.add_struct_label(x); }
    if let Some(x) = args.key_label { builder.add_key_label(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    builder.finish()
  }


  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableDop::VT_SEMANTIC, None)}
  }
  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableDop::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(TableDop::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn key_label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableDop::VT_KEY_LABEL, None)}
  }
  #[inline]
  pub fn struct_label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableDop::VT_STRUCT_LABEL, None)}
  }
  #[inline]
  pub fn key_dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(TableDop::VT_KEY_DOP, None)}
  }
  #[inline]
  pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableRow<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableRow>>>>(TableDop::VT_ROWS, None)}
  }
  #[inline]
  pub fn diag_comm_connector(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableDiagCommConnector<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableDiagCommConnector>>>>(TableDop::VT_DIAG_COMM_CONNECTOR, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(TableDop::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for TableDop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key_label", Self::VT_KEY_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("struct_label", Self::VT_STRUCT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("key_dop", Self::VT_KEY_DOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TableRow>>>>("rows", Self::VT_ROWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TableDiagCommConnector>>>>("diag_comm_connector", Self::VT_DIAG_COMM_CONNECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct TableDopArgs<'a> {
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub key_label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub struct_label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key_dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableRow<'a>>>>>,
    pub diag_comm_connector: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableDiagCommConnector<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
}
impl<'a> Default for TableDopArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableDopArgs {
      semantic: None,
      short_name: None,
      long_name: None,
      key_label: None,
      struct_label: None,
      key_dop: None,
      rows: None,
      diag_comm_connector: None,
      sdgs: None,
    }
  }
}

pub struct TableDopBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableDopBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(TableDop::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_key_label(&mut self, key_label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_KEY_LABEL, key_label);
  }
  #[inline]
  pub fn add_struct_label(&mut self, struct_label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_STRUCT_LABEL, struct_label);
  }
  #[inline]
  pub fn add_key_dop(&mut self, key_dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(TableDop::VT_KEY_DOP, key_dop);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TableRow<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_ROWS, rows);
  }
  #[inline]
  pub fn add_diag_comm_connector(&mut self, diag_comm_connector: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TableDiagCommConnector<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableDop::VT_DIAG_COMM_CONNECTOR, diag_comm_connector);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(TableDop::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableDopBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableDopBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableDop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableDop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableDop");
      ds.field("semantic", &self.semantic());
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("key_label", &self.key_label());
      ds.field("struct_label", &self.struct_label());
      ds.field("key_dop", &self.key_dop());
      ds.field("rows", &self.rows());
      ds.field("diag_comm_connector", &self.diag_comm_connector());
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum CodedConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CodedConst<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CodedConst<'a> {
  type Inner = CodedConst<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CodedConst<'a> {
  pub const VT_CODED_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DIAG_CODED_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CodedConst { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CodedConstArgs<'args>
  ) -> flatbuffers::WIPOffset<CodedConst<'bldr>> {
    let mut builder = CodedConstBuilder::new(_fbb);
    if let Some(x) = args.diag_coded_type { builder.add_diag_coded_type(x); }
    if let Some(x) = args.coded_value { builder.add_coded_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn coded_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CodedConst::VT_CODED_VALUE, None)}
  }
  #[inline]
  pub fn diag_coded_type(&self) -> Option<DiagCodedType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagCodedType>>(CodedConst::VT_DIAG_CODED_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for CodedConst<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coded_value", Self::VT_CODED_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagCodedType>>("diag_coded_type", Self::VT_DIAG_CODED_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CodedConstArgs<'a> {
    pub coded_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diag_coded_type: Option<flatbuffers::WIPOffset<DiagCodedType<'a>>>,
}
impl<'a> Default for CodedConstArgs<'a> {
  #[inline]
  fn default() -> Self {
    CodedConstArgs {
      coded_value: None,
      diag_coded_type: None,
    }
  }
}

pub struct CodedConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CodedConstBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_coded_value(&mut self, coded_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CodedConst::VT_CODED_VALUE, coded_value);
  }
  #[inline]
  pub fn add_diag_coded_type(&mut self, diag_coded_type: flatbuffers::WIPOffset<DiagCodedType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagCodedType>>(CodedConst::VT_DIAG_CODED_TYPE, diag_coded_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CodedConstBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CodedConstBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CodedConst<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CodedConst<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CodedConst");
      ds.field("coded_value", &self.coded_value());
      ds.field("diag_coded_type", &self.diag_coded_type());
      ds.finish()
  }
}
pub enum DynamicOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dynamic<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dynamic<'a> {
  type Inner = Dynamic<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Dynamic<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dynamic { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args DynamicArgs
  ) -> flatbuffers::WIPOffset<Dynamic<'bldr>> {
    let mut builder = DynamicBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Dynamic<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DynamicArgs {
}
impl<'a> Default for DynamicArgs {
  #[inline]
  fn default() -> Self {
    DynamicArgs {
    }
  }
}

pub struct DynamicBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DynamicBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DynamicBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DynamicBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dynamic<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Dynamic<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Dynamic");
      ds.finish()
  }
}
pub enum LengthKeyRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LengthKeyRef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LengthKeyRef<'a> {
  type Inner = LengthKeyRef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> LengthKeyRef<'a> {
  pub const VT_DOP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LengthKeyRef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LengthKeyRefArgs<'args>
  ) -> flatbuffers::WIPOffset<LengthKeyRef<'bldr>> {
    let mut builder = LengthKeyRefBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    builder.finish()
  }


  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(LengthKeyRef::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for LengthKeyRef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct LengthKeyRefArgs<'a> {
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for LengthKeyRefArgs<'a> {
  #[inline]
  fn default() -> Self {
    LengthKeyRefArgs {
      dop: None,
    }
  }
}

pub struct LengthKeyRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LengthKeyRefBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(LengthKeyRef::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LengthKeyRefBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LengthKeyRefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LengthKeyRef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LengthKeyRef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LengthKeyRef");
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum MatchingRequestParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingRequestParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingRequestParam<'a> {
  type Inner = MatchingRequestParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> MatchingRequestParam<'a> {
  pub const VT_REQUEST_BYTE_POS: flatbuffers::VOffsetT = 4;
  pub const VT_BYTE_LENGTH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingRequestParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingRequestParamArgs
  ) -> flatbuffers::WIPOffset<MatchingRequestParam<'bldr>> {
    let mut builder = MatchingRequestParamBuilder::new(_fbb);
    builder.add_byte_length(args.byte_length);
    builder.add_request_byte_pos(args.request_byte_pos);
    builder.finish()
  }


  #[inline]
  pub fn request_byte_pos(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MatchingRequestParam::VT_REQUEST_BYTE_POS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn byte_length(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MatchingRequestParam::VT_BYTE_LENGTH, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MatchingRequestParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("request_byte_pos", Self::VT_REQUEST_BYTE_POS, false)?
     .visit_field::<u32>("byte_length", Self::VT_BYTE_LENGTH, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingRequestParamArgs {
    pub request_byte_pos: i32,
    pub byte_length: u32,
}
impl<'a> Default for MatchingRequestParamArgs {
  #[inline]
  fn default() -> Self {
    MatchingRequestParamArgs {
      request_byte_pos: 0,
      byte_length: 0,
    }
  }
}

pub struct MatchingRequestParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingRequestParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_request_byte_pos(&mut self, request_byte_pos: i32) {
    self.fbb_.push_slot::<i32>(MatchingRequestParam::VT_REQUEST_BYTE_POS, request_byte_pos, 0);
  }
  #[inline]
  pub fn add_byte_length(&mut self, byte_length: u32) {
    self.fbb_.push_slot::<u32>(MatchingRequestParam::VT_BYTE_LENGTH, byte_length, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingRequestParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingRequestParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingRequestParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingRequestParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingRequestParam");
      ds.field("request_byte_pos", &self.request_byte_pos());
      ds.field("byte_length", &self.byte_length());
      ds.finish()
  }
}
pub enum NrcConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NrcConst<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NrcConst<'a> {
  type Inner = NrcConst<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> NrcConst<'a> {
  pub const VT_CODED_VALUES: flatbuffers::VOffsetT = 4;
  pub const VT_DIAG_CODED_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NrcConst { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NrcConstArgs<'args>
  ) -> flatbuffers::WIPOffset<NrcConst<'bldr>> {
    let mut builder = NrcConstBuilder::new(_fbb);
    if let Some(x) = args.diag_coded_type { builder.add_diag_coded_type(x); }
    if let Some(x) = args.coded_values { builder.add_coded_values(x); }
    builder.finish()
  }


  #[inline]
  pub fn coded_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(NrcConst::VT_CODED_VALUES, None)}
  }
  #[inline]
  pub fn diag_coded_type(&self) -> Option<DiagCodedType<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagCodedType>>(NrcConst::VT_DIAG_CODED_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for NrcConst<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("coded_values", Self::VT_CODED_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagCodedType>>("diag_coded_type", Self::VT_DIAG_CODED_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct NrcConstArgs<'a> {
    pub coded_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub diag_coded_type: Option<flatbuffers::WIPOffset<DiagCodedType<'a>>>,
}
impl<'a> Default for NrcConstArgs<'a> {
  #[inline]
  fn default() -> Self {
    NrcConstArgs {
      coded_values: None,
      diag_coded_type: None,
    }
  }
}

pub struct NrcConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NrcConstBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_coded_values(&mut self, coded_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NrcConst::VT_CODED_VALUES, coded_values);
  }
  #[inline]
  pub fn add_diag_coded_type(&mut self, diag_coded_type: flatbuffers::WIPOffset<DiagCodedType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagCodedType>>(NrcConst::VT_DIAG_CODED_TYPE, diag_coded_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NrcConstBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NrcConstBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NrcConst<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NrcConst<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NrcConst");
      ds.field("coded_values", &self.coded_values());
      ds.field("diag_coded_type", &self.diag_coded_type());
      ds.finish()
  }
}
pub enum PhysConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PhysConst<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PhysConst<'a> {
  type Inner = PhysConst<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PhysConst<'a> {
  pub const VT_PHYS_CONSTANT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DOP: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PhysConst { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PhysConstArgs<'args>
  ) -> flatbuffers::WIPOffset<PhysConst<'bldr>> {
    let mut builder = PhysConstBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    if let Some(x) = args.phys_constant_value { builder.add_phys_constant_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn phys_constant_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PhysConst::VT_PHYS_CONSTANT_VALUE, None)}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(PhysConst::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for PhysConst<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("phys_constant_value", Self::VT_PHYS_CONSTANT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct PhysConstArgs<'a> {
    pub phys_constant_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for PhysConstArgs<'a> {
  #[inline]
  fn default() -> Self {
    PhysConstArgs {
      phys_constant_value: None,
      dop: None,
    }
  }
}

pub struct PhysConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PhysConstBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_phys_constant_value(&mut self, phys_constant_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PhysConst::VT_PHYS_CONSTANT_VALUE, phys_constant_value);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(PhysConst::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PhysConstBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PhysConstBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PhysConst<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PhysConst<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PhysConst");
      ds.field("phys_constant_value", &self.phys_constant_value());
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum ReservedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Reserved<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Reserved<'a> {
  type Inner = Reserved<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Reserved<'a> {
  pub const VT_BIT_LENGTH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Reserved { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ReservedArgs
  ) -> flatbuffers::WIPOffset<Reserved<'bldr>> {
    let mut builder = ReservedBuilder::new(_fbb);
    builder.add_bit_length(args.bit_length);
    builder.finish()
  }


  #[inline]
  pub fn bit_length(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Reserved::VT_BIT_LENGTH, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Reserved<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("bit_length", Self::VT_BIT_LENGTH, false)?
     .finish();
    Ok(())
  }
}
pub struct ReservedArgs {
    pub bit_length: u32,
}
impl<'a> Default for ReservedArgs {
  #[inline]
  fn default() -> Self {
    ReservedArgs {
      bit_length: 0,
    }
  }
}

pub struct ReservedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReservedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_bit_length(&mut self, bit_length: u32) {
    self.fbb_.push_slot::<u32>(Reserved::VT_BIT_LENGTH, bit_length, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReservedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReservedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Reserved<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Reserved<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Reserved");
      ds.field("bit_length", &self.bit_length());
      ds.finish()
  }
}
pub enum SystemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct System<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for System<'a> {
  type Inner = System<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> System<'a> {
  pub const VT_DOP: flatbuffers::VOffsetT = 4;
  pub const VT_SYS_PARAM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    System { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SystemArgs<'args>
  ) -> flatbuffers::WIPOffset<System<'bldr>> {
    let mut builder = SystemBuilder::new(_fbb);
    if let Some(x) = args.sys_param { builder.add_sys_param(x); }
    if let Some(x) = args.dop { builder.add_dop(x); }
    builder.finish()
  }


  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(System::VT_DOP, None)}
  }
  #[inline]
  pub fn sys_param(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(System::VT_SYS_PARAM, None)}
  }
}

impl flatbuffers::Verifiable for System<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sys_param", Self::VT_SYS_PARAM, false)?
     .finish();
    Ok(())
  }
}
pub struct SystemArgs<'a> {
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub sys_param: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SystemArgs<'a> {
  #[inline]
  fn default() -> Self {
    SystemArgs {
      dop: None,
      sys_param: None,
    }
  }
}

pub struct SystemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SystemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(System::VT_DOP, dop);
  }
  #[inline]
  pub fn add_sys_param(&mut self, sys_param: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(System::VT_SYS_PARAM, sys_param);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SystemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SystemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<System<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for System<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("System");
      ds.field("dop", &self.dop());
      ds.field("sys_param", &self.sys_param());
      ds.finish()
  }
}
pub enum TableEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableEntry<'a> {
  type Inner = TableEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableEntry<'a> {
  pub const VT_PARAM: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_ROW: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<TableEntry<'bldr>> {
    let mut builder = TableEntryBuilder::new(_fbb);
    if let Some(x) = args.table_row { builder.add_table_row(x); }
    if let Some(x) = args.param { builder.add_param(x); }
    builder.add_target(args.target);
    builder.finish()
  }


  #[inline]
  pub fn param(&self) -> Option<Param<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Param>>(TableEntry::VT_PARAM, None)}
  }
  #[inline]
  pub fn target(&self) -> TableEntryRowFragment {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TableEntryRowFragment>(TableEntry::VT_TARGET, Some(TableEntryRowFragment::KEY)).unwrap()}
  }
  #[inline]
  pub fn table_row(&self) -> Option<TableRow<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TableRow>>(TableEntry::VT_TABLE_ROW, None)}
  }
}

impl flatbuffers::Verifiable for TableEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Param>>("param", Self::VT_PARAM, false)?
     .visit_field::<TableEntryRowFragment>("target", Self::VT_TARGET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TableRow>>("table_row", Self::VT_TABLE_ROW, false)?
     .finish();
    Ok(())
  }
}
pub struct TableEntryArgs<'a> {
    pub param: Option<flatbuffers::WIPOffset<Param<'a>>>,
    pub target: TableEntryRowFragment,
    pub table_row: Option<flatbuffers::WIPOffset<TableRow<'a>>>,
}
impl<'a> Default for TableEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableEntryArgs {
      param: None,
      target: TableEntryRowFragment::KEY,
      table_row: None,
    }
  }
}

pub struct TableEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_param(&mut self, param: flatbuffers::WIPOffset<Param<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Param>>(TableEntry::VT_PARAM, param);
  }
  #[inline]
  pub fn add_target(&mut self, target: TableEntryRowFragment) {
    self.fbb_.push_slot::<TableEntryRowFragment>(TableEntry::VT_TARGET, target, TableEntryRowFragment::KEY);
  }
  #[inline]
  pub fn add_table_row(&mut self, table_row: flatbuffers::WIPOffset<TableRow<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TableRow>>(TableEntry::VT_TABLE_ROW, table_row);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableEntry");
      ds.field("param", &self.param());
      ds.field("target", &self.target());
      ds.field("table_row", &self.table_row());
      ds.finish()
  }
}
pub enum TableKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableKey<'a> {
  type Inner = TableKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableKey<'a> {
  pub const VT_TABLE_KEY_REFERENCE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_TABLE_KEY_REFERENCE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableKeyArgs
  ) -> flatbuffers::WIPOffset<TableKey<'bldr>> {
    let mut builder = TableKeyBuilder::new(_fbb);
    if let Some(x) = args.table_key_reference { builder.add_table_key_reference(x); }
    builder.add_table_key_reference_type(args.table_key_reference_type);
    builder.finish()
  }


  #[inline]
  pub fn table_key_reference_type(&self) -> TableKeyReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TableKeyReference>(TableKey::VT_TABLE_KEY_REFERENCE_TYPE, Some(TableKeyReference::NONE)).unwrap()}
  }
  #[inline]
  pub fn table_key_reference(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(TableKey::VT_TABLE_KEY_REFERENCE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn table_key_reference_as_table_dop(&self) -> Option<TableDop<'a>> {
    if self.table_key_reference_type() == TableKeyReference::TableDop {
      self.table_key_reference().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableDop::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn table_key_reference_as_table_row(&self) -> Option<TableRow<'a>> {
    if self.table_key_reference_type() == TableKeyReference::TableRow {
      self.table_key_reference().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableRow::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for TableKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<TableKeyReferenceUnionValue>("table_key_reference_type", Self::VT_TABLE_KEY_REFERENCE_TYPE, "table_key_reference", Self::VT_TABLE_KEY_REFERENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct TableKeyArgs {
    pub table_key_reference_type: TableKeyReference,
    pub table_key_reference: Option<flatbuffers::WIPOffset<TableKeyReferenceUnionValue>>,
}
impl<'a> Default for TableKeyArgs {
  #[inline]
  fn default() -> Self {
    TableKeyArgs {
      table_key_reference_type: TableKeyReference::NONE,
      table_key_reference: None,
    }
  }
}

pub struct TableKeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableKeyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_table_key_reference_type(&mut self, table_key_reference_type: TableKeyReference) {
    self.fbb_.push_slot::<TableKeyReference>(TableKey::VT_TABLE_KEY_REFERENCE_TYPE, table_key_reference_type, TableKeyReference::NONE);
  }
  #[inline]
  pub fn add_table_key_reference(&mut self, table_key_reference: flatbuffers::WIPOffset<TableKeyReferenceUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableKey::VT_TABLE_KEY_REFERENCE, table_key_reference);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableKeyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableKey");
      ds.field("table_key_reference_type", &self.table_key_reference_type());
      match self.table_key_reference_type() {
        TableKeyReference::TableDop => {
          if let Some(x) = self.table_key_reference_as_table_dop() {
            ds.field("table_key_reference", &x)
          } else {
            ds.field("table_key_reference", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TableKeyReference::TableRow => {
          if let Some(x) = self.table_key_reference_as_table_row() {
            ds.field("table_key_reference", &x)
          } else {
            ds.field("table_key_reference", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("table_key_reference", &x)
        },
      };
      ds.finish()
  }
}
pub enum TableStructOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TableStruct<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableStruct<'a> {
  type Inner = TableStruct<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TableStruct<'a> {
  pub const VT_TABLE_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TableStruct { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TableStructArgs<'args>
  ) -> flatbuffers::WIPOffset<TableStruct<'bldr>> {
    let mut builder = TableStructBuilder::new(_fbb);
    if let Some(x) = args.table_key { builder.add_table_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn table_key(&self) -> Option<Param<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Param>>(TableStruct::VT_TABLE_KEY, None)}
  }
}

impl flatbuffers::Verifiable for TableStruct<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Param>>("table_key", Self::VT_TABLE_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct TableStructArgs<'a> {
    pub table_key: Option<flatbuffers::WIPOffset<Param<'a>>>,
}
impl<'a> Default for TableStructArgs<'a> {
  #[inline]
  fn default() -> Self {
    TableStructArgs {
      table_key: None,
    }
  }
}

pub struct TableStructBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TableStructBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_table_key(&mut self, table_key: flatbuffers::WIPOffset<Param<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Param>>(TableStruct::VT_TABLE_KEY, table_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TableStructBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TableStructBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableStruct<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TableStruct<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TableStruct");
      ds.field("table_key", &self.table_key());
      ds.finish()
  }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
  type Inner = Value<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Value<'a> {
  pub const VT_PHYSICAL_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DOP: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Value { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueArgs<'args>
  ) -> flatbuffers::WIPOffset<Value<'bldr>> {
    let mut builder = ValueBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    if let Some(x) = args.physical_default_value { builder.add_physical_default_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn physical_default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Value::VT_PHYSICAL_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(Value::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for Value<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("physical_default_value", Self::VT_PHYSICAL_DEFAULT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueArgs<'a> {
    pub physical_default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for ValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueArgs {
      physical_default_value: None,
      dop: None,
    }
  }
}

pub struct ValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_physical_default_value(&mut self, physical_default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_PHYSICAL_DEFAULT_VALUE, physical_default_value);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(Value::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Value<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Value");
      ds.field("physical_default_value", &self.physical_default_value());
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum ParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Param<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Param<'a> {
  type Inner = Param<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Param<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PARAM_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 10;
  pub const VT_SDGS: flatbuffers::VOffsetT = 12;
  pub const VT_PHYSICAL_DEFAULT_VALUE: flatbuffers::VOffsetT = 14;
  pub const VT_BYTE_POSITION: flatbuffers::VOffsetT = 16;
  pub const VT_BIT_POSITION: flatbuffers::VOffsetT = 18;
  pub const VT_SPECIFIC_DATA_TYPE: flatbuffers::VOffsetT = 20;
  pub const VT_SPECIFIC_DATA: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Param { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParamArgs<'args>
  ) -> flatbuffers::WIPOffset<Param<'bldr>> {
    let mut builder = ParamBuilder::new(_fbb);
    if let Some(x) = args.specific_data { builder.add_specific_data(x); }
    if let Some(x) = args.bit_position { builder.add_bit_position(x); }
    if let Some(x) = args.byte_position { builder.add_byte_position(x); }
    if let Some(x) = args.physical_default_value { builder.add_physical_default_value(x); }
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_id(args.id);
    builder.add_specific_data_type(args.specific_data_type);
    builder.add_param_type(args.param_type);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn param_type(&self) -> ParamType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParamType>(Param::VT_PARAM_TYPE, Some(ParamType::CODED_CONST)).unwrap()}
  }
  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Param::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Param::VT_SEMANTIC, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(Param::VT_SDGS, None)}
  }
  #[inline]
  pub fn physical_default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Param::VT_PHYSICAL_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn byte_position(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_BYTE_POSITION, None)}
  }
  #[inline]
  pub fn bit_position(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Param::VT_BIT_POSITION, None)}
  }
  #[inline]
  pub fn specific_data_type(&self) -> ParamSpecificData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParamSpecificData>(Param::VT_SPECIFIC_DATA_TYPE, Some(ParamSpecificData::NONE)).unwrap()}
  }
  #[inline]
  pub fn specific_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Param::VT_SPECIFIC_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_coded_const(&self) -> Option<CodedConst<'a>> {
    if self.specific_data_type() == ParamSpecificData::CodedConst {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CodedConst::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_dynamic(&self) -> Option<Dynamic<'a>> {
    if self.specific_data_type() == ParamSpecificData::Dynamic {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Dynamic::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_matching_request_param(&self) -> Option<MatchingRequestParam<'a>> {
    if self.specific_data_type() == ParamSpecificData::MatchingRequestParam {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { MatchingRequestParam::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_nrc_const(&self) -> Option<NrcConst<'a>> {
    if self.specific_data_type() == ParamSpecificData::NrcConst {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { NrcConst::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_phys_const(&self) -> Option<PhysConst<'a>> {
    if self.specific_data_type() == ParamSpecificData::PhysConst {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PhysConst::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_reserved(&self) -> Option<Reserved<'a>> {
    if self.specific_data_type() == ParamSpecificData::Reserved {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Reserved::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_value(&self) -> Option<Value<'a>> {
    if self.specific_data_type() == ParamSpecificData::Value {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Value::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_table_entry(&self) -> Option<TableEntry<'a>> {
    if self.specific_data_type() == ParamSpecificData::TableEntry {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableEntry::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_table_key(&self) -> Option<TableKey<'a>> {
    if self.specific_data_type() == ParamSpecificData::TableKey {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableKey::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_table_struct(&self) -> Option<TableStruct<'a>> {
    if self.specific_data_type() == ParamSpecificData::TableStruct {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableStruct::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_system(&self) -> Option<System<'a>> {
    if self.specific_data_type() == ParamSpecificData::System {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { System::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_length_key_ref(&self) -> Option<LengthKeyRef<'a>> {
    if self.specific_data_type() == ParamSpecificData::LengthKeyRef {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LengthKeyRef::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Param<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<ParamType>("param_type", Self::VT_PARAM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("physical_default_value", Self::VT_PHYSICAL_DEFAULT_VALUE, false)?
     .visit_field::<u32>("byte_position", Self::VT_BYTE_POSITION, false)?
     .visit_field::<u32>("bit_position", Self::VT_BIT_POSITION, false)?
     .visit_union::<ParamSpecificDataUnionValue>("specific_data_type", Self::VT_SPECIFIC_DATA_TYPE, "specific_data", Self::VT_SPECIFIC_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ParamArgs<'a> {
    pub id: u32,
    pub param_type: ParamType,
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
    pub physical_default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub byte_position: Option<u32>,
    pub bit_position: Option<u32>,
    pub specific_data_type: ParamSpecificData,
    pub specific_data: Option<flatbuffers::WIPOffset<ParamSpecificDataUnionValue>>,
}
impl<'a> Default for ParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParamArgs {
      id: 0,
      param_type: ParamType::CODED_CONST,
      short_name: None,
      semantic: None,
      sdgs: None,
      physical_default_value: None,
      byte_position: None,
      bit_position: None,
      specific_data_type: ParamSpecificData::NONE,
      specific_data: None,
    }
  }
}

pub struct ParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Param::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_param_type(&mut self, param_type: ParamType) {
    self.fbb_.push_slot::<ParamType>(Param::VT_PARAM_TYPE, param_type, ParamType::CODED_CONST);
  }
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Param::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Param::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(Param::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn add_physical_default_value(&mut self, physical_default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Param::VT_PHYSICAL_DEFAULT_VALUE, physical_default_value);
  }
  #[inline]
  pub fn add_byte_position(&mut self, byte_position: u32) {
    self.fbb_.push_slot_always::<u32>(Param::VT_BYTE_POSITION, byte_position);
  }
  #[inline]
  pub fn add_bit_position(&mut self, bit_position: u32) {
    self.fbb_.push_slot_always::<u32>(Param::VT_BIT_POSITION, bit_position);
  }
  #[inline]
  pub fn add_specific_data_type(&mut self, specific_data_type: ParamSpecificData) {
    self.fbb_.push_slot::<ParamSpecificData>(Param::VT_SPECIFIC_DATA_TYPE, specific_data_type, ParamSpecificData::NONE);
  }
  #[inline]
  pub fn add_specific_data(&mut self, specific_data: flatbuffers::WIPOffset<ParamSpecificDataUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Param::VT_SPECIFIC_DATA, specific_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Param<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Param<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Param");
      ds.field("id", &self.id());
      ds.field("param_type", &self.param_type());
      ds.field("short_name", &self.short_name());
      ds.field("semantic", &self.semantic());
      ds.field("sdgs", &self.sdgs());
      ds.field("physical_default_value", &self.physical_default_value());
      ds.field("byte_position", &self.byte_position());
      ds.field("bit_position", &self.bit_position());
      ds.field("specific_data_type", &self.specific_data_type());
      match self.specific_data_type() {
        ParamSpecificData::CodedConst => {
          if let Some(x) = self.specific_data_as_coded_const() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::Dynamic => {
          if let Some(x) = self.specific_data_as_dynamic() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::MatchingRequestParam => {
          if let Some(x) = self.specific_data_as_matching_request_param() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::NrcConst => {
          if let Some(x) = self.specific_data_as_nrc_const() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::PhysConst => {
          if let Some(x) = self.specific_data_as_phys_const() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::Reserved => {
          if let Some(x) = self.specific_data_as_reserved() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::Value => {
          if let Some(x) = self.specific_data_as_value() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::TableEntry => {
          if let Some(x) = self.specific_data_as_table_entry() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::TableKey => {
          if let Some(x) = self.specific_data_as_table_key() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::TableStruct => {
          if let Some(x) = self.specific_data_as_table_struct() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::System => {
          if let Some(x) = self.specific_data_as_system() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParamSpecificData::LengthKeyRef => {
          if let Some(x) = self.specific_data_as_length_key_ref() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("specific_data", &x)
        },
      };
      ds.finish()
  }
}
pub enum FunctClassOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FunctClass<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctClass<'a> {
  type Inner = FunctClass<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> FunctClass<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FunctClass { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FunctClassArgs<'args>
  ) -> flatbuffers::WIPOffset<FunctClass<'bldr>> {
    let mut builder = FunctClassBuilder::new(_fbb);
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FunctClass::VT_SHORT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for FunctClass<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct FunctClassArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FunctClassArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctClassArgs {
      short_name: None,
    }
  }
}

pub struct FunctClassBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FunctClassBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctClass::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FunctClassBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FunctClassBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctClass<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FunctClass<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FunctClass");
      ds.field("short_name", &self.short_name());
      ds.finish()
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Request<'a> {
  pub const VT_PARAMS: flatbuffers::VOffsetT = 4;
  pub const VT_SDGS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs<'args>
  ) -> flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    builder.finish()
  }


  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param>>>>(Request::VT_PARAMS, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(Request::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs<'a> {
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
}
impl<'a> Default for RequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      params: None,
      sdgs: None,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Param<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Request::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(Request::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("params", &self.params());
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Response<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Response<'a> {
  type Inner = Response<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Response<'a> {
  pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 6;
  pub const VT_SDGS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Response { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<Response<'bldr>> {
    let mut builder = ResponseBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    builder.add_response_type(args.response_type);
    builder.finish()
  }


  #[inline]
  pub fn response_type(&self) -> ResponseType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ResponseType>(Response::VT_RESPONSE_TYPE, Some(ResponseType::POS_RESPONSE)).unwrap()}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param>>>>(Response::VT_PARAMS, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(Response::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for Response<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ResponseType>("response_type", Self::VT_RESPONSE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Param>>>>("params", Self::VT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResponseArgs<'a> {
    pub response_type: ResponseType,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Param<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
}
impl<'a> Default for ResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResponseArgs {
      response_type: ResponseType::POS_RESPONSE,
      params: None,
      sdgs: None,
    }
  }
}

pub struct ResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_response_type(&mut self, response_type: ResponseType) {
    self.fbb_.push_slot::<ResponseType>(Response::VT_RESPONSE_TYPE, response_type, ResponseType::POS_RESPONSE);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Param<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Response::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(Response::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Response<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Response<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Response");
      ds.field("response_type", &self.response_type());
      ds.field("params", &self.params());
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum AdditionalAudienceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AdditionalAudience<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AdditionalAudience<'a> {
  type Inner = AdditionalAudience<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> AdditionalAudience<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AdditionalAudience { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AdditionalAudienceArgs<'args>
  ) -> flatbuffers::WIPOffset<AdditionalAudience<'bldr>> {
    let mut builder = AdditionalAudienceBuilder::new(_fbb);
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AdditionalAudience::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(AdditionalAudience::VT_LONG_NAME, None)}
  }
}

impl flatbuffers::Verifiable for AdditionalAudience<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct AdditionalAudienceArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
}
impl<'a> Default for AdditionalAudienceArgs<'a> {
  #[inline]
  fn default() -> Self {
    AdditionalAudienceArgs {
      short_name: None,
      long_name: None,
    }
  }
}

pub struct AdditionalAudienceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AdditionalAudienceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AdditionalAudience::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(AdditionalAudience::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AdditionalAudienceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AdditionalAudienceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AdditionalAudience<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AdditionalAudience<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AdditionalAudience");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.finish()
  }
}
pub enum DiagCommOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DiagComm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DiagComm<'a> {
  type Inner = DiagComm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DiagComm<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 8;
  pub const VT_FUNCT_CLASS: flatbuffers::VOffsetT = 10;
  pub const VT_SDGS: flatbuffers::VOffsetT = 12;
  pub const VT_DIAG_CLASS_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_PRE_CONDITION_STATE_REFS: flatbuffers::VOffsetT = 16;
  pub const VT_STATE_TRANSITION_REFS: flatbuffers::VOffsetT = 18;
  pub const VT_PROTOCOLS: flatbuffers::VOffsetT = 20;
  pub const VT_AUDIENCE: flatbuffers::VOffsetT = 22;
  pub const VT_IS_MANDATORY: flatbuffers::VOffsetT = 24;
  pub const VT_IS_EXECUTABLE: flatbuffers::VOffsetT = 26;
  pub const VT_IS_FINAL: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DiagComm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DiagCommArgs<'args>
  ) -> flatbuffers::WIPOffset<DiagComm<'bldr>> {
    let mut builder = DiagCommBuilder::new(_fbb);
    if let Some(x) = args.audience { builder.add_audience(x); }
    if let Some(x) = args.protocols { builder.add_protocols(x); }
    if let Some(x) = args.state_transition_refs { builder.add_state_transition_refs(x); }
    if let Some(x) = args.pre_condition_state_refs { builder.add_pre_condition_state_refs(x); }
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.funct_class { builder.add_funct_class(x); }
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_is_final(args.is_final);
    builder.add_is_executable(args.is_executable);
    builder.add_is_mandatory(args.is_mandatory);
    builder.add_diag_class_type(args.diag_class_type);
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiagComm::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(DiagComm::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiagComm::VT_SEMANTIC, None)}
  }
  #[inline]
  pub fn funct_class(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass>>>>(DiagComm::VT_FUNCT_CLASS, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(DiagComm::VT_SDGS, None)}
  }
  #[inline]
  pub fn diag_class_type(&self) -> DiagClassType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DiagClassType>(DiagComm::VT_DIAG_CLASS_TYPE, Some(DiagClassType::START_COMM)).unwrap()}
  }
  #[inline]
  pub fn pre_condition_state_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef>>>>(DiagComm::VT_PRE_CONDITION_STATE_REFS, None)}
  }
  #[inline]
  pub fn state_transition_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef>>>>(DiagComm::VT_STATE_TRANSITION_REFS, None)}
  }
  #[inline]
  pub fn protocols(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol>>>>(DiagComm::VT_PROTOCOLS, None)}
  }
  #[inline]
  pub fn audience(&self) -> Option<Audience<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Audience>>(DiagComm::VT_AUDIENCE, None)}
  }
  #[inline]
  pub fn is_mandatory(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagComm::VT_IS_MANDATORY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_executable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagComm::VT_IS_EXECUTABLE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn is_final(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagComm::VT_IS_FINAL, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DiagComm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctClass>>>>("funct_class", Self::VT_FUNCT_CLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .visit_field::<DiagClassType>("diag_class_type", Self::VT_DIAG_CLASS_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PreConditionStateRef>>>>("pre_condition_state_refs", Self::VT_PRE_CONDITION_STATE_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateTransitionRef>>>>("state_transition_refs", Self::VT_STATE_TRANSITION_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Protocol>>>>("protocols", Self::VT_PROTOCOLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Audience>>("audience", Self::VT_AUDIENCE, false)?
     .visit_field::<bool>("is_mandatory", Self::VT_IS_MANDATORY, false)?
     .visit_field::<bool>("is_executable", Self::VT_IS_EXECUTABLE, false)?
     .visit_field::<bool>("is_final", Self::VT_IS_FINAL, false)?
     .finish();
    Ok(())
  }
}
pub struct DiagCommArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub funct_class: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
    pub diag_class_type: DiagClassType,
    pub pre_condition_state_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PreConditionStateRef<'a>>>>>,
    pub state_transition_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateTransitionRef<'a>>>>>,
    pub protocols: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol<'a>>>>>,
    pub audience: Option<flatbuffers::WIPOffset<Audience<'a>>>,
    pub is_mandatory: bool,
    pub is_executable: bool,
    pub is_final: bool,
}
impl<'a> Default for DiagCommArgs<'a> {
  #[inline]
  fn default() -> Self {
    DiagCommArgs {
      short_name: None,
      long_name: None,
      semantic: None,
      funct_class: None,
      sdgs: None,
      diag_class_type: DiagClassType::START_COMM,
      pre_condition_state_refs: None,
      state_transition_refs: None,
      protocols: None,
      audience: None,
      is_mandatory: false,
      is_executable: true,
      is_final: false,
    }
  }
}

pub struct DiagCommBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiagCommBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(DiagComm::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn add_funct_class(&mut self, funct_class: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctClass<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_FUNCT_CLASS, funct_class);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(DiagComm::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn add_diag_class_type(&mut self, diag_class_type: DiagClassType) {
    self.fbb_.push_slot::<DiagClassType>(DiagComm::VT_DIAG_CLASS_TYPE, diag_class_type, DiagClassType::START_COMM);
  }
  #[inline]
  pub fn add_pre_condition_state_refs(&mut self, pre_condition_state_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PreConditionStateRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_PRE_CONDITION_STATE_REFS, pre_condition_state_refs);
  }
  #[inline]
  pub fn add_state_transition_refs(&mut self, state_transition_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateTransitionRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_STATE_TRANSITION_REFS, state_transition_refs);
  }
  #[inline]
  pub fn add_protocols(&mut self, protocols: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Protocol<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagComm::VT_PROTOCOLS, protocols);
  }
  #[inline]
  pub fn add_audience(&mut self, audience: flatbuffers::WIPOffset<Audience<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Audience>>(DiagComm::VT_AUDIENCE, audience);
  }
  #[inline]
  pub fn add_is_mandatory(&mut self, is_mandatory: bool) {
    self.fbb_.push_slot::<bool>(DiagComm::VT_IS_MANDATORY, is_mandatory, false);
  }
  #[inline]
  pub fn add_is_executable(&mut self, is_executable: bool) {
    self.fbb_.push_slot::<bool>(DiagComm::VT_IS_EXECUTABLE, is_executable, true);
  }
  #[inline]
  pub fn add_is_final(&mut self, is_final: bool) {
    self.fbb_.push_slot::<bool>(DiagComm::VT_IS_FINAL, is_final, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DiagCommBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DiagCommBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DiagComm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DiagComm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DiagComm");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("semantic", &self.semantic());
      ds.field("funct_class", &self.funct_class());
      ds.field("sdgs", &self.sdgs());
      ds.field("diag_class_type", &self.diag_class_type());
      ds.field("pre_condition_state_refs", &self.pre_condition_state_refs());
      ds.field("state_transition_refs", &self.state_transition_refs());
      ds.field("protocols", &self.protocols());
      ds.field("audience", &self.audience());
      ds.field("is_mandatory", &self.is_mandatory());
      ds.field("is_executable", &self.is_executable());
      ds.field("is_final", &self.is_final());
      ds.finish()
  }
}
pub enum DiagServiceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DiagService<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DiagService<'a> {
  type Inner = DiagService<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DiagService<'a> {
  pub const VT_DIAG_COMM: flatbuffers::VOffsetT = 4;
  pub const VT_REQUEST: flatbuffers::VOffsetT = 6;
  pub const VT_POS_RESPONSES: flatbuffers::VOffsetT = 8;
  pub const VT_NEG_RESPONSES: flatbuffers::VOffsetT = 10;
  pub const VT_IS_CYCLIC: flatbuffers::VOffsetT = 12;
  pub const VT_IS_MULTIPLE: flatbuffers::VOffsetT = 14;
  pub const VT_ADDRESSING: flatbuffers::VOffsetT = 16;
  pub const VT_TRANSMISSION_MODE: flatbuffers::VOffsetT = 18;
  pub const VT_COM_PARAM_REFS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DiagService { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DiagServiceArgs<'args>
  ) -> flatbuffers::WIPOffset<DiagService<'bldr>> {
    let mut builder = DiagServiceBuilder::new(_fbb);
    if let Some(x) = args.com_param_refs { builder.add_com_param_refs(x); }
    if let Some(x) = args.neg_responses { builder.add_neg_responses(x); }
    if let Some(x) = args.pos_responses { builder.add_pos_responses(x); }
    if let Some(x) = args.request { builder.add_request(x); }
    if let Some(x) = args.diag_comm { builder.add_diag_comm(x); }
    builder.add_transmission_mode(args.transmission_mode);
    builder.add_addressing(args.addressing);
    builder.add_is_multiple(args.is_multiple);
    builder.add_is_cyclic(args.is_cyclic);
    builder.finish()
  }


  #[inline]
  pub fn diag_comm(&self) -> Option<DiagComm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagComm>>(DiagService::VT_DIAG_COMM, None)}
  }
  #[inline]
  pub fn request(&self) -> Option<Request<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Request>>(DiagService::VT_REQUEST, None)}
  }
  #[inline]
  pub fn pos_responses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response>>>>(DiagService::VT_POS_RESPONSES, None)}
  }
  #[inline]
  pub fn neg_responses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response>>>>(DiagService::VT_NEG_RESPONSES, None)}
  }
  #[inline]
  pub fn is_cyclic(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagService::VT_IS_CYCLIC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_multiple(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DiagService::VT_IS_MULTIPLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn addressing(&self) -> Addressing {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Addressing>(DiagService::VT_ADDRESSING, Some(Addressing::FUNCTIONAL)).unwrap()}
  }
  #[inline]
  pub fn transmission_mode(&self) -> TransmissionMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TransmissionMode>(DiagService::VT_TRANSMISSION_MODE, Some(TransmissionMode::SEND_ONLY)).unwrap()}
  }
  #[inline]
  pub fn com_param_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef>>>>(DiagService::VT_COM_PARAM_REFS, None)}
  }
}

impl flatbuffers::Verifiable for DiagService<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagComm>>("diag_comm", Self::VT_DIAG_COMM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Request>>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Response>>>>("pos_responses", Self::VT_POS_RESPONSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Response>>>>("neg_responses", Self::VT_NEG_RESPONSES, false)?
     .visit_field::<bool>("is_cyclic", Self::VT_IS_CYCLIC, false)?
     .visit_field::<bool>("is_multiple", Self::VT_IS_MULTIPLE, false)?
     .visit_field::<Addressing>("addressing", Self::VT_ADDRESSING, false)?
     .visit_field::<TransmissionMode>("transmission_mode", Self::VT_TRANSMISSION_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParamRef>>>>("com_param_refs", Self::VT_COM_PARAM_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct DiagServiceArgs<'a> {
    pub diag_comm: Option<flatbuffers::WIPOffset<DiagComm<'a>>>,
    pub request: Option<flatbuffers::WIPOffset<Request<'a>>>,
    pub pos_responses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response<'a>>>>>,
    pub neg_responses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Response<'a>>>>>,
    pub is_cyclic: bool,
    pub is_multiple: bool,
    pub addressing: Addressing,
    pub transmission_mode: TransmissionMode,
    pub com_param_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef<'a>>>>>,
}
impl<'a> Default for DiagServiceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DiagServiceArgs {
      diag_comm: None,
      request: None,
      pos_responses: None,
      neg_responses: None,
      is_cyclic: false,
      is_multiple: false,
      addressing: Addressing::FUNCTIONAL,
      transmission_mode: TransmissionMode::SEND_ONLY,
      com_param_refs: None,
    }
  }
}

pub struct DiagServiceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiagServiceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_comm(&mut self, diag_comm: flatbuffers::WIPOffset<DiagComm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagComm>>(DiagService::VT_DIAG_COMM, diag_comm);
  }
  #[inline]
  pub fn add_request(&mut self, request: flatbuffers::WIPOffset<Request<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Request>>(DiagService::VT_REQUEST, request);
  }
  #[inline]
  pub fn add_pos_responses(&mut self, pos_responses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Response<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagService::VT_POS_RESPONSES, pos_responses);
  }
  #[inline]
  pub fn add_neg_responses(&mut self, neg_responses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Response<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagService::VT_NEG_RESPONSES, neg_responses);
  }
  #[inline]
  pub fn add_is_cyclic(&mut self, is_cyclic: bool) {
    self.fbb_.push_slot::<bool>(DiagService::VT_IS_CYCLIC, is_cyclic, false);
  }
  #[inline]
  pub fn add_is_multiple(&mut self, is_multiple: bool) {
    self.fbb_.push_slot::<bool>(DiagService::VT_IS_MULTIPLE, is_multiple, false);
  }
  #[inline]
  pub fn add_addressing(&mut self, addressing: Addressing) {
    self.fbb_.push_slot::<Addressing>(DiagService::VT_ADDRESSING, addressing, Addressing::FUNCTIONAL);
  }
  #[inline]
  pub fn add_transmission_mode(&mut self, transmission_mode: TransmissionMode) {
    self.fbb_.push_slot::<TransmissionMode>(DiagService::VT_TRANSMISSION_MODE, transmission_mode, TransmissionMode::SEND_ONLY);
  }
  #[inline]
  pub fn add_com_param_refs(&mut self, com_param_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParamRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagService::VT_COM_PARAM_REFS, com_param_refs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DiagServiceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DiagServiceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DiagService<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DiagService<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DiagService");
      ds.field("diag_comm", &self.diag_comm());
      ds.field("request", &self.request());
      ds.field("pos_responses", &self.pos_responses());
      ds.field("neg_responses", &self.neg_responses());
      ds.field("is_cyclic", &self.is_cyclic());
      ds.field("is_multiple", &self.is_multiple());
      ds.field("addressing", &self.addressing());
      ds.field("transmission_mode", &self.transmission_mode());
      ds.field("com_param_refs", &self.com_param_refs());
      ds.finish()
  }
}
pub enum ProgCodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProgCode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProgCode<'a> {
  type Inner = ProgCode<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ProgCode<'a> {
  pub const VT_CODE_FILE: flatbuffers::VOffsetT = 4;
  pub const VT_ENCRYPTION: flatbuffers::VOffsetT = 6;
  pub const VT_SYNTAX: flatbuffers::VOffsetT = 8;
  pub const VT_REVISION: flatbuffers::VOffsetT = 10;
  pub const VT_ENTRYPOINT: flatbuffers::VOffsetT = 12;
  pub const VT_LIBRARY: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProgCode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProgCodeArgs<'args>
  ) -> flatbuffers::WIPOffset<ProgCode<'bldr>> {
    let mut builder = ProgCodeBuilder::new(_fbb);
    if let Some(x) = args.library { builder.add_library(x); }
    if let Some(x) = args.entrypoint { builder.add_entrypoint(x); }
    if let Some(x) = args.revision { builder.add_revision(x); }
    if let Some(x) = args.syntax { builder.add_syntax(x); }
    if let Some(x) = args.encryption { builder.add_encryption(x); }
    if let Some(x) = args.code_file { builder.add_code_file(x); }
    builder.finish()
  }


  #[inline]
  pub fn code_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProgCode::VT_CODE_FILE, None)}
  }
  #[inline]
  pub fn encryption(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProgCode::VT_ENCRYPTION, None)}
  }
  #[inline]
  pub fn syntax(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProgCode::VT_SYNTAX, None)}
  }
  #[inline]
  pub fn revision(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProgCode::VT_REVISION, None)}
  }
  #[inline]
  pub fn entrypoint(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProgCode::VT_ENTRYPOINT, None)}
  }
  #[inline]
  pub fn library(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Library<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Library>>>>(ProgCode::VT_LIBRARY, None)}
  }
}

impl flatbuffers::Verifiable for ProgCode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code_file", Self::VT_CODE_FILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("encryption", Self::VT_ENCRYPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("syntax", Self::VT_SYNTAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("revision", Self::VT_REVISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entrypoint", Self::VT_ENTRYPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Library>>>>("library", Self::VT_LIBRARY, false)?
     .finish();
    Ok(())
  }
}
pub struct ProgCodeArgs<'a> {
    pub code_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encryption: Option<flatbuffers::WIPOffset<&'a str>>,
    pub syntax: Option<flatbuffers::WIPOffset<&'a str>>,
    pub revision: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entrypoint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub library: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Library<'a>>>>>,
}
impl<'a> Default for ProgCodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProgCodeArgs {
      code_file: None,
      encryption: None,
      syntax: None,
      revision: None,
      entrypoint: None,
      library: None,
    }
  }
}

pub struct ProgCodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProgCodeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code_file(&mut self, code_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_CODE_FILE, code_file);
  }
  #[inline]
  pub fn add_encryption(&mut self, encryption: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_ENCRYPTION, encryption);
  }
  #[inline]
  pub fn add_syntax(&mut self, syntax: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_SYNTAX, syntax);
  }
  #[inline]
  pub fn add_revision(&mut self, revision: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_REVISION, revision);
  }
  #[inline]
  pub fn add_entrypoint(&mut self, entrypoint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_ENTRYPOINT, entrypoint);
  }
  #[inline]
  pub fn add_library(&mut self, library: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Library<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProgCode::VT_LIBRARY, library);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProgCodeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProgCodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProgCode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProgCode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProgCode");
      ds.field("code_file", &self.code_file());
      ds.field("encryption", &self.encryption());
      ds.field("syntax", &self.syntax());
      ds.field("revision", &self.revision());
      ds.field("entrypoint", &self.entrypoint());
      ds.field("library", &self.library());
      ds.finish()
  }
}
pub enum JobParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct JobParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for JobParam<'a> {
  type Inner = JobParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> JobParam<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PHYSICAL_DEFAULT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_DOP_BASE: flatbuffers::VOffsetT = 10;
  pub const VT_SEMANTIC: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    JobParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args JobParamArgs<'args>
  ) -> flatbuffers::WIPOffset<JobParam<'bldr>> {
    let mut builder = JobParamBuilder::new(_fbb);
    if let Some(x) = args.semantic { builder.add_semantic(x); }
    if let Some(x) = args.dop_base { builder.add_dop_base(x); }
    if let Some(x) = args.physical_default_value { builder.add_physical_default_value(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JobParam::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(JobParam::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn physical_default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JobParam::VT_PHYSICAL_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn dop_base(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(JobParam::VT_DOP_BASE, None)}
  }
  #[inline]
  pub fn semantic(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JobParam::VT_SEMANTIC, None)}
  }
}

impl flatbuffers::Verifiable for JobParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("physical_default_value", Self::VT_PHYSICAL_DEFAULT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop_base", Self::VT_DOP_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("semantic", Self::VT_SEMANTIC, false)?
     .finish();
    Ok(())
  }
}
pub struct JobParamArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub physical_default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dop_base: Option<flatbuffers::WIPOffset<DOP<'a>>>,
    pub semantic: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for JobParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    JobParamArgs {
      short_name: None,
      long_name: None,
      physical_default_value: None,
      dop_base: None,
      semantic: None,
    }
  }
}

pub struct JobParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> JobParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JobParam::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(JobParam::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_physical_default_value(&mut self, physical_default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JobParam::VT_PHYSICAL_DEFAULT_VALUE, physical_default_value);
  }
  #[inline]
  pub fn add_dop_base(&mut self, dop_base: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(JobParam::VT_DOP_BASE, dop_base);
  }
  #[inline]
  pub fn add_semantic(&mut self, semantic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JobParam::VT_SEMANTIC, semantic);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> JobParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    JobParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<JobParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for JobParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("JobParam");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("physical_default_value", &self.physical_default_value());
      ds.field("dop_base", &self.dop_base());
      ds.field("semantic", &self.semantic());
      ds.finish()
  }
}
pub enum SingleEcuJobOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SingleEcuJob<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SingleEcuJob<'a> {
  type Inner = SingleEcuJob<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SingleEcuJob<'a> {
  pub const VT_DIAG_COMM: flatbuffers::VOffsetT = 4;
  pub const VT_PROG_CODES: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_PARAMS: flatbuffers::VOffsetT = 8;
  pub const VT_OUTPUT_PARAMS: flatbuffers::VOffsetT = 10;
  pub const VT_NEG_OUTPUT_PARAMS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SingleEcuJob { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SingleEcuJobArgs<'args>
  ) -> flatbuffers::WIPOffset<SingleEcuJob<'bldr>> {
    let mut builder = SingleEcuJobBuilder::new(_fbb);
    if let Some(x) = args.neg_output_params { builder.add_neg_output_params(x); }
    if let Some(x) = args.output_params { builder.add_output_params(x); }
    if let Some(x) = args.input_params { builder.add_input_params(x); }
    if let Some(x) = args.prog_codes { builder.add_prog_codes(x); }
    if let Some(x) = args.diag_comm { builder.add_diag_comm(x); }
    builder.finish()
  }


  #[inline]
  pub fn diag_comm(&self) -> Option<DiagComm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagComm>>(SingleEcuJob::VT_DIAG_COMM, None)}
  }
  #[inline]
  pub fn prog_codes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProgCode<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProgCode>>>>(SingleEcuJob::VT_PROG_CODES, None)}
  }
  #[inline]
  pub fn input_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam>>>>(SingleEcuJob::VT_INPUT_PARAMS, None)}
  }
  #[inline]
  pub fn output_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam>>>>(SingleEcuJob::VT_OUTPUT_PARAMS, None)}
  }
  #[inline]
  pub fn neg_output_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam>>>>(SingleEcuJob::VT_NEG_OUTPUT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for SingleEcuJob<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagComm>>("diag_comm", Self::VT_DIAG_COMM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProgCode>>>>("prog_codes", Self::VT_PROG_CODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<JobParam>>>>("input_params", Self::VT_INPUT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<JobParam>>>>("output_params", Self::VT_OUTPUT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<JobParam>>>>("neg_output_params", Self::VT_NEG_OUTPUT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SingleEcuJobArgs<'a> {
    pub diag_comm: Option<flatbuffers::WIPOffset<DiagComm<'a>>>,
    pub prog_codes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProgCode<'a>>>>>,
    pub input_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>>>,
    pub output_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>>>,
    pub neg_output_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JobParam<'a>>>>>,
}
impl<'a> Default for SingleEcuJobArgs<'a> {
  #[inline]
  fn default() -> Self {
    SingleEcuJobArgs {
      diag_comm: None,
      prog_codes: None,
      input_params: None,
      output_params: None,
      neg_output_params: None,
    }
  }
}

pub struct SingleEcuJobBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SingleEcuJobBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_comm(&mut self, diag_comm: flatbuffers::WIPOffset<DiagComm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagComm>>(SingleEcuJob::VT_DIAG_COMM, diag_comm);
  }
  #[inline]
  pub fn add_prog_codes(&mut self, prog_codes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProgCode<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SingleEcuJob::VT_PROG_CODES, prog_codes);
  }
  #[inline]
  pub fn add_input_params(&mut self, input_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<JobParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SingleEcuJob::VT_INPUT_PARAMS, input_params);
  }
  #[inline]
  pub fn add_output_params(&mut self, output_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<JobParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SingleEcuJob::VT_OUTPUT_PARAMS, output_params);
  }
  #[inline]
  pub fn add_neg_output_params(&mut self, neg_output_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<JobParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SingleEcuJob::VT_NEG_OUTPUT_PARAMS, neg_output_params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SingleEcuJobBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SingleEcuJobBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SingleEcuJob<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SingleEcuJob<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SingleEcuJob");
      ds.field("diag_comm", &self.diag_comm());
      ds.field("prog_codes", &self.prog_codes());
      ds.field("input_params", &self.input_params());
      ds.field("output_params", &self.output_params());
      ds.field("neg_output_params", &self.neg_output_params());
      ds.finish()
  }
}
pub enum MatchingParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchingParameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchingParameter<'a> {
  type Inner = MatchingParameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> MatchingParameter<'a> {
  pub const VT_EXPECTED_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DIAG_SERVICE: flatbuffers::VOffsetT = 6;
  pub const VT_OUT_PARAM: flatbuffers::VOffsetT = 8;
  pub const VT_USE_PHYSICAL_ADDRESSING: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchingParameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchingParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchingParameter<'bldr>> {
    let mut builder = MatchingParameterBuilder::new(_fbb);
    if let Some(x) = args.out_param { builder.add_out_param(x); }
    if let Some(x) = args.diag_service { builder.add_diag_service(x); }
    if let Some(x) = args.expected_value { builder.add_expected_value(x); }
    if let Some(x) = args.use_physical_addressing { builder.add_use_physical_addressing(x); }
    builder.finish()
  }


  #[inline]
  pub fn expected_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MatchingParameter::VT_EXPECTED_VALUE, None)}
  }
  #[inline]
  pub fn diag_service(&self) -> Option<DiagService<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagService>>(MatchingParameter::VT_DIAG_SERVICE, None)}
  }
  #[inline]
  pub fn out_param(&self) -> Option<Param<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Param>>(MatchingParameter::VT_OUT_PARAM, None)}
  }
  #[inline]
  pub fn use_physical_addressing(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchingParameter::VT_USE_PHYSICAL_ADDRESSING, None)}
  }
}

impl flatbuffers::Verifiable for MatchingParameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expected_value", Self::VT_EXPECTED_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagService>>("diag_service", Self::VT_DIAG_SERVICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Param>>("out_param", Self::VT_OUT_PARAM, false)?
     .visit_field::<bool>("use_physical_addressing", Self::VT_USE_PHYSICAL_ADDRESSING, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchingParameterArgs<'a> {
    pub expected_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diag_service: Option<flatbuffers::WIPOffset<DiagService<'a>>>,
    pub out_param: Option<flatbuffers::WIPOffset<Param<'a>>>,
    pub use_physical_addressing: Option<bool>,
}
impl<'a> Default for MatchingParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchingParameterArgs {
      expected_value: None,
      diag_service: None,
      out_param: None,
      use_physical_addressing: None,
    }
  }
}

pub struct MatchingParameterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchingParameterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_expected_value(&mut self, expected_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchingParameter::VT_EXPECTED_VALUE, expected_value);
  }
  #[inline]
  pub fn add_diag_service(&mut self, diag_service: flatbuffers::WIPOffset<DiagService<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagService>>(MatchingParameter::VT_DIAG_SERVICE, diag_service);
  }
  #[inline]
  pub fn add_out_param(&mut self, out_param: flatbuffers::WIPOffset<Param<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Param>>(MatchingParameter::VT_OUT_PARAM, out_param);
  }
  #[inline]
  pub fn add_use_physical_addressing(&mut self, use_physical_addressing: bool) {
    self.fbb_.push_slot_always::<bool>(MatchingParameter::VT_USE_PHYSICAL_ADDRESSING, use_physical_addressing);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchingParameterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchingParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchingParameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchingParameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchingParameter");
      ds.field("expected_value", &self.expected_value());
      ds.field("diag_service", &self.diag_service());
      ds.field("out_param", &self.out_param());
      ds.field("use_physical_addressing", &self.use_physical_addressing());
      ds.finish()
  }
}
pub enum VariantPatternOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VariantPattern<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariantPattern<'a> {
  type Inner = VariantPattern<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> VariantPattern<'a> {
  pub const VT_MATCHING_PARAMETER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VariantPattern { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VariantPatternArgs<'args>
  ) -> flatbuffers::WIPOffset<VariantPattern<'bldr>> {
    let mut builder = VariantPatternBuilder::new(_fbb);
    if let Some(x) = args.matching_parameter { builder.add_matching_parameter(x); }
    builder.finish()
  }


  #[inline]
  pub fn matching_parameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingParameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingParameter>>>>(VariantPattern::VT_MATCHING_PARAMETER, None)}
  }
}

impl flatbuffers::Verifiable for VariantPattern<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MatchingParameter>>>>("matching_parameter", Self::VT_MATCHING_PARAMETER, false)?
     .finish();
    Ok(())
  }
}
pub struct VariantPatternArgs<'a> {
    pub matching_parameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MatchingParameter<'a>>>>>,
}
impl<'a> Default for VariantPatternArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariantPatternArgs {
      matching_parameter: None,
    }
  }
}

pub struct VariantPatternBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VariantPatternBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_matching_parameter(&mut self, matching_parameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MatchingParameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariantPattern::VT_MATCHING_PARAMETER, matching_parameter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VariantPatternBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VariantPatternBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariantPattern<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VariantPattern<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VariantPattern");
      ds.field("matching_parameter", &self.matching_parameter());
      ds.finish()
  }
}
pub enum DiagLayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DiagLayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DiagLayer<'a> {
  type Inner = DiagLayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DiagLayer<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_FUNCT_CLASSES: flatbuffers::VOffsetT = 8;
  pub const VT_COM_PARAM_REFS: flatbuffers::VOffsetT = 10;
  pub const VT_DIAG_SERVICES: flatbuffers::VOffsetT = 12;
  pub const VT_SINGLE_ECU_JOBS: flatbuffers::VOffsetT = 14;
  pub const VT_STATE_CHARTS: flatbuffers::VOffsetT = 16;
  pub const VT_ADDITIONAL_AUDIENCES: flatbuffers::VOffsetT = 18;
  pub const VT_SDGS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DiagLayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DiagLayerArgs<'args>
  ) -> flatbuffers::WIPOffset<DiagLayer<'bldr>> {
    let mut builder = DiagLayerBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.additional_audiences { builder.add_additional_audiences(x); }
    if let Some(x) = args.state_charts { builder.add_state_charts(x); }
    if let Some(x) = args.single_ecu_jobs { builder.add_single_ecu_jobs(x); }
    if let Some(x) = args.diag_services { builder.add_diag_services(x); }
    if let Some(x) = args.com_param_refs { builder.add_com_param_refs(x); }
    if let Some(x) = args.funct_classes { builder.add_funct_classes(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DiagLayer::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(DiagLayer::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn funct_classes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass>>>>(DiagLayer::VT_FUNCT_CLASSES, None)}
  }
  #[inline]
  pub fn com_param_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef>>>>(DiagLayer::VT_COM_PARAM_REFS, None)}
  }
  #[inline]
  pub fn diag_services(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DiagService<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DiagService>>>>(DiagLayer::VT_DIAG_SERVICES, None)}
  }
  #[inline]
  pub fn single_ecu_jobs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SingleEcuJob<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SingleEcuJob>>>>(DiagLayer::VT_SINGLE_ECU_JOBS, None)}
  }
  #[inline]
  pub fn state_charts(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateChart<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateChart>>>>(DiagLayer::VT_STATE_CHARTS, None)}
  }
  #[inline]
  pub fn additional_audiences(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>(DiagLayer::VT_ADDITIONAL_AUDIENCES, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(DiagLayer::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for DiagLayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctClass>>>>("funct_classes", Self::VT_FUNCT_CLASSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParamRef>>>>("com_param_refs", Self::VT_COM_PARAM_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DiagService>>>>("diag_services", Self::VT_DIAG_SERVICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SingleEcuJob>>>>("single_ecu_jobs", Self::VT_SINGLE_ECU_JOBS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StateChart>>>>("state_charts", Self::VT_STATE_CHARTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AdditionalAudience>>>>("additional_audiences", Self::VT_ADDITIONAL_AUDIENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct DiagLayerArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub funct_classes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctClass<'a>>>>>,
    pub com_param_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamRef<'a>>>>>,
    pub diag_services: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DiagService<'a>>>>>,
    pub single_ecu_jobs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SingleEcuJob<'a>>>>>,
    pub state_charts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StateChart<'a>>>>>,
    pub additional_audiences: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AdditionalAudience<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
}
impl<'a> Default for DiagLayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    DiagLayerArgs {
      short_name: None,
      long_name: None,
      funct_classes: None,
      com_param_refs: None,
      diag_services: None,
      single_ecu_jobs: None,
      state_charts: None,
      additional_audiences: None,
      sdgs: None,
    }
  }
}

pub struct DiagLayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiagLayerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(DiagLayer::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_funct_classes(&mut self, funct_classes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctClass<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_FUNCT_CLASSES, funct_classes);
  }
  #[inline]
  pub fn add_com_param_refs(&mut self, com_param_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParamRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_COM_PARAM_REFS, com_param_refs);
  }
  #[inline]
  pub fn add_diag_services(&mut self, diag_services: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DiagService<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_DIAG_SERVICES, diag_services);
  }
  #[inline]
  pub fn add_single_ecu_jobs(&mut self, single_ecu_jobs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SingleEcuJob<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_SINGLE_ECU_JOBS, single_ecu_jobs);
  }
  #[inline]
  pub fn add_state_charts(&mut self, state_charts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StateChart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_STATE_CHARTS, state_charts);
  }
  #[inline]
  pub fn add_additional_audiences(&mut self, additional_audiences: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AdditionalAudience<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DiagLayer::VT_ADDITIONAL_AUDIENCES, additional_audiences);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(DiagLayer::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DiagLayerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DiagLayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DiagLayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DiagLayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DiagLayer");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("funct_classes", &self.funct_classes());
      ds.field("com_param_refs", &self.com_param_refs());
      ds.field("diag_services", &self.diag_services());
      ds.field("single_ecu_jobs", &self.single_ecu_jobs());
      ds.field("state_charts", &self.state_charts());
      ds.field("additional_audiences", &self.additional_audiences());
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum FunctionalGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FunctionalGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FunctionalGroup<'a> {
  type Inner = FunctionalGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> FunctionalGroup<'a> {
  pub const VT_DIAG_LAYER: flatbuffers::VOffsetT = 4;
  pub const VT_PARENT_REFS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FunctionalGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FunctionalGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<FunctionalGroup<'bldr>> {
    let mut builder = FunctionalGroupBuilder::new(_fbb);
    if let Some(x) = args.parent_refs { builder.add_parent_refs(x); }
    if let Some(x) = args.diag_layer { builder.add_diag_layer(x); }
    builder.finish()
  }


  #[inline]
  pub fn diag_layer(&self) -> Option<DiagLayer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagLayer>>(FunctionalGroup::VT_DIAG_LAYER, None)}
  }
  #[inline]
  pub fn parent_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef>>>>(FunctionalGroup::VT_PARENT_REFS, None)}
  }
}

impl flatbuffers::Verifiable for FunctionalGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagLayer>>("diag_layer", Self::VT_DIAG_LAYER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ParentRef>>>>("parent_refs", Self::VT_PARENT_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct FunctionalGroupArgs<'a> {
    pub diag_layer: Option<flatbuffers::WIPOffset<DiagLayer<'a>>>,
    pub parent_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef<'a>>>>>,
}
impl<'a> Default for FunctionalGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctionalGroupArgs {
      diag_layer: None,
      parent_refs: None,
    }
  }
}

pub struct FunctionalGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FunctionalGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_layer(&mut self, diag_layer: flatbuffers::WIPOffset<DiagLayer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagLayer>>(FunctionalGroup::VT_DIAG_LAYER, diag_layer);
  }
  #[inline]
  pub fn add_parent_refs(&mut self, parent_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ParentRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionalGroup::VT_PARENT_REFS, parent_refs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FunctionalGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FunctionalGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FunctionalGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FunctionalGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FunctionalGroup");
      ds.field("diag_layer", &self.diag_layer());
      ds.field("parent_refs", &self.parent_refs());
      ds.finish()
  }
}
pub enum ParentRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParentRef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParentRef<'a> {
  type Inner = ParentRef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ParentRef<'a> {
  pub const VT_REF_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_REF_: flatbuffers::VOffsetT = 6;
  pub const VT_NOT_INHERITED_DIAG_COMM_SHORT_NAMES: flatbuffers::VOffsetT = 8;
  pub const VT_NOT_INHERITED_VARIABLES_SHORT_NAMES: flatbuffers::VOffsetT = 10;
  pub const VT_NOT_INHERITED_DOPS_SHORT_NAMES: flatbuffers::VOffsetT = 12;
  pub const VT_NOT_INHERITED_TABLES_SHORT_NAMES: flatbuffers::VOffsetT = 14;
  pub const VT_NOT_INHERITED_GLOBAL_NEG_RESPONSES_SHORT_NAMES: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParentRef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParentRefArgs<'args>
  ) -> flatbuffers::WIPOffset<ParentRef<'bldr>> {
    let mut builder = ParentRefBuilder::new(_fbb);
    if let Some(x) = args.not_inherited_global_neg_responses_short_names { builder.add_not_inherited_global_neg_responses_short_names(x); }
    if let Some(x) = args.not_inherited_tables_short_names { builder.add_not_inherited_tables_short_names(x); }
    if let Some(x) = args.not_inherited_dops_short_names { builder.add_not_inherited_dops_short_names(x); }
    if let Some(x) = args.not_inherited_variables_short_names { builder.add_not_inherited_variables_short_names(x); }
    if let Some(x) = args.not_inherited_diag_comm_short_names { builder.add_not_inherited_diag_comm_short_names(x); }
    if let Some(x) = args.ref_ { builder.add_ref_(x); }
    builder.add_ref_type(args.ref_type);
    builder.finish()
  }


  #[inline]
  pub fn ref_type(&self) -> ParentRefType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParentRefType>(ParentRef::VT_REF_TYPE, Some(ParentRefType::NONE)).unwrap()}
  }
  #[inline]
  pub fn ref_(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ParentRef::VT_REF_, None)}
  }
  #[inline]
  pub fn not_inherited_diag_comm_short_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParentRef::VT_NOT_INHERITED_DIAG_COMM_SHORT_NAMES, None)}
  }
  #[inline]
  pub fn not_inherited_variables_short_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParentRef::VT_NOT_INHERITED_VARIABLES_SHORT_NAMES, None)}
  }
  #[inline]
  pub fn not_inherited_dops_short_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParentRef::VT_NOT_INHERITED_DOPS_SHORT_NAMES, None)}
  }
  #[inline]
  pub fn not_inherited_tables_short_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParentRef::VT_NOT_INHERITED_TABLES_SHORT_NAMES, None)}
  }
  #[inline]
  pub fn not_inherited_global_neg_responses_short_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ParentRef::VT_NOT_INHERITED_GLOBAL_NEG_RESPONSES_SHORT_NAMES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn ref__as_variant(&self) -> Option<Variant<'a>> {
    if self.ref_type() == ParentRefType::Variant {
      self.ref_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Variant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ref__as_protocol(&self) -> Option<Protocol<'a>> {
    if self.ref_type() == ParentRefType::Protocol {
      self.ref_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Protocol::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ref__as_functional_group(&self) -> Option<FunctionalGroup<'a>> {
    if self.ref_type() == ParentRefType::FunctionalGroup {
      self.ref_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FunctionalGroup::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ref__as_table_dop(&self) -> Option<TableDop<'a>> {
    if self.ref_type() == ParentRefType::TableDop {
      self.ref_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TableDop::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ref__as_ecu_shared_data(&self) -> Option<EcuSharedData<'a>> {
    if self.ref_type() == ParentRefType::EcuSharedData {
      self.ref_().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EcuSharedData::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ParentRef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<ParentRefTypeUnionValue>("ref_type", Self::VT_REF_TYPE, "ref_", Self::VT_REF_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("not_inherited_diag_comm_short_names", Self::VT_NOT_INHERITED_DIAG_COMM_SHORT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("not_inherited_variables_short_names", Self::VT_NOT_INHERITED_VARIABLES_SHORT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("not_inherited_dops_short_names", Self::VT_NOT_INHERITED_DOPS_SHORT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("not_inherited_tables_short_names", Self::VT_NOT_INHERITED_TABLES_SHORT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("not_inherited_global_neg_responses_short_names", Self::VT_NOT_INHERITED_GLOBAL_NEG_RESPONSES_SHORT_NAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct ParentRefArgs<'a> {
    pub ref_type: ParentRefType,
    pub ref_: Option<flatbuffers::WIPOffset<ParentRefTypeUnionValue>>,
    pub not_inherited_diag_comm_short_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub not_inherited_variables_short_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub not_inherited_dops_short_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub not_inherited_tables_short_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub not_inherited_global_neg_responses_short_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ParentRefArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParentRefArgs {
      ref_type: ParentRefType::NONE,
      ref_: None,
      not_inherited_diag_comm_short_names: None,
      not_inherited_variables_short_names: None,
      not_inherited_dops_short_names: None,
      not_inherited_tables_short_names: None,
      not_inherited_global_neg_responses_short_names: None,
    }
  }
}

pub struct ParentRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParentRefBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ref_type(&mut self, ref_type: ParentRefType) {
    self.fbb_.push_slot::<ParentRefType>(ParentRef::VT_REF_TYPE, ref_type, ParentRefType::NONE);
  }
  #[inline]
  pub fn add_ref_(&mut self, ref_: flatbuffers::WIPOffset<ParentRefTypeUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_REF_, ref_);
  }
  #[inline]
  pub fn add_not_inherited_diag_comm_short_names(&mut self, not_inherited_diag_comm_short_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_NOT_INHERITED_DIAG_COMM_SHORT_NAMES, not_inherited_diag_comm_short_names);
  }
  #[inline]
  pub fn add_not_inherited_variables_short_names(&mut self, not_inherited_variables_short_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_NOT_INHERITED_VARIABLES_SHORT_NAMES, not_inherited_variables_short_names);
  }
  #[inline]
  pub fn add_not_inherited_dops_short_names(&mut self, not_inherited_dops_short_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_NOT_INHERITED_DOPS_SHORT_NAMES, not_inherited_dops_short_names);
  }
  #[inline]
  pub fn add_not_inherited_tables_short_names(&mut self, not_inherited_tables_short_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_NOT_INHERITED_TABLES_SHORT_NAMES, not_inherited_tables_short_names);
  }
  #[inline]
  pub fn add_not_inherited_global_neg_responses_short_names(&mut self, not_inherited_global_neg_responses_short_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParentRef::VT_NOT_INHERITED_GLOBAL_NEG_RESPONSES_SHORT_NAMES, not_inherited_global_neg_responses_short_names);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParentRefBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParentRefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParentRef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParentRef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParentRef");
      ds.field("ref_type", &self.ref_type());
      match self.ref_type() {
        ParentRefType::Variant => {
          if let Some(x) = self.ref__as_variant() {
            ds.field("ref_", &x)
          } else {
            ds.field("ref_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParentRefType::Protocol => {
          if let Some(x) = self.ref__as_protocol() {
            ds.field("ref_", &x)
          } else {
            ds.field("ref_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParentRefType::FunctionalGroup => {
          if let Some(x) = self.ref__as_functional_group() {
            ds.field("ref_", &x)
          } else {
            ds.field("ref_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParentRefType::TableDop => {
          if let Some(x) = self.ref__as_table_dop() {
            ds.field("ref_", &x)
          } else {
            ds.field("ref_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ParentRefType::EcuSharedData => {
          if let Some(x) = self.ref__as_ecu_shared_data() {
            ds.field("ref_", &x)
          } else {
            ds.field("ref_", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("ref_", &x)
        },
      };
      ds.field("not_inherited_diag_comm_short_names", &self.not_inherited_diag_comm_short_names());
      ds.field("not_inherited_variables_short_names", &self.not_inherited_variables_short_names());
      ds.field("not_inherited_dops_short_names", &self.not_inherited_dops_short_names());
      ds.field("not_inherited_tables_short_names", &self.not_inherited_tables_short_names());
      ds.field("not_inherited_global_neg_responses_short_names", &self.not_inherited_global_neg_responses_short_names());
      ds.finish()
  }
}
pub enum EcuSharedDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EcuSharedData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EcuSharedData<'a> {
  type Inner = EcuSharedData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> EcuSharedData<'a> {
  pub const VT_DIAG_LAYER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EcuSharedData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EcuSharedDataArgs<'args>
  ) -> flatbuffers::WIPOffset<EcuSharedData<'bldr>> {
    let mut builder = EcuSharedDataBuilder::new(_fbb);
    if let Some(x) = args.diag_layer { builder.add_diag_layer(x); }
    builder.finish()
  }


  #[inline]
  pub fn diag_layer(&self) -> Option<DiagLayer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagLayer>>(EcuSharedData::VT_DIAG_LAYER, None)}
  }
}

impl flatbuffers::Verifiable for EcuSharedData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagLayer>>("diag_layer", Self::VT_DIAG_LAYER, false)?
     .finish();
    Ok(())
  }
}
pub struct EcuSharedDataArgs<'a> {
    pub diag_layer: Option<flatbuffers::WIPOffset<DiagLayer<'a>>>,
}
impl<'a> Default for EcuSharedDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    EcuSharedDataArgs {
      diag_layer: None,
    }
  }
}

pub struct EcuSharedDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EcuSharedDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_layer(&mut self, diag_layer: flatbuffers::WIPOffset<DiagLayer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagLayer>>(EcuSharedData::VT_DIAG_LAYER, diag_layer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EcuSharedDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EcuSharedDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EcuSharedData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EcuSharedData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EcuSharedData");
      ds.field("diag_layer", &self.diag_layer());
      ds.finish()
  }
}
pub enum VariantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Variant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Variant<'a> {
  type Inner = Variant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Variant<'a> {
  pub const VT_DIAG_LAYER: flatbuffers::VOffsetT = 4;
  pub const VT_IS_BASE_VARIANT: flatbuffers::VOffsetT = 6;
  pub const VT_VARIANT_PATTERN: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT_REFS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Variant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VariantArgs<'args>
  ) -> flatbuffers::WIPOffset<Variant<'bldr>> {
    let mut builder = VariantBuilder::new(_fbb);
    if let Some(x) = args.parent_refs { builder.add_parent_refs(x); }
    if let Some(x) = args.variant_pattern { builder.add_variant_pattern(x); }
    if let Some(x) = args.diag_layer { builder.add_diag_layer(x); }
    builder.add_is_base_variant(args.is_base_variant);
    builder.finish()
  }


  #[inline]
  pub fn diag_layer(&self) -> Option<DiagLayer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagLayer>>(Variant::VT_DIAG_LAYER, None)}
  }
  #[inline]
  pub fn is_base_variant(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Variant::VT_IS_BASE_VARIANT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn variant_pattern(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantPattern<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantPattern>>>>(Variant::VT_VARIANT_PATTERN, None)}
  }
  #[inline]
  pub fn parent_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef>>>>(Variant::VT_PARENT_REFS, None)}
  }
}

impl flatbuffers::Verifiable for Variant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagLayer>>("diag_layer", Self::VT_DIAG_LAYER, false)?
     .visit_field::<bool>("is_base_variant", Self::VT_IS_BASE_VARIANT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VariantPattern>>>>("variant_pattern", Self::VT_VARIANT_PATTERN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ParentRef>>>>("parent_refs", Self::VT_PARENT_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct VariantArgs<'a> {
    pub diag_layer: Option<flatbuffers::WIPOffset<DiagLayer<'a>>>,
    pub is_base_variant: bool,
    pub variant_pattern: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantPattern<'a>>>>>,
    pub parent_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParentRef<'a>>>>>,
}
impl<'a> Default for VariantArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariantArgs {
      diag_layer: None,
      is_base_variant: false,
      variant_pattern: None,
      parent_refs: None,
    }
  }
}

pub struct VariantBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VariantBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_layer(&mut self, diag_layer: flatbuffers::WIPOffset<DiagLayer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagLayer>>(Variant::VT_DIAG_LAYER, diag_layer);
  }
  #[inline]
  pub fn add_is_base_variant(&mut self, is_base_variant: bool) {
    self.fbb_.push_slot::<bool>(Variant::VT_IS_BASE_VARIANT, is_base_variant, false);
  }
  #[inline]
  pub fn add_variant_pattern(&mut self, variant_pattern: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VariantPattern<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variant::VT_VARIANT_PATTERN, variant_pattern);
  }
  #[inline]
  pub fn add_parent_refs(&mut self, parent_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ParentRef<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Variant::VT_PARENT_REFS, parent_refs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VariantBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VariantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Variant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Variant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Variant");
      ds.field("diag_layer", &self.diag_layer());
      ds.field("is_base_variant", &self.is_base_variant());
      ds.field("variant_pattern", &self.variant_pattern());
      ds.field("parent_refs", &self.parent_refs());
      ds.finish()
  }
}
pub enum SimpleValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimpleValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimpleValue<'a> {
  type Inner = SimpleValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SimpleValue<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimpleValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimpleValueArgs<'args>
  ) -> flatbuffers::WIPOffset<SimpleValue<'bldr>> {
    let mut builder = SimpleValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SimpleValue::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for SimpleValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct SimpleValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SimpleValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    SimpleValueArgs {
      value: None,
    }
  }
}

pub struct SimpleValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimpleValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SimpleValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimpleValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimpleValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimpleValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimpleValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimpleValue");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ComplexValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComplexValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComplexValue<'a> {
  type Inner = ComplexValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComplexValue<'a> {
  pub const VT_ENTRIES_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComplexValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComplexValueArgs<'args>
  ) -> flatbuffers::WIPOffset<ComplexValue<'bldr>> {
    let mut builder = ComplexValueBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    if let Some(x) = args.entries_type { builder.add_entries_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries_type(&self) -> Option<flatbuffers::Vector<'a, SimpleOrComplexValueEntry>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, SimpleOrComplexValueEntry>>>(ComplexValue::VT_ENTRIES_TYPE, None)}
  }
  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>>>(ComplexValue::VT_ENTRIES, None)}
  }
    #[inline]
    #[allow(non_snake_case)]
    pub fn entries_item_as_simple_value(&self, idx: usize) -> Option<SimpleValue<'a>> {
      if let Some(tags) = self.entries_type() {
        if let Some(tables) = self.entries() {
          if let Some((tag, table)) = tags.iter().zip(tables.iter()).nth(idx) {
            if tag == SimpleOrComplexValueEntry::SimpleValue {
              return Some(unsafe { <SimpleValue>::init_from_table(table) });
            }
          }
        }
      }
      None
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn entries_item_as_complex_value(&self, idx: usize) -> Option<ComplexValue<'a>> {
      if let Some(tags) = self.entries_type() {
        if let Some(tables) = self.entries() {
          if let Some((tag, table)) = tags.iter().zip(tables.iter()).nth(idx) {
            if tag == SimpleOrComplexValueEntry::ComplexValue {
              return Some(unsafe { <ComplexValue>::init_from_table(table) });
            }
          }
        }
      }
      None
    }

}

impl flatbuffers::Verifiable for ComplexValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union_vector::<SimpleOrComplexValueEntryUnionValue>("entries_type", Self::VT_ENTRIES_TYPE, "entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct ComplexValueArgs<'a> {
    pub entries_type: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, SimpleOrComplexValueEntry>>>,
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SimpleOrComplexValueEntryUnionValue>>>>,
}
impl<'a> Default for ComplexValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComplexValueArgs {
      entries_type: None,
      entries: None,
    }
  }
}

pub struct ComplexValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComplexValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries_type(&mut self, entries_type: flatbuffers::WIPOffset<flatbuffers::Vector<'b , SimpleOrComplexValueEntry>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComplexValue::VT_ENTRIES_TYPE, entries_type);
  }
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SimpleOrComplexValueEntryUnionValue>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComplexValue::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComplexValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComplexValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComplexValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComplexValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComplexValue");
      ds.field("entries_type", &self.entries_type());
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum ProtocolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Protocol<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Protocol<'a> {
  type Inner = Protocol<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Protocol<'a> {
  pub const VT_DIAG_LAYER: flatbuffers::VOffsetT = 4;
  pub const VT_COM_PARAM_SPEC: flatbuffers::VOffsetT = 6;
  pub const VT_PROT_STACK: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT_REFS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Protocol { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProtocolArgs<'args>
  ) -> flatbuffers::WIPOffset<Protocol<'bldr>> {
    let mut builder = ProtocolBuilder::new(_fbb);
    if let Some(x) = args.parent_refs { builder.add_parent_refs(x); }
    if let Some(x) = args.prot_stack { builder.add_prot_stack(x); }
    if let Some(x) = args.com_param_spec { builder.add_com_param_spec(x); }
    if let Some(x) = args.diag_layer { builder.add_diag_layer(x); }
    builder.finish()
  }


  #[inline]
  pub fn diag_layer(&self) -> Option<DiagLayer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DiagLayer>>(Protocol::VT_DIAG_LAYER, None)}
  }
  #[inline]
  pub fn com_param_spec(&self) -> Option<ComParamSpec<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ComParamSpec>>(Protocol::VT_COM_PARAM_SPEC, None)}
  }
  #[inline]
  pub fn prot_stack(&self) -> Option<ProtStack<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProtStack>>(Protocol::VT_PROT_STACK, None)}
  }
  #[inline]
  pub fn parent_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol>>>>(Protocol::VT_PARENT_REFS, None)}
  }
}

impl flatbuffers::Verifiable for Protocol<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DiagLayer>>("diag_layer", Self::VT_DIAG_LAYER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ComParamSpec>>("com_param_spec", Self::VT_COM_PARAM_SPEC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProtStack>>("prot_stack", Self::VT_PROT_STACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Protocol>>>>("parent_refs", Self::VT_PARENT_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProtocolArgs<'a> {
    pub diag_layer: Option<flatbuffers::WIPOffset<DiagLayer<'a>>>,
    pub com_param_spec: Option<flatbuffers::WIPOffset<ComParamSpec<'a>>>,
    pub prot_stack: Option<flatbuffers::WIPOffset<ProtStack<'a>>>,
    pub parent_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Protocol<'a>>>>>,
}
impl<'a> Default for ProtocolArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProtocolArgs {
      diag_layer: None,
      com_param_spec: None,
      prot_stack: None,
      parent_refs: None,
    }
  }
}

pub struct ProtocolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProtocolBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_diag_layer(&mut self, diag_layer: flatbuffers::WIPOffset<DiagLayer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DiagLayer>>(Protocol::VT_DIAG_LAYER, diag_layer);
  }
  #[inline]
  pub fn add_com_param_spec(&mut self, com_param_spec: flatbuffers::WIPOffset<ComParamSpec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ComParamSpec>>(Protocol::VT_COM_PARAM_SPEC, com_param_spec);
  }
  #[inline]
  pub fn add_prot_stack(&mut self, prot_stack: flatbuffers::WIPOffset<ProtStack<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProtStack>>(Protocol::VT_PROT_STACK, prot_stack);
  }
  #[inline]
  pub fn add_parent_refs(&mut self, parent_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Protocol<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Protocol::VT_PARENT_REFS, parent_refs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProtocolBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProtocolBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Protocol<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Protocol<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Protocol");
      ds.field("diag_layer", &self.diag_layer());
      ds.field("com_param_spec", &self.com_param_spec());
      ds.field("prot_stack", &self.prot_stack());
      ds.field("parent_refs", &self.parent_refs());
      ds.finish()
  }
}
pub enum ComParamRefOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComParamRef<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComParamRef<'a> {
  type Inner = ComParamRef<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComParamRef<'a> {
  pub const VT_SIMPLE_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_COMPLEX_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_COM_PARAM: flatbuffers::VOffsetT = 8;
  pub const VT_PROTOCOL: flatbuffers::VOffsetT = 10;
  pub const VT_PROT_STACK: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComParamRef { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComParamRefArgs<'args>
  ) -> flatbuffers::WIPOffset<ComParamRef<'bldr>> {
    let mut builder = ComParamRefBuilder::new(_fbb);
    if let Some(x) = args.prot_stack { builder.add_prot_stack(x); }
    if let Some(x) = args.protocol { builder.add_protocol(x); }
    if let Some(x) = args.com_param { builder.add_com_param(x); }
    if let Some(x) = args.complex_value { builder.add_complex_value(x); }
    if let Some(x) = args.simple_value { builder.add_simple_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn simple_value(&self) -> Option<SimpleValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimpleValue>>(ComParamRef::VT_SIMPLE_VALUE, None)}
  }
  #[inline]
  pub fn complex_value(&self) -> Option<ComplexValue<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ComplexValue>>(ComParamRef::VT_COMPLEX_VALUE, None)}
  }
  #[inline]
  pub fn com_param(&self) -> Option<ComParam<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ComParam>>(ComParamRef::VT_COM_PARAM, None)}
  }
  #[inline]
  pub fn protocol(&self) -> Option<Protocol<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Protocol>>(ComParamRef::VT_PROTOCOL, None)}
  }
  #[inline]
  pub fn prot_stack(&self) -> Option<ProtStack<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProtStack>>(ComParamRef::VT_PROT_STACK, None)}
  }
}

impl flatbuffers::Verifiable for ComParamRef<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimpleValue>>("simple_value", Self::VT_SIMPLE_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ComplexValue>>("complex_value", Self::VT_COMPLEX_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ComParam>>("com_param", Self::VT_COM_PARAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Protocol>>("protocol", Self::VT_PROTOCOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProtStack>>("prot_stack", Self::VT_PROT_STACK, false)?
     .finish();
    Ok(())
  }
}
pub struct ComParamRefArgs<'a> {
    pub simple_value: Option<flatbuffers::WIPOffset<SimpleValue<'a>>>,
    pub complex_value: Option<flatbuffers::WIPOffset<ComplexValue<'a>>>,
    pub com_param: Option<flatbuffers::WIPOffset<ComParam<'a>>>,
    pub protocol: Option<flatbuffers::WIPOffset<Protocol<'a>>>,
    pub prot_stack: Option<flatbuffers::WIPOffset<ProtStack<'a>>>,
}
impl<'a> Default for ComParamRefArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComParamRefArgs {
      simple_value: None,
      complex_value: None,
      com_param: None,
      protocol: None,
      prot_stack: None,
    }
  }
}

pub struct ComParamRefBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComParamRefBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_simple_value(&mut self, simple_value: flatbuffers::WIPOffset<SimpleValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimpleValue>>(ComParamRef::VT_SIMPLE_VALUE, simple_value);
  }
  #[inline]
  pub fn add_complex_value(&mut self, complex_value: flatbuffers::WIPOffset<ComplexValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ComplexValue>>(ComParamRef::VT_COMPLEX_VALUE, complex_value);
  }
  #[inline]
  pub fn add_com_param(&mut self, com_param: flatbuffers::WIPOffset<ComParam<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ComParam>>(ComParamRef::VT_COM_PARAM, com_param);
  }
  #[inline]
  pub fn add_protocol(&mut self, protocol: flatbuffers::WIPOffset<Protocol<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Protocol>>(ComParamRef::VT_PROTOCOL, protocol);
  }
  #[inline]
  pub fn add_prot_stack(&mut self, prot_stack: flatbuffers::WIPOffset<ProtStack<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProtStack>>(ComParamRef::VT_PROT_STACK, prot_stack);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComParamRefBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComParamRefBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComParamRef<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComParamRef<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComParamRef");
      ds.field("simple_value", &self.simple_value());
      ds.field("complex_value", &self.complex_value());
      ds.field("com_param", &self.com_param());
      ds.field("protocol", &self.protocol());
      ds.field("prot_stack", &self.prot_stack());
      ds.finish()
  }
}
pub enum RegularComParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RegularComParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RegularComParam<'a> {
  type Inner = RegularComParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> RegularComParam<'a> {
  pub const VT_PHYSICAL_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_DOP: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RegularComParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RegularComParamArgs<'args>
  ) -> flatbuffers::WIPOffset<RegularComParam<'bldr>> {
    let mut builder = RegularComParamBuilder::new(_fbb);
    if let Some(x) = args.dop { builder.add_dop(x); }
    if let Some(x) = args.physical_default_value { builder.add_physical_default_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn physical_default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RegularComParam::VT_PHYSICAL_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn dop(&self) -> Option<DOP<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DOP>>(RegularComParam::VT_DOP, None)}
  }
}

impl flatbuffers::Verifiable for RegularComParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("physical_default_value", Self::VT_PHYSICAL_DEFAULT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DOP>>("dop", Self::VT_DOP, false)?
     .finish();
    Ok(())
  }
}
pub struct RegularComParamArgs<'a> {
    pub physical_default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dop: Option<flatbuffers::WIPOffset<DOP<'a>>>,
}
impl<'a> Default for RegularComParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegularComParamArgs {
      physical_default_value: None,
      dop: None,
    }
  }
}

pub struct RegularComParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RegularComParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_physical_default_value(&mut self, physical_default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RegularComParam::VT_PHYSICAL_DEFAULT_VALUE, physical_default_value);
  }
  #[inline]
  pub fn add_dop(&mut self, dop: flatbuffers::WIPOffset<DOP<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DOP>>(RegularComParam::VT_DOP, dop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RegularComParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RegularComParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RegularComParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RegularComParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RegularComParam");
      ds.field("physical_default_value", &self.physical_default_value());
      ds.field("dop", &self.dop());
      ds.finish()
  }
}
pub enum ComplexComParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComplexComParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComplexComParam<'a> {
  type Inner = ComplexComParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComplexComParam<'a> {
  pub const VT_COM_PARAMS: flatbuffers::VOffsetT = 4;
  pub const VT_COMPLEX_PHYSICAL_DEFAULT_VALUES: flatbuffers::VOffsetT = 6;
  pub const VT_ALLOW_MULTIPLE_VALUES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComplexComParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComplexComParamArgs<'args>
  ) -> flatbuffers::WIPOffset<ComplexComParam<'bldr>> {
    let mut builder = ComplexComParamBuilder::new(_fbb);
    if let Some(x) = args.complex_physical_default_values { builder.add_complex_physical_default_values(x); }
    if let Some(x) = args.com_params { builder.add_com_params(x); }
    builder.add_allow_multiple_values(args.allow_multiple_values);
    builder.finish()
  }


  #[inline]
  pub fn com_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam>>>>(ComplexComParam::VT_COM_PARAMS, None)}
  }
  #[inline]
  pub fn complex_physical_default_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComplexValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComplexValue>>>>(ComplexComParam::VT_COMPLEX_PHYSICAL_DEFAULT_VALUES, None)}
  }
  #[inline]
  pub fn allow_multiple_values(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ComplexComParam::VT_ALLOW_MULTIPLE_VALUES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ComplexComParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParam>>>>("com_params", Self::VT_COM_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComplexValue>>>>("complex_physical_default_values", Self::VT_COMPLEX_PHYSICAL_DEFAULT_VALUES, false)?
     .visit_field::<bool>("allow_multiple_values", Self::VT_ALLOW_MULTIPLE_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct ComplexComParamArgs<'a> {
    pub com_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>>>,
    pub complex_physical_default_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComplexValue<'a>>>>>,
    pub allow_multiple_values: bool,
}
impl<'a> Default for ComplexComParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComplexComParamArgs {
      com_params: None,
      complex_physical_default_values: None,
      allow_multiple_values: false,
    }
  }
}

pub struct ComplexComParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComplexComParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_com_params(&mut self, com_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComplexComParam::VT_COM_PARAMS, com_params);
  }
  #[inline]
  pub fn add_complex_physical_default_values(&mut self, complex_physical_default_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComplexValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComplexComParam::VT_COMPLEX_PHYSICAL_DEFAULT_VALUES, complex_physical_default_values);
  }
  #[inline]
  pub fn add_allow_multiple_values(&mut self, allow_multiple_values: bool) {
    self.fbb_.push_slot::<bool>(ComplexComParam::VT_ALLOW_MULTIPLE_VALUES, allow_multiple_values, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComplexComParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComplexComParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComplexComParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComplexComParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComplexComParam");
      ds.field("com_params", &self.com_params());
      ds.field("complex_physical_default_values", &self.complex_physical_default_values());
      ds.field("allow_multiple_values", &self.allow_multiple_values());
      ds.finish()
  }
}
pub enum ComParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComParam<'a> {
  type Inner = ComParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComParam<'a> {
  pub const VT_COM_PARAM_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_PARAM_CLASS: flatbuffers::VOffsetT = 10;
  pub const VT_CP_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_DISPLAY_LEVEL: flatbuffers::VOffsetT = 14;
  pub const VT_CP_USAGE: flatbuffers::VOffsetT = 16;
  pub const VT_SPECIFIC_DATA_TYPE: flatbuffers::VOffsetT = 18;
  pub const VT_SPECIFIC_DATA: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComParamArgs<'args>
  ) -> flatbuffers::WIPOffset<ComParam<'bldr>> {
    let mut builder = ComParamBuilder::new(_fbb);
    if let Some(x) = args.specific_data { builder.add_specific_data(x); }
    if let Some(x) = args.display_level { builder.add_display_level(x); }
    if let Some(x) = args.param_class { builder.add_param_class(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.add_specific_data_type(args.specific_data_type);
    builder.add_cp_usage(args.cp_usage);
    builder.add_cp_type(args.cp_type);
    builder.add_com_param_type(args.com_param_type);
    builder.finish()
  }


  #[inline]
  pub fn com_param_type(&self) -> ComParamType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComParamType>(ComParam::VT_COM_PARAM_TYPE, Some(ComParamType::REGULAR)).unwrap()}
  }
  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ComParam::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(ComParam::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn param_class(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ComParam::VT_PARAM_CLASS, None)}
  }
  #[inline]
  pub fn cp_type(&self) -> ComParamStandardisationLevel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComParamStandardisationLevel>(ComParam::VT_CP_TYPE, Some(ComParamStandardisationLevel::STANDARD)).unwrap()}
  }
  #[inline]
  pub fn display_level(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ComParam::VT_DISPLAY_LEVEL, None)}
  }
  #[inline]
  pub fn cp_usage(&self) -> ComParamUsage {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComParamUsage>(ComParam::VT_CP_USAGE, Some(ComParamUsage::ECU_SOFTWARE)).unwrap()}
  }
  #[inline]
  pub fn specific_data_type(&self) -> ComParamSpecificData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComParamSpecificData>(ComParam::VT_SPECIFIC_DATA_TYPE, Some(ComParamSpecificData::NONE)).unwrap()}
  }
  #[inline]
  pub fn specific_data(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ComParam::VT_SPECIFIC_DATA, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_regular_com_param(&self) -> Option<RegularComParam<'a>> {
    if self.specific_data_type() == ComParamSpecificData::RegularComParam {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RegularComParam::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn specific_data_as_complex_com_param(&self) -> Option<ComplexComParam<'a>> {
    if self.specific_data_type() == ComParamSpecificData::ComplexComParam {
      self.specific_data().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ComplexComParam::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ComParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ComParamType>("com_param_type", Self::VT_COM_PARAM_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("param_class", Self::VT_PARAM_CLASS, false)?
     .visit_field::<ComParamStandardisationLevel>("cp_type", Self::VT_CP_TYPE, false)?
     .visit_field::<u32>("display_level", Self::VT_DISPLAY_LEVEL, false)?
     .visit_field::<ComParamUsage>("cp_usage", Self::VT_CP_USAGE, false)?
     .visit_union::<ComParamSpecificDataUnionValue>("specific_data_type", Self::VT_SPECIFIC_DATA_TYPE, "specific_data", Self::VT_SPECIFIC_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ComParamArgs<'a> {
    pub com_param_type: ComParamType,
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub param_class: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cp_type: ComParamStandardisationLevel,
    pub display_level: Option<u32>,
    pub cp_usage: ComParamUsage,
    pub specific_data_type: ComParamSpecificData,
    pub specific_data: Option<flatbuffers::WIPOffset<ComParamSpecificDataUnionValue>>,
}
impl<'a> Default for ComParamArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComParamArgs {
      com_param_type: ComParamType::REGULAR,
      short_name: None,
      long_name: None,
      param_class: None,
      cp_type: ComParamStandardisationLevel::STANDARD,
      display_level: None,
      cp_usage: ComParamUsage::ECU_SOFTWARE,
      specific_data_type: ComParamSpecificData::NONE,
      specific_data: None,
    }
  }
}

pub struct ComParamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComParamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_com_param_type(&mut self, com_param_type: ComParamType) {
    self.fbb_.push_slot::<ComParamType>(ComParam::VT_COM_PARAM_TYPE, com_param_type, ComParamType::REGULAR);
  }
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParam::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(ComParam::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_param_class(&mut self, param_class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParam::VT_PARAM_CLASS, param_class);
  }
  #[inline]
  pub fn add_cp_type(&mut self, cp_type: ComParamStandardisationLevel) {
    self.fbb_.push_slot::<ComParamStandardisationLevel>(ComParam::VT_CP_TYPE, cp_type, ComParamStandardisationLevel::STANDARD);
  }
  #[inline]
  pub fn add_display_level(&mut self, display_level: u32) {
    self.fbb_.push_slot_always::<u32>(ComParam::VT_DISPLAY_LEVEL, display_level);
  }
  #[inline]
  pub fn add_cp_usage(&mut self, cp_usage: ComParamUsage) {
    self.fbb_.push_slot::<ComParamUsage>(ComParam::VT_CP_USAGE, cp_usage, ComParamUsage::ECU_SOFTWARE);
  }
  #[inline]
  pub fn add_specific_data_type(&mut self, specific_data_type: ComParamSpecificData) {
    self.fbb_.push_slot::<ComParamSpecificData>(ComParam::VT_SPECIFIC_DATA_TYPE, specific_data_type, ComParamSpecificData::NONE);
  }
  #[inline]
  pub fn add_specific_data(&mut self, specific_data: flatbuffers::WIPOffset<ComParamSpecificDataUnionValue>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParam::VT_SPECIFIC_DATA, specific_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComParamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComParam");
      ds.field("com_param_type", &self.com_param_type());
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("param_class", &self.param_class());
      ds.field("cp_type", &self.cp_type());
      ds.field("display_level", &self.display_level());
      ds.field("cp_usage", &self.cp_usage());
      ds.field("specific_data_type", &self.specific_data_type());
      match self.specific_data_type() {
        ComParamSpecificData::RegularComParam => {
          if let Some(x) = self.specific_data_as_regular_com_param() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ComParamSpecificData::ComplexComParam => {
          if let Some(x) = self.specific_data_as_complex_com_param() {
            ds.field("specific_data", &x)
          } else {
            ds.field("specific_data", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("specific_data", &x)
        },
      };
      ds.finish()
  }
}
pub enum PhysicalDimensionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PhysicalDimension<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PhysicalDimension<'a> {
  type Inner = PhysicalDimension<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PhysicalDimension<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_LENGTH_EXP: flatbuffers::VOffsetT = 8;
  pub const VT_MASS_EXP: flatbuffers::VOffsetT = 10;
  pub const VT_TIME_EXP: flatbuffers::VOffsetT = 12;
  pub const VT_CURRENT_EXP: flatbuffers::VOffsetT = 14;
  pub const VT_TEMPERATURE_EXP: flatbuffers::VOffsetT = 16;
  pub const VT_MOLAR_AMOUNT_EXP: flatbuffers::VOffsetT = 18;
  pub const VT_LUMINOUS_INTENSITY_EXP: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PhysicalDimension { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PhysicalDimensionArgs<'args>
  ) -> flatbuffers::WIPOffset<PhysicalDimension<'bldr>> {
    let mut builder = PhysicalDimensionBuilder::new(_fbb);
    if let Some(x) = args.luminous_intensity_exp { builder.add_luminous_intensity_exp(x); }
    if let Some(x) = args.molar_amount_exp { builder.add_molar_amount_exp(x); }
    if let Some(x) = args.temperature_exp { builder.add_temperature_exp(x); }
    if let Some(x) = args.current_exp { builder.add_current_exp(x); }
    if let Some(x) = args.time_exp { builder.add_time_exp(x); }
    if let Some(x) = args.mass_exp { builder.add_mass_exp(x); }
    if let Some(x) = args.length_exp { builder.add_length_exp(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PhysicalDimension::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(PhysicalDimension::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn length_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_LENGTH_EXP, None)}
  }
  #[inline]
  pub fn mass_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_MASS_EXP, None)}
  }
  #[inline]
  pub fn time_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_TIME_EXP, None)}
  }
  #[inline]
  pub fn current_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_CURRENT_EXP, None)}
  }
  #[inline]
  pub fn temperature_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_TEMPERATURE_EXP, None)}
  }
  #[inline]
  pub fn molar_amount_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_MOLAR_AMOUNT_EXP, None)}
  }
  #[inline]
  pub fn luminous_intensity_exp(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PhysicalDimension::VT_LUMINOUS_INTENSITY_EXP, None)}
  }
}

impl flatbuffers::Verifiable for PhysicalDimension<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<i32>("length_exp", Self::VT_LENGTH_EXP, false)?
     .visit_field::<i32>("mass_exp", Self::VT_MASS_EXP, false)?
     .visit_field::<i32>("time_exp", Self::VT_TIME_EXP, false)?
     .visit_field::<i32>("current_exp", Self::VT_CURRENT_EXP, false)?
     .visit_field::<i32>("temperature_exp", Self::VT_TEMPERATURE_EXP, false)?
     .visit_field::<i32>("molar_amount_exp", Self::VT_MOLAR_AMOUNT_EXP, false)?
     .visit_field::<i32>("luminous_intensity_exp", Self::VT_LUMINOUS_INTENSITY_EXP, false)?
     .finish();
    Ok(())
  }
}
pub struct PhysicalDimensionArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub length_exp: Option<i32>,
    pub mass_exp: Option<i32>,
    pub time_exp: Option<i32>,
    pub current_exp: Option<i32>,
    pub temperature_exp: Option<i32>,
    pub molar_amount_exp: Option<i32>,
    pub luminous_intensity_exp: Option<i32>,
}
impl<'a> Default for PhysicalDimensionArgs<'a> {
  #[inline]
  fn default() -> Self {
    PhysicalDimensionArgs {
      short_name: None,
      long_name: None,
      length_exp: None,
      mass_exp: None,
      time_exp: None,
      current_exp: None,
      temperature_exp: None,
      molar_amount_exp: None,
      luminous_intensity_exp: None,
    }
  }
}

pub struct PhysicalDimensionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PhysicalDimensionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PhysicalDimension::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(PhysicalDimension::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_length_exp(&mut self, length_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_LENGTH_EXP, length_exp);
  }
  #[inline]
  pub fn add_mass_exp(&mut self, mass_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_MASS_EXP, mass_exp);
  }
  #[inline]
  pub fn add_time_exp(&mut self, time_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_TIME_EXP, time_exp);
  }
  #[inline]
  pub fn add_current_exp(&mut self, current_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_CURRENT_EXP, current_exp);
  }
  #[inline]
  pub fn add_temperature_exp(&mut self, temperature_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_TEMPERATURE_EXP, temperature_exp);
  }
  #[inline]
  pub fn add_molar_amount_exp(&mut self, molar_amount_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_MOLAR_AMOUNT_EXP, molar_amount_exp);
  }
  #[inline]
  pub fn add_luminous_intensity_exp(&mut self, luminous_intensity_exp: i32) {
    self.fbb_.push_slot_always::<i32>(PhysicalDimension::VT_LUMINOUS_INTENSITY_EXP, luminous_intensity_exp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PhysicalDimensionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PhysicalDimensionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PhysicalDimension<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PhysicalDimension<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PhysicalDimension");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("length_exp", &self.length_exp());
      ds.field("mass_exp", &self.mass_exp());
      ds.field("time_exp", &self.time_exp());
      ds.field("current_exp", &self.current_exp());
      ds.field("temperature_exp", &self.temperature_exp());
      ds.field("molar_amount_exp", &self.molar_amount_exp());
      ds.field("luminous_intensity_exp", &self.luminous_intensity_exp());
      ds.finish()
  }
}
pub enum UnitGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitGroup<'a> {
  type Inner = UnitGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> UnitGroup<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_UNITREFS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnitGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnitGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<UnitGroup<'bldr>> {
    let mut builder = UnitGroupBuilder::new(_fbb);
    if let Some(x) = args.unitrefs { builder.add_unitrefs(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UnitGroup::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(UnitGroup::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn unitrefs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(UnitGroup::VT_UNITREFS, None)}
  }
}

impl flatbuffers::Verifiable for UnitGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("unitrefs", Self::VT_UNITREFS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitGroupArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub unitrefs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
}
impl<'a> Default for UnitGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnitGroupArgs {
      short_name: None,
      long_name: None,
      unitrefs: None,
    }
  }
}

pub struct UnitGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitGroup::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(UnitGroup::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_unitrefs(&mut self, unitrefs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitGroup::VT_UNITREFS, unitrefs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnitGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnitGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnitGroup");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("unitrefs", &self.unitrefs());
      ds.finish()
  }
}
pub enum UnitSpecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitSpec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitSpec<'a> {
  type Inner = UnitSpec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> UnitSpec<'a> {
  pub const VT_UNIT_GROUPS: flatbuffers::VOffsetT = 4;
  pub const VT_UNITS: flatbuffers::VOffsetT = 6;
  pub const VT_PHYSICAL_DIMENSIONS: flatbuffers::VOffsetT = 8;
  pub const VT_SDGS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnitSpec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnitSpecArgs<'args>
  ) -> flatbuffers::WIPOffset<UnitSpec<'bldr>> {
    let mut builder = UnitSpecBuilder::new(_fbb);
    if let Some(x) = args.sdgs { builder.add_sdgs(x); }
    if let Some(x) = args.physical_dimensions { builder.add_physical_dimensions(x); }
    if let Some(x) = args.units { builder.add_units(x); }
    if let Some(x) = args.unit_groups { builder.add_unit_groups(x); }
    builder.finish()
  }


  #[inline]
  pub fn unit_groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitGroup>>>>(UnitSpec::VT_UNIT_GROUPS, None)}
  }
  #[inline]
  pub fn units(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(UnitSpec::VT_UNITS, None)}
  }
  #[inline]
  pub fn physical_dimensions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PhysicalDimension<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PhysicalDimension>>>>(UnitSpec::VT_PHYSICAL_DIMENSIONS, None)}
  }
  #[inline]
  pub fn sdgs(&self) -> Option<SDGS<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDGS>>(UnitSpec::VT_SDGS, None)}
  }
}

impl flatbuffers::Verifiable for UnitSpec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UnitGroup>>>>("unit_groups", Self::VT_UNIT_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("units", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PhysicalDimension>>>>("physical_dimensions", Self::VT_PHYSICAL_DIMENSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDGS>>("sdgs", Self::VT_SDGS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitSpecArgs<'a> {
    pub unit_groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UnitGroup<'a>>>>>,
    pub units: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub physical_dimensions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PhysicalDimension<'a>>>>>,
    pub sdgs: Option<flatbuffers::WIPOffset<SDGS<'a>>>,
}
impl<'a> Default for UnitSpecArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnitSpecArgs {
      unit_groups: None,
      units: None,
      physical_dimensions: None,
      sdgs: None,
    }
  }
}

pub struct UnitSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitSpecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_unit_groups(&mut self, unit_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UnitGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitSpec::VT_UNIT_GROUPS, unit_groups);
  }
  #[inline]
  pub fn add_units(&mut self, units: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitSpec::VT_UNITS, units);
  }
  #[inline]
  pub fn add_physical_dimensions(&mut self, physical_dimensions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PhysicalDimension<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UnitSpec::VT_PHYSICAL_DIMENSIONS, physical_dimensions);
  }
  #[inline]
  pub fn add_sdgs(&mut self, sdgs: flatbuffers::WIPOffset<SDGS<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDGS>>(UnitSpec::VT_SDGS, sdgs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitSpecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnitSpecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitSpec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnitSpec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnitSpec");
      ds.field("unit_groups", &self.unit_groups());
      ds.field("units", &self.units());
      ds.field("physical_dimensions", &self.physical_dimensions());
      ds.field("sdgs", &self.sdgs());
      ds.finish()
  }
}
pub enum ComParamSubSetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComParamSubSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComParamSubSet<'a> {
  type Inner = ComParamSubSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComParamSubSet<'a> {
  pub const VT_COM_PARAMS: flatbuffers::VOffsetT = 4;
  pub const VT_COMPLEX_COM_PARAMS: flatbuffers::VOffsetT = 6;
  pub const VT_DATA_OBJECT_PROPS: flatbuffers::VOffsetT = 8;
  pub const VT_UNIT_SPEC: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComParamSubSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComParamSubSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ComParamSubSet<'bldr>> {
    let mut builder = ComParamSubSetBuilder::new(_fbb);
    if let Some(x) = args.unit_spec { builder.add_unit_spec(x); }
    if let Some(x) = args.data_object_props { builder.add_data_object_props(x); }
    if let Some(x) = args.complex_com_params { builder.add_complex_com_params(x); }
    if let Some(x) = args.com_params { builder.add_com_params(x); }
    builder.finish()
  }


  #[inline]
  pub fn com_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam>>>>(ComParamSubSet::VT_COM_PARAMS, None)}
  }
  #[inline]
  pub fn complex_com_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam>>>>(ComParamSubSet::VT_COMPLEX_COM_PARAMS, None)}
  }
  #[inline]
  pub fn data_object_props(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP>>>>(ComParamSubSet::VT_DATA_OBJECT_PROPS, None)}
  }
  #[inline]
  pub fn unit_spec(&self) -> Option<UnitSpec<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UnitSpec>>(ComParamSubSet::VT_UNIT_SPEC, None)}
  }
}

impl flatbuffers::Verifiable for ComParamSubSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParam>>>>("com_params", Self::VT_COM_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParam>>>>("complex_com_params", Self::VT_COMPLEX_COM_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DOP>>>>("data_object_props", Self::VT_DATA_OBJECT_PROPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UnitSpec>>("unit_spec", Self::VT_UNIT_SPEC, false)?
     .finish();
    Ok(())
  }
}
pub struct ComParamSubSetArgs<'a> {
    pub com_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>>>,
    pub complex_com_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParam<'a>>>>>,
    pub data_object_props: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DOP<'a>>>>>,
    pub unit_spec: Option<flatbuffers::WIPOffset<UnitSpec<'a>>>,
}
impl<'a> Default for ComParamSubSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComParamSubSetArgs {
      com_params: None,
      complex_com_params: None,
      data_object_props: None,
      unit_spec: None,
    }
  }
}

pub struct ComParamSubSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComParamSubSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_com_params(&mut self, com_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParamSubSet::VT_COM_PARAMS, com_params);
  }
  #[inline]
  pub fn add_complex_com_params(&mut self, complex_com_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParamSubSet::VT_COMPLEX_COM_PARAMS, complex_com_params);
  }
  #[inline]
  pub fn add_data_object_props(&mut self, data_object_props: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DOP<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParamSubSet::VT_DATA_OBJECT_PROPS, data_object_props);
  }
  #[inline]
  pub fn add_unit_spec(&mut self, unit_spec: flatbuffers::WIPOffset<UnitSpec<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UnitSpec>>(ComParamSubSet::VT_UNIT_SPEC, unit_spec);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComParamSubSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComParamSubSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComParamSubSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComParamSubSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComParamSubSet");
      ds.field("com_params", &self.com_params());
      ds.field("complex_com_params", &self.complex_com_params());
      ds.field("data_object_props", &self.data_object_props());
      ds.field("unit_spec", &self.unit_spec());
      ds.finish()
  }
}
pub enum ProtStackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProtStack<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProtStack<'a> {
  type Inner = ProtStack<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ProtStack<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PDU_PROTOCOL_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_PHYSICAL_LINK_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_COMPARAM_SUBSET_REFS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProtStack { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProtStackArgs<'args>
  ) -> flatbuffers::WIPOffset<ProtStack<'bldr>> {
    let mut builder = ProtStackBuilder::new(_fbb);
    if let Some(x) = args.comparam_subset_refs { builder.add_comparam_subset_refs(x); }
    if let Some(x) = args.physical_link_type { builder.add_physical_link_type(x); }
    if let Some(x) = args.pdu_protocol_type { builder.add_pdu_protocol_type(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProtStack::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(ProtStack::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn pdu_protocol_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProtStack::VT_PDU_PROTOCOL_TYPE, None)}
  }
  #[inline]
  pub fn physical_link_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ProtStack::VT_PHYSICAL_LINK_TYPE, None)}
  }
  #[inline]
  pub fn comparam_subset_refs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamSubSet<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamSubSet>>>>(ProtStack::VT_COMPARAM_SUBSET_REFS, None)}
  }
}

impl flatbuffers::Verifiable for ProtStack<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pdu_protocol_type", Self::VT_PDU_PROTOCOL_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("physical_link_type", Self::VT_PHYSICAL_LINK_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ComParamSubSet>>>>("comparam_subset_refs", Self::VT_COMPARAM_SUBSET_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct ProtStackArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub pdu_protocol_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub physical_link_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comparam_subset_refs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ComParamSubSet<'a>>>>>,
}
impl<'a> Default for ProtStackArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProtStackArgs {
      short_name: None,
      long_name: None,
      pdu_protocol_type: None,
      physical_link_type: None,
      comparam_subset_refs: None,
    }
  }
}

pub struct ProtStackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProtStackBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProtStack::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(ProtStack::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_pdu_protocol_type(&mut self, pdu_protocol_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProtStack::VT_PDU_PROTOCOL_TYPE, pdu_protocol_type);
  }
  #[inline]
  pub fn add_physical_link_type(&mut self, physical_link_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProtStack::VT_PHYSICAL_LINK_TYPE, physical_link_type);
  }
  #[inline]
  pub fn add_comparam_subset_refs(&mut self, comparam_subset_refs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ComParamSubSet<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ProtStack::VT_COMPARAM_SUBSET_REFS, comparam_subset_refs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProtStackBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProtStackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProtStack<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProtStack<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProtStack");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("pdu_protocol_type", &self.pdu_protocol_type());
      ds.field("physical_link_type", &self.physical_link_type());
      ds.field("comparam_subset_refs", &self.comparam_subset_refs());
      ds.finish()
  }
}
pub enum ComParamSpecOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ComParamSpec<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComParamSpec<'a> {
  type Inner = ComParamSpec<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ComParamSpec<'a> {
  pub const VT_PROT_STACKS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ComParamSpec { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ComParamSpecArgs<'args>
  ) -> flatbuffers::WIPOffset<ComParamSpec<'bldr>> {
    let mut builder = ComParamSpecBuilder::new(_fbb);
    if let Some(x) = args.prot_stacks { builder.add_prot_stacks(x); }
    builder.finish()
  }


  #[inline]
  pub fn prot_stacks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProtStack<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProtStack>>>>(ComParamSpec::VT_PROT_STACKS, None)}
  }
}

impl flatbuffers::Verifiable for ComParamSpec<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProtStack>>>>("prot_stacks", Self::VT_PROT_STACKS, false)?
     .finish();
    Ok(())
  }
}
pub struct ComParamSpecArgs<'a> {
    pub prot_stacks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProtStack<'a>>>>>,
}
impl<'a> Default for ComParamSpecArgs<'a> {
  #[inline]
  fn default() -> Self {
    ComParamSpecArgs {
      prot_stacks: None,
    }
  }
}

pub struct ComParamSpecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ComParamSpecBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_prot_stacks(&mut self, prot_stacks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProtStack<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComParamSpec::VT_PROT_STACKS, prot_stacks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ComParamSpecBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ComParamSpecBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComParamSpec<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ComParamSpec<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ComParamSpec");
      ds.field("prot_stacks", &self.prot_stacks());
      ds.finish()
  }
}
pub enum LibraryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Library<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Library<'a> {
  type Inner = Library<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Library<'a> {
  pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LONG_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CODE_FILE: flatbuffers::VOffsetT = 8;
  pub const VT_ENCRYPTION: flatbuffers::VOffsetT = 10;
  pub const VT_SYNTAX: flatbuffers::VOffsetT = 12;
  pub const VT_ENTRY_POINT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Library { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LibraryArgs<'args>
  ) -> flatbuffers::WIPOffset<Library<'bldr>> {
    let mut builder = LibraryBuilder::new(_fbb);
    if let Some(x) = args.entry_point { builder.add_entry_point(x); }
    if let Some(x) = args.syntax { builder.add_syntax(x); }
    if let Some(x) = args.encryption { builder.add_encryption(x); }
    if let Some(x) = args.code_file { builder.add_code_file(x); }
    if let Some(x) = args.long_name { builder.add_long_name(x); }
    if let Some(x) = args.short_name { builder.add_short_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn short_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Library::VT_SHORT_NAME, None)}
  }
  #[inline]
  pub fn long_name(&self) -> Option<LongName<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LongName>>(Library::VT_LONG_NAME, None)}
  }
  #[inline]
  pub fn code_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Library::VT_CODE_FILE, None)}
  }
  #[inline]
  pub fn encryption(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Library::VT_ENCRYPTION, None)}
  }
  #[inline]
  pub fn syntax(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Library::VT_SYNTAX, None)}
  }
  #[inline]
  pub fn entry_point(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Library::VT_ENTRY_POINT, None)}
  }
}

impl flatbuffers::Verifiable for Library<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("short_name", Self::VT_SHORT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LongName>>("long_name", Self::VT_LONG_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code_file", Self::VT_CODE_FILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("encryption", Self::VT_ENCRYPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("syntax", Self::VT_SYNTAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entry_point", Self::VT_ENTRY_POINT, false)?
     .finish();
    Ok(())
  }
}
pub struct LibraryArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub long_name: Option<flatbuffers::WIPOffset<LongName<'a>>>,
    pub code_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encryption: Option<flatbuffers::WIPOffset<&'a str>>,
    pub syntax: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entry_point: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LibraryArgs<'a> {
  #[inline]
  fn default() -> Self {
    LibraryArgs {
      short_name: None,
      long_name: None,
      code_file: None,
      encryption: None,
      syntax: None,
      entry_point: None,
    }
  }
}

pub struct LibraryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LibraryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Library::VT_SHORT_NAME, short_name);
  }
  #[inline]
  pub fn add_long_name(&mut self, long_name: flatbuffers::WIPOffset<LongName<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LongName>>(Library::VT_LONG_NAME, long_name);
  }
  #[inline]
  pub fn add_code_file(&mut self, code_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Library::VT_CODE_FILE, code_file);
  }
  #[inline]
  pub fn add_encryption(&mut self, encryption: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Library::VT_ENCRYPTION, encryption);
  }
  #[inline]
  pub fn add_syntax(&mut self, syntax: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Library::VT_SYNTAX, syntax);
  }
  #[inline]
  pub fn add_entry_point(&mut self, entry_point: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Library::VT_ENTRY_POINT, entry_point);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LibraryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LibraryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Library<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Library<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Library");
      ds.field("short_name", &self.short_name());
      ds.field("long_name", &self.long_name());
      ds.field("code_file", &self.code_file());
      ds.field("encryption", &self.encryption());
      ds.field("syntax", &self.syntax());
      ds.field("entry_point", &self.entry_point());
      ds.finish()
  }
}
pub enum EcuDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EcuData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EcuData<'a> {
  type Inner = EcuData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> EcuData<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_ECU_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_REVISION: flatbuffers::VOffsetT = 8;
  pub const VT_METADATA: flatbuffers::VOffsetT = 10;
  pub const VT_FEATURE_FLAGS: flatbuffers::VOffsetT = 12;
  pub const VT_VARIANTS: flatbuffers::VOffsetT = 14;
  pub const VT_FUNCTIONAL_GROUPS: flatbuffers::VOffsetT = 16;
  pub const VT_DTCS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EcuData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EcuDataArgs<'args>
  ) -> flatbuffers::WIPOffset<EcuData<'bldr>> {
    let mut builder = EcuDataBuilder::new(_fbb);
    if let Some(x) = args.dtcs { builder.add_dtcs(x); }
    if let Some(x) = args.functional_groups { builder.add_functional_groups(x); }
    if let Some(x) = args.variants { builder.add_variants(x); }
    if let Some(x) = args.feature_flags { builder.add_feature_flags(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.revision { builder.add_revision(x); }
    if let Some(x) = args.ecu_name { builder.add_ecu_name(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EcuData::VT_VERSION, None)}
  }
  #[inline]
  pub fn ecu_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EcuData::VT_ECU_NAME, None)}
  }
  #[inline]
  pub fn revision(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EcuData::VT_REVISION, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(EcuData::VT_METADATA, None)}
  }
  #[inline]
  pub fn feature_flags(&self) -> Option<flatbuffers::Vector<'a, FeatureFlag>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, FeatureFlag>>>(EcuData::VT_FEATURE_FLAGS, None)}
  }
  #[inline]
  pub fn variants(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Variant<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Variant>>>>(EcuData::VT_VARIANTS, None)}
  }
  #[inline]
  pub fn functional_groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionalGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionalGroup>>>>(EcuData::VT_FUNCTIONAL_GROUPS, None)}
  }
  #[inline]
  pub fn dtcs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC>>>>(EcuData::VT_DTCS, None)}
  }
}

impl flatbuffers::Verifiable for EcuData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ecu_name", Self::VT_ECU_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("revision", Self::VT_REVISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, FeatureFlag>>>("feature_flags", Self::VT_FEATURE_FLAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Variant>>>>("variants", Self::VT_VARIANTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FunctionalGroup>>>>("functional_groups", Self::VT_FUNCTIONAL_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DTC>>>>("dtcs", Self::VT_DTCS, false)?
     .finish();
    Ok(())
  }
}
pub struct EcuDataArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ecu_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub revision: Option<flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub feature_flags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, FeatureFlag>>>,
    pub variants: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Variant<'a>>>>>,
    pub functional_groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FunctionalGroup<'a>>>>>,
    pub dtcs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DTC<'a>>>>>,
}
impl<'a> Default for EcuDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    EcuDataArgs {
      version: None,
      ecu_name: None,
      revision: None,
      metadata: None,
      feature_flags: None,
      variants: None,
      functional_groups: None,
      dtcs: None,
    }
  }
}

pub struct EcuDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EcuDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_VERSION, version);
  }
  #[inline]
  pub fn add_ecu_name(&mut self, ecu_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_ECU_NAME, ecu_name);
  }
  #[inline]
  pub fn add_revision(&mut self, revision: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_REVISION, revision);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_feature_flags(&mut self, feature_flags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , FeatureFlag>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_FEATURE_FLAGS, feature_flags);
  }
  #[inline]
  pub fn add_variants(&mut self, variants: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Variant<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_VARIANTS, variants);
  }
  #[inline]
  pub fn add_functional_groups(&mut self, functional_groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FunctionalGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_FUNCTIONAL_GROUPS, functional_groups);
  }
  #[inline]
  pub fn add_dtcs(&mut self, dtcs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DTC<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EcuData::VT_DTCS, dtcs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EcuDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EcuDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EcuData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EcuData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EcuData");
      ds.field("version", &self.version());
      ds.field("ecu_name", &self.ecu_name());
      ds.field("revision", &self.revision());
      ds.field("metadata", &self.metadata());
      ds.field("feature_flags", &self.feature_flags());
      ds.field("variants", &self.variants());
      ds.field("functional_groups", &self.functional_groups());
      ds.field("dtcs", &self.dtcs());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key: None,
      value: None,
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EcuData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecu_data_unchecked`.
pub fn root_as_ecu_data(buf: &[u8]) -> Result<EcuData<'_>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EcuData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EcuData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ecu_data_unchecked`.
pub fn size_prefixed_root_as_ecu_data(buf: &[u8]) -> Result<EcuData<'_>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EcuData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EcuData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecu_data_unchecked`.
pub fn root_as_ecu_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EcuData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EcuData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EcuData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ecu_data_unchecked`.
pub fn size_prefixed_root_as_ecu_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EcuData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EcuData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EcuData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EcuData`.
pub unsafe fn root_as_ecu_data_unchecked(buf: &[u8]) -> EcuData<'_> {
  unsafe { flatbuffers::root_unchecked::<EcuData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EcuData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EcuData`.
pub unsafe fn size_prefixed_root_as_ecu_data_unchecked(buf: &[u8]) -> EcuData<'_> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<EcuData>(buf) }
}
#[inline]
pub fn finish_ecu_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EcuData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_ecu_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EcuData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod dataformat

