/*
 * Copyright (c) 2025 The Contributors to Eclipse OpenSOVD (see CONTRIBUTORS)
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObjectId {
    #[prost(uint32, tag = "1")]
    pub value: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Sd {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub si: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub ti: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SD`.
pub mod sd {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SdOrSdg {
    #[prost(oneof = "sd_or_sdg::SDxorSdg", tags = "1, 2")]
    pub s_dxor_sdg: ::core::option::Option<sd_or_sdg::SDxorSdg>,
}
/// Nested message and enum types in `SDOrSDG`.
pub mod sd_or_sdg {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SDxorSdg {
        #[prost(message, tag = "1")]
        Sd(super::sd::Ref),
        #[prost(message, tag = "2")]
        Sdg(super::sdg::Ref),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sdg {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub caption: ::core::option::Option<sdg::SdgCaption>,
    #[prost(message, repeated, tag = "3")]
    pub sds: ::prost::alloc::vec::Vec<SdOrSdg>,
    #[prost(string, optional, tag = "4")]
    pub si: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SDG`.
pub mod sdg {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SdgCaption {
        #[prost(string, tag = "1")]
        pub short_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sdgs {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, repeated, tag = "2")]
    pub sdgs: ::prost::alloc::vec::Vec<sdg::Ref>,
}
/// Nested message and enum types in `SDGS`.
pub mod sdgs {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audience {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, repeated, tag = "2")]
    pub enabled_audiences: ::prost::alloc::vec::Vec<additional_audience::Ref>,
    #[prost(message, repeated, tag = "3")]
    pub disabled_audiences: ::prost::alloc::vec::Vec<additional_audience::Ref>,
    #[prost(bool, tag = "4")]
    pub is_supplier: bool,
    #[prost(bool, tag = "5")]
    pub is_development: bool,
    #[prost(bool, tag = "6")]
    pub is_manufacturing: bool,
    #[prost(bool, tag = "7")]
    pub is_after_sales: bool,
    #[prost(bool, tag = "8")]
    pub is_after_market: bool,
}
/// Nested message and enum types in `Audience`.
pub mod audience {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiagCodedType {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(enumeration = "diag_coded_type::DiagCodedTypeName", tag = "2")]
    pub r#type: i32,
    #[prost(string, optional, tag = "3")]
    pub base_type_encoding: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "diag_coded_type::DataType", tag = "4")]
    pub base_data_type: i32,
    /// default true
    #[prost(bool, optional, tag = "5")]
    pub is_high_low_byte_order: ::core::option::Option<bool>,
    #[prost(oneof = "diag_coded_type::SpecificData", tags = "6, 7, 8, 9")]
    pub specific_data: ::core::option::Option<diag_coded_type::SpecificData>,
}
/// Nested message and enum types in `DiagCodedType`.
pub mod diag_coded_type {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LeadingLengthInfoType {
        #[prost(uint32, tag = "1")]
        pub bit_length: u32,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MinMaxLengthType {
        #[prost(uint32, tag = "1")]
        pub min_length: u32,
        #[prost(uint32, optional, tag = "2")]
        pub max_length: ::core::option::Option<u32>,
        #[prost(enumeration = "min_max_length_type::Termination", tag = "3")]
        pub termination: i32,
    }
    /// Nested message and enum types in `MinMaxLengthType`.
    pub mod min_max_length_type {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Termination {
            EndOfPdu = 0,
            Zero = 1,
            HexFf = 2,
        }
        impl Termination {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::EndOfPdu => "END_OF_PDU",
                    Self::Zero => "ZERO",
                    Self::HexFf => "HEX_FF",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "END_OF_PDU" => Some(Self::EndOfPdu),
                    "ZERO" => Some(Self::Zero),
                    "HEX_FF" => Some(Self::HexFf),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParamLengthInfoType {
        #[prost(message, optional, tag = "1")]
        pub length_key: ::core::option::Option<super::param::Ref>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StandardLengthType {
        #[prost(uint32, tag = "1")]
        pub bit_length: u32,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub bit_mask: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// default false
        #[prost(bool, optional, tag = "3")]
        pub condensed: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiagCodedTypeName {
        LeadingLengthInfoType = 0,
        MinMaxLengthType = 1,
        ParamLengthInfoType = 2,
        StandardLengthType = 3,
    }
    impl DiagCodedTypeName {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LeadingLengthInfoType => "LEADING_LENGTH_INFO_TYPE",
                Self::MinMaxLengthType => "MIN_MAX_LENGTH_TYPE",
                Self::ParamLengthInfoType => "PARAM_LENGTH_INFO_TYPE",
                Self::StandardLengthType => "STANDARD_LENGTH_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LEADING_LENGTH_INFO_TYPE" => Some(Self::LeadingLengthInfoType),
                "MIN_MAX_LENGTH_TYPE" => Some(Self::MinMaxLengthType),
                "PARAM_LENGTH_INFO_TYPE" => Some(Self::ParamLengthInfoType),
                "STANDARD_LENGTH_TYPE" => Some(Self::StandardLengthType),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        AInt32 = 0,
        AUint32 = 1,
        AFloat32 = 2,
        AAsciistring = 3,
        AUtf8String = 4,
        AUnicode2String = 5,
        ABytefield = 6,
        AFloat64 = 7,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AInt32 => "A_INT_32",
                Self::AUint32 => "A_UINT_32",
                Self::AFloat32 => "A_FLOAT_32",
                Self::AAsciistring => "A_ASCIISTRING",
                Self::AUtf8String => "A_UTF_8_STRING",
                Self::AUnicode2String => "A_UNICODE_2_STRING",
                Self::ABytefield => "A_BYTEFIELD",
                Self::AFloat64 => "A_FLOAT_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "A_INT_32" => Some(Self::AInt32),
                "A_UINT_32" => Some(Self::AUint32),
                "A_FLOAT_32" => Some(Self::AFloat32),
                "A_ASCIISTRING" => Some(Self::AAsciistring),
                "A_UTF_8_STRING" => Some(Self::AUtf8String),
                "A_UNICODE_2_STRING" => Some(Self::AUnicode2String),
                "A_BYTEFIELD" => Some(Self::ABytefield),
                "A_FLOAT_64" => Some(Self::AFloat64),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SpecificData {
        #[prost(message, tag = "6")]
        LeadingLengthInfoType(LeadingLengthInfoType),
        #[prost(message, tag = "7")]
        MinMaxLengthType(MinMaxLengthType),
        #[prost(message, tag = "8")]
        ParamLengthInfoType(ParamLengthInfoType),
        #[prost(message, tag = "9")]
        StandardLengthType(StandardLengthType),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Text {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub ti: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Limit {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    #[prost(enumeration = "limit::IntervalType", tag = "2")]
    pub interval_type: i32,
}
/// Nested message and enum types in `Limit`.
pub mod limit {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IntervalType {
        Open = 0,
        Closed = 1,
        Infinite = 2,
    }
    impl IntervalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Open => "OPEN",
                Self::Closed => "CLOSED",
                Self::Infinite => "INFINITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                "INFINITE" => Some(Self::Infinite),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompuValues {
    #[prost(double, optional, tag = "1")]
    pub v: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "2")]
    pub vt: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub vt_ti: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompuScale {
    #[prost(message, optional, tag = "1")]
    pub short_label: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "2")]
    pub lower_limit: ::core::option::Option<Limit>,
    #[prost(message, optional, tag = "3")]
    pub upper_limit: ::core::option::Option<Limit>,
    #[prost(message, optional, tag = "4")]
    pub inverse_values: ::core::option::Option<CompuValues>,
    #[prost(message, optional, tag = "5")]
    pub consts: ::core::option::Option<CompuValues>,
    #[prost(message, optional, tag = "6")]
    pub rational_co_effs: ::core::option::Option<compu_scale::CompuRationalCoEffs>,
}
/// Nested message and enum types in `CompuScale`.
pub mod compu_scale {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompuRationalCoEffs {
        #[prost(double, repeated, tag = "1")]
        pub numerator: ::prost::alloc::vec::Vec<f64>,
        #[prost(double, repeated, tag = "2")]
        pub denominator: ::prost::alloc::vec::Vec<f64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompuMethod {
    #[prost(enumeration = "compu_method::CompuCategory", optional, tag = "1")]
    pub category: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub internal_to_phys: ::core::option::Option<compu_method::CompuInternalToPhys>,
    #[prost(message, optional, tag = "3")]
    pub phys_to_internal: ::core::option::Option<compu_method::CompuPhysToInternal>,
}
/// Nested message and enum types in `CompuMethod`.
pub mod compu_method {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompuInternalToPhys {
        #[prost(message, repeated, tag = "1")]
        pub compu_scales: ::prost::alloc::vec::Vec<super::CompuScale>,
        #[prost(message, optional, tag = "2")]
        pub prog_code: ::core::option::Option<super::ProgCode>,
        #[prost(message, optional, tag = "3")]
        pub compu_default_value: ::core::option::Option<CompuDefaultValue>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompuPhysToInternal {
        #[prost(message, optional, tag = "1")]
        pub prog_code: ::core::option::Option<super::ProgCode>,
        #[prost(message, repeated, tag = "2")]
        pub compu_scales: ::prost::alloc::vec::Vec<super::CompuScale>,
        #[prost(message, optional, tag = "3")]
        pub compu_default_value: ::core::option::Option<CompuDefaultValue>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompuDefaultValue {
        #[prost(message, optional, tag = "1")]
        pub values: ::core::option::Option<super::CompuValues>,
        #[prost(message, optional, tag = "2")]
        pub inverse_values: ::core::option::Option<super::CompuValues>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompuCategory {
        Identical = 0,
        Linear = 1,
        ScaleLinear = 2,
        TextTable = 3,
        CompuCode = 4,
        TabIntp = 5,
        RatFunc = 6,
        ScaleRatFunc = 7,
    }
    impl CompuCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Identical => "IDENTICAL",
                Self::Linear => "LINEAR",
                Self::ScaleLinear => "SCALE_LINEAR",
                Self::TextTable => "TEXT_TABLE",
                Self::CompuCode => "COMPU_CODE",
                Self::TabIntp => "TAB_INTP",
                Self::RatFunc => "RAT_FUNC",
                Self::ScaleRatFunc => "SCALE_RAT_FUNC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IDENTICAL" => Some(Self::Identical),
                "LINEAR" => Some(Self::Linear),
                "SCALE_LINEAR" => Some(Self::ScaleLinear),
                "TEXT_TABLE" => Some(Self::TextTable),
                "COMPU_CODE" => Some(Self::CompuCode),
                "TAB_INTP" => Some(Self::TabIntp),
                "RAT_FUNC" => Some(Self::RatFunc),
                "SCALE_RAT_FUNC" => Some(Self::ScaleRatFunc),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhysicalType {
    #[prost(uint32, optional, tag = "1")]
    pub precision: ::core::option::Option<u32>,
    #[prost(enumeration = "physical_type::DataType", tag = "2")]
    pub base_data_type: i32,
    #[prost(enumeration = "physical_type::Radix", optional, tag = "3")]
    pub display_radix: ::core::option::Option<i32>,
}
/// Nested message and enum types in `PhysicalType`.
pub mod physical_type {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        AInt32 = 0,
        AUint32 = 1,
        AFloat32 = 2,
        AAsciistring = 3,
        AUtf8String = 4,
        AUnicode2String = 5,
        ABytefield = 6,
        AFloat64 = 7,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AInt32 => "A_INT_32",
                Self::AUint32 => "A_UINT_32",
                Self::AFloat32 => "A_FLOAT_32",
                Self::AAsciistring => "A_ASCIISTRING",
                Self::AUtf8String => "A_UTF_8_STRING",
                Self::AUnicode2String => "A_UNICODE_2_STRING",
                Self::ABytefield => "A_BYTEFIELD",
                Self::AFloat64 => "A_FLOAT_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "A_INT_32" => Some(Self::AInt32),
                "A_UINT_32" => Some(Self::AUint32),
                "A_FLOAT_32" => Some(Self::AFloat32),
                "A_ASCIISTRING" => Some(Self::AAsciistring),
                "A_UTF_8_STRING" => Some(Self::AUtf8String),
                "A_UNICODE_2_STRING" => Some(Self::AUnicode2String),
                "A_BYTEFIELD" => Some(Self::ABytefield),
                "A_FLOAT_64" => Some(Self::AFloat64),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Radix {
        Hex = 0,
        Dec = 1,
        Bin = 2,
        Oct = 3,
    }
    impl Radix {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Hex => "HEX",
                Self::Dec => "DEC",
                Self::Bin => "BIN",
                Self::Oct => "OCT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HEX" => Some(Self::Hex),
                "DEC" => Some(Self::Dec),
                "BIN" => Some(Self::Bin),
                "OCT" => Some(Self::Oct),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unit {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(double, optional, tag = "4")]
    pub factorsitounit: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "5")]
    pub offsetitounit: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "6")]
    pub physical_dimension: ::core::option::Option<physical_dimension::Ref>,
}
/// Nested message and enum types in `Unit`.
pub mod unit {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScaleConstr {
    #[prost(message, optional, tag = "1")]
    pub short_label: ::core::option::Option<Text>,
    #[prost(message, optional, tag = "2")]
    pub lower_limit: ::core::option::Option<Limit>,
    #[prost(message, optional, tag = "3")]
    pub upper_limit: ::core::option::Option<Limit>,
    #[prost(enumeration = "scale_constr::ValidType", tag = "4")]
    pub validity: i32,
}
/// Nested message and enum types in `ScaleConstr`.
pub mod scale_constr {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValidType {
        Valid = 0,
        NotValid = 1,
        NotDefined = 2,
        NotAvailable = 3,
    }
    impl ValidType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Valid => "VALID",
                Self::NotValid => "NOT_VALID",
                Self::NotDefined => "NOT_DEFINED",
                Self::NotAvailable => "NOT_AVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALID" => Some(Self::Valid),
                "NOT_VALID" => Some(Self::NotValid),
                "NOT_DEFINED" => Some(Self::NotDefined),
                "NOT_AVAILABLE" => Some(Self::NotAvailable),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalConstr {
    #[prost(message, optional, tag = "1")]
    pub lower_limit: ::core::option::Option<Limit>,
    #[prost(message, optional, tag = "2")]
    pub upper_limit: ::core::option::Option<Limit>,
    #[prost(message, repeated, tag = "3")]
    pub scale_constr: ::prost::alloc::vec::Vec<ScaleConstr>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Dtc {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub trouble_code: u32,
    #[prost(string, optional, tag = "4")]
    pub display_trouble_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Text>,
    #[prost(uint32, optional, tag = "6")]
    pub level: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "7")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
    #[prost(bool, optional, tag = "8")]
    pub is_temporary: ::core::option::Option<bool>,
}
/// Nested message and enum types in `DTC`.
pub mod dtc {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dop {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(enumeration = "dop::DopType", tag = "2")]
    pub dop_type: i32,
    #[prost(string, tag = "3")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
    #[prost(oneof = "dop::SpecificData", tags = "5, 6, 7, 8, 9, 10, 11, 12, 13")]
    pub specific_data: ::core::option::Option<dop::SpecificData>,
}
/// Nested message and enum types in `DOP`.
pub mod dop {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NormalDop {
        #[prost(message, optional, tag = "1")]
        pub compu_method: ::core::option::Option<super::CompuMethod>,
        #[prost(message, optional, tag = "2")]
        pub diag_coded_type: ::core::option::Option<super::diag_coded_type::Ref>,
        #[prost(message, optional, tag = "3")]
        pub physical_type: ::core::option::Option<super::PhysicalType>,
        #[prost(message, optional, tag = "4")]
        pub internal_constr: ::core::option::Option<super::InternalConstr>,
        #[prost(message, optional, tag = "5")]
        pub unit_ref: ::core::option::Option<super::unit::Ref>,
        #[prost(message, optional, tag = "6")]
        pub phys_constr: ::core::option::Option<super::InternalConstr>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Field {
        #[prost(message, optional, tag = "1")]
        pub basic_structure: ::core::option::Option<Ref>,
        #[prost(string, optional, tag = "2")]
        pub basic_structure_short_name_ref: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "3")]
        pub env_data_desc: ::core::option::Option<Ref>,
        #[prost(string, optional, tag = "4")]
        pub env_data_desc_short_name_ref: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(bool, optional, tag = "5")]
        pub is_visible: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StaticField {
        #[prost(uint32, tag = "1")]
        pub fixed_number_of_items: u32,
        #[prost(uint32, tag = "2")]
        pub item_byte_size: u32,
        #[prost(message, optional, tag = "3")]
        pub field: ::core::option::Option<Field>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EndOfPduField {
        #[prost(uint32, optional, tag = "1")]
        pub max_number_of_items: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub min_number_of_items: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "3")]
        pub field: ::core::option::Option<Field>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EnvDataDesc {
        #[prost(string, optional, tag = "1")]
        pub param_short_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub param_path_short_name: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, repeated, tag = "3")]
        pub env_datas: ::prost::alloc::vec::Vec<Ref>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EnvData {
        #[prost(uint32, repeated, tag = "1")]
        pub dtc_values: ::prost::alloc::vec::Vec<u32>,
        #[prost(message, repeated, tag = "2")]
        pub params: ::prost::alloc::vec::Vec<super::param::Ref>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Structure {
        #[prost(message, repeated, tag = "1")]
        pub params: ::prost::alloc::vec::Vec<super::param::Ref>,
        #[prost(uint32, optional, tag = "2")]
        pub byte_size: ::core::option::Option<u32>,
        #[prost(bool, tag = "3")]
        pub is_visible: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Dtcdop {
        #[prost(message, optional, tag = "1")]
        pub diag_coded_type: ::core::option::Option<super::diag_coded_type::Ref>,
        #[prost(message, optional, tag = "2")]
        pub physical_type: ::core::option::Option<super::PhysicalType>,
        #[prost(message, optional, tag = "3")]
        pub compu_method: ::core::option::Option<super::CompuMethod>,
        #[prost(message, repeated, tag = "4")]
        pub dtcs: ::prost::alloc::vec::Vec<super::dtc::Ref>,
        #[prost(bool, optional, tag = "5")]
        pub is_visible: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Muxdop {
        #[prost(uint32, tag = "1")]
        pub byte_position: u32,
        #[prost(message, optional, tag = "2")]
        pub switch_key: ::core::option::Option<muxdop::SwitchKey>,
        #[prost(message, optional, tag = "3")]
        pub default_case: ::core::option::Option<muxdop::DefaultCase>,
        #[prost(message, repeated, tag = "4")]
        pub cases: ::prost::alloc::vec::Vec<muxdop::Case>,
        #[prost(bool, optional, tag = "5")]
        pub is_visible: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `MUXDOP`.
    pub mod muxdop {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SwitchKey {
            #[prost(uint32, tag = "1")]
            pub byte_position: u32,
            #[prost(uint32, optional, tag = "2")]
            pub bit_position: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "3")]
            pub dop: ::core::option::Option<super::Ref>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DefaultCase {
            #[prost(string, tag = "1")]
            pub short_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub long_name: ::core::option::Option<super::super::LongName>,
            #[prost(message, optional, tag = "3")]
            pub structure: ::core::option::Option<super::Ref>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Case {
            #[prost(string, tag = "1")]
            pub short_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub long_name: ::core::option::Option<super::super::LongName>,
            #[prost(message, optional, tag = "3")]
            pub structure: ::core::option::Option<super::Ref>,
            #[prost(message, optional, tag = "4")]
            pub lower_limit: ::core::option::Option<super::super::Limit>,
            #[prost(message, optional, tag = "5")]
            pub upper_limit: ::core::option::Option<super::super::Limit>,
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DynamicLengthField {
        #[prost(uint32, tag = "1")]
        pub offset: u32,
        #[prost(message, optional, tag = "3")]
        pub field: ::core::option::Option<Field>,
        #[prost(message, optional, tag = "4")]
        pub determine_number_of_items: ::core::option::Option<
            dynamic_length_field::DetermineNumberOfItems,
        >,
    }
    /// Nested message and enum types in `DynamicLengthField`.
    pub mod dynamic_length_field {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DetermineNumberOfItems {
            #[prost(uint32, tag = "1")]
            pub byte_position: u32,
            #[prost(uint32, tag = "2")]
            pub bit_position: u32,
            #[prost(message, optional, tag = "3")]
            pub dop: ::core::option::Option<super::Ref>,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DopType {
        Regular = 0,
        EnvDataDesc = 1,
        Mux = 2,
        DynamicEndMarkerField = 3,
        DynamicLengthField = 4,
        EndOfPduField = 5,
        StaticField = 6,
        EnvData = 7,
        Structure = 8,
        Dtc = 9,
    }
    impl DopType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::EnvDataDesc => "ENV_DATA_DESC",
                Self::Mux => "MUX",
                Self::DynamicEndMarkerField => "DYNAMIC_END_MARKER_FIELD",
                Self::DynamicLengthField => "DYNAMIC_LENGTH_FIELD",
                Self::EndOfPduField => "END_OF_PDU_FIELD",
                Self::StaticField => "STATIC_FIELD",
                Self::EnvData => "ENV_DATA",
                Self::Structure => "STRUCTURE",
                Self::Dtc => "DTC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "ENV_DATA_DESC" => Some(Self::EnvDataDesc),
                "MUX" => Some(Self::Mux),
                "DYNAMIC_END_MARKER_FIELD" => Some(Self::DynamicEndMarkerField),
                "DYNAMIC_LENGTH_FIELD" => Some(Self::DynamicLengthField),
                "END_OF_PDU_FIELD" => Some(Self::EndOfPduField),
                "STATIC_FIELD" => Some(Self::StaticField),
                "ENV_DATA" => Some(Self::EnvData),
                "STRUCTURE" => Some(Self::Structure),
                "DTC" => Some(Self::Dtc),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SpecificData {
        #[prost(message, tag = "5")]
        NormalDop(NormalDop),
        #[prost(message, tag = "6")]
        EndOfPduField(EndOfPduField),
        #[prost(message, tag = "7")]
        StaticField(StaticField),
        #[prost(message, tag = "8")]
        EnvDataDesc(EnvDataDesc),
        #[prost(message, tag = "9")]
        EnvData(EnvData),
        #[prost(message, tag = "10")]
        DtcDop(Dtcdop),
        #[prost(message, tag = "11")]
        Structure(Structure),
        #[prost(message, tag = "12")]
        MuxDop(Muxdop),
        #[prost(message, tag = "13")]
        DynamicLengthField(DynamicLengthField),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LongName {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub ti: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct State {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
}
/// Nested message and enum types in `State`.
pub mod state {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateChart {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub semantic: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub state_transitions: ::prost::alloc::vec::Vec<state_transition::Ref>,
    #[prost(string, tag = "5")]
    pub start_state_short_name_ref: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub states: ::prost::alloc::vec::Vec<state::Ref>,
}
/// Nested message and enum types in `StateChart`.
pub mod state_chart {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StateTransition {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_short_name_ref: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub target_short_name_ref: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StateTransition`.
pub mod state_transition {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StateTransitionRef {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub state_transition: ::core::option::Option<state_transition::Ref>,
}
/// Nested message and enum types in `StateTransitionRef`.
pub mod state_transition_ref {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreConditionStateRef {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub in_param_if: ::core::option::Option<param::Ref>,
    #[prost(string, optional, tag = "4")]
    pub in_param_path_short_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub state: ::core::option::Option<state::Ref>,
}
/// Nested message and enum types in `PreConditionStateRef`.
pub mod pre_condition_state_ref {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableRow {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, tag = "4")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub dop: ::core::option::Option<dop::Ref>,
    #[prost(message, optional, tag = "6")]
    pub structure: ::core::option::Option<dop::Ref>,
    #[prost(message, optional, tag = "8")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
    #[prost(message, optional, tag = "9")]
    pub audience: ::core::option::Option<audience::Ref>,
    #[prost(message, repeated, tag = "10")]
    pub funct_class_refs: ::prost::alloc::vec::Vec<funct_class::Ref>,
    #[prost(message, repeated, tag = "11")]
    pub state_transition_refs: ::prost::alloc::vec::Vec<state_transition_ref::Ref>,
    #[prost(message, repeated, tag = "12")]
    pub pre_condition_state_refs: ::prost::alloc::vec::Vec<pre_condition_state_ref::Ref>,
    #[prost(bool, optional, tag = "13")]
    pub is_executable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "14")]
    pub semantic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "15")]
    pub is_mandatory: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub is_final: ::core::option::Option<bool>,
}
/// Nested message and enum types in `TableRow`.
pub mod table_row {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TableDiagCommConnector {
    #[prost(string, tag = "3")]
    pub semantic: ::prost::alloc::string::String,
    #[prost(oneof = "table_diag_comm_connector::DiagComm", tags = "1, 2")]
    pub diag_comm: ::core::option::Option<table_diag_comm_connector::DiagComm>,
}
/// Nested message and enum types in `TableDiagCommConnector`.
pub mod table_diag_comm_connector {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DiagComm {
        #[prost(message, tag = "1")]
        DiagService(super::diag_service::Ref),
        #[prost(message, tag = "2")]
        SingleEcuJob(super::single_ecu_job::Ref),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, optional, tag = "2")]
    pub semantic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, optional, tag = "5")]
    pub key_label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub struct_label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub key_dop: ::core::option::Option<dop::Ref>,
    #[prost(message, repeated, tag = "8")]
    pub rows: ::prost::alloc::vec::Vec<table_row::Ref>,
    #[prost(message, repeated, tag = "9")]
    pub diag_comm_connector: ::prost::alloc::vec::Vec<TableDiagCommConnector>,
    #[prost(message, optional, tag = "11")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
}
/// Nested message and enum types in `Table`.
pub mod table {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Param {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(enumeration = "param::ParamType", tag = "2")]
    pub param_type: i32,
    #[prost(string, tag = "3")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "4")]
    pub semantic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
    /// PositionableParam
    #[prost(string, optional, tag = "6")]
    pub physical_default_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "7")]
    pub byte_position: ::core::option::Option<u32>,
    /// allowed: 0-7
    #[prost(uint32, optional, tag = "8")]
    pub bit_position: ::core::option::Option<u32>,
    #[prost(
        oneof = "param::SpecificData",
        tags = "9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20"
    )]
    pub specific_data: ::core::option::Option<param::SpecificData>,
}
/// Nested message and enum types in `Param`.
pub mod param {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CodedConst {
        #[prost(string, tag = "1")]
        pub coded_value: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub diag_coded_type: ::core::option::Option<super::diag_coded_type::Ref>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Dynamic {}
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LengthKeyRef {
        #[prost(message, optional, tag = "1")]
        pub dop: ::core::option::Option<super::dop::Ref>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MatchingRequestParam {
        #[prost(int32, tag = "1")]
        pub request_byte_pos: i32,
        #[prost(uint32, tag = "2")]
        pub byte_length: u32,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NrcConst {
        #[prost(string, repeated, tag = "1")]
        pub coded_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "2")]
        pub diag_coded_type: ::core::option::Option<super::diag_coded_type::Ref>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PhysConst {
        #[prost(string, tag = "1")]
        pub phys_constant_value: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub dop: ::core::option::Option<super::dop::Ref>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Reserved {
        #[prost(uint32, tag = "1")]
        pub bit_length: u32,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct System {
        #[prost(message, optional, tag = "1")]
        pub dop: ::core::option::Option<super::dop::Ref>,
        #[prost(string, tag = "3")]
        pub sys_param: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableEntry {
        #[prost(message, optional, boxed, tag = "1")]
        pub param: ::core::option::Option<::prost::alloc::boxed::Box<super::Param>>,
        #[prost(enumeration = "table_entry::RowFragment", tag = "2")]
        pub target: i32,
        #[prost(message, optional, tag = "3")]
        pub table_row: ::core::option::Option<super::table_row::Ref>,
    }
    /// Nested message and enum types in `TableEntry`.
    pub mod table_entry {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RowFragment {
            Key = 0,
            Struct = 1,
        }
        impl RowFragment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Key => "KEY",
                    Self::Struct => "STRUCT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KEY" => Some(Self::Key),
                    "STRUCT" => Some(Self::Struct),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TableKey {
        #[prost(oneof = "table_key::TableKeyReference", tags = "1, 2")]
        pub table_key_reference: ::core::option::Option<table_key::TableKeyReference>,
    }
    /// Nested message and enum types in `TableKey`.
    pub mod table_key {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum TableKeyReference {
            #[prost(message, tag = "1")]
            Table(super::super::table::Ref),
            #[prost(message, tag = "2")]
            TableRow(super::super::table_row::Ref),
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TableStruct {
        #[prost(message, optional, tag = "1")]
        pub table_key: ::core::option::Option<Ref>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Value {
        #[prost(string, optional, tag = "1")]
        pub physical_default_value: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "2")]
        pub dop: ::core::option::Option<super::dop::Ref>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParamType {
        CodedConst = 0,
        Dynamic = 1,
        LengthKey = 2,
        MatchingRequestParam = 3,
        NrcConst = 4,
        PhysConst = 5,
        Reserved = 6,
        System = 7,
        TableEntry = 8,
        TableKey = 9,
        TableStruct = 10,
        Value = 11,
    }
    impl ParamType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CodedConst => "CODED_CONST",
                Self::Dynamic => "DYNAMIC",
                Self::LengthKey => "LENGTH_KEY",
                Self::MatchingRequestParam => "MATCHING_REQUEST_PARAM",
                Self::NrcConst => "NRC_CONST",
                Self::PhysConst => "PHYS_CONST",
                Self::Reserved => "RESERVED",
                Self::System => "SYSTEM",
                Self::TableEntry => "TABLE_ENTRY",
                Self::TableKey => "TABLE_KEY",
                Self::TableStruct => "TABLE_STRUCT",
                Self::Value => "VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CODED_CONST" => Some(Self::CodedConst),
                "DYNAMIC" => Some(Self::Dynamic),
                "LENGTH_KEY" => Some(Self::LengthKey),
                "MATCHING_REQUEST_PARAM" => Some(Self::MatchingRequestParam),
                "NRC_CONST" => Some(Self::NrcConst),
                "PHYS_CONST" => Some(Self::PhysConst),
                "RESERVED" => Some(Self::Reserved),
                "SYSTEM" => Some(Self::System),
                "TABLE_ENTRY" => Some(Self::TableEntry),
                "TABLE_KEY" => Some(Self::TableKey),
                "TABLE_STRUCT" => Some(Self::TableStruct),
                "VALUE" => Some(Self::Value),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SpecificData {
        #[prost(message, tag = "9")]
        CodedConst(CodedConst),
        #[prost(message, tag = "10")]
        Dynamic(Dynamic),
        #[prost(message, tag = "11")]
        MatchingRequestParam(MatchingRequestParam),
        #[prost(message, tag = "12")]
        NrcConst(NrcConst),
        #[prost(message, tag = "13")]
        PhysConst(PhysConst),
        #[prost(message, tag = "14")]
        Reserved(Reserved),
        #[prost(message, tag = "15")]
        Value(Value),
        #[prost(message, tag = "16")]
        TableEntry(::prost::alloc::boxed::Box<TableEntry>),
        #[prost(message, tag = "17")]
        TableKey(TableKey),
        #[prost(message, tag = "18")]
        TableStruct(TableStruct),
        #[prost(message, tag = "19")]
        System(System),
        #[prost(message, tag = "20")]
        LengthKeyRef(LengthKeyRef),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FunctClass {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FunctClass`.
pub mod funct_class {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<param::Ref>,
    #[prost(message, optional, tag = "3")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(enumeration = "response::ResponseType", tag = "2")]
    pub response_type: i32,
    #[prost(message, repeated, tag = "3")]
    pub params: ::prost::alloc::vec::Vec<param::Ref>,
    #[prost(message, optional, tag = "4")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResponseType {
        PosResponse = 0,
        NegResponse = 1,
        GlobalNegResponse = 2,
    }
    impl ResponseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PosResponse => "POS_RESPONSE",
                Self::NegResponse => "NEG_RESPONSE",
                Self::GlobalNegResponse => "GLOBAL_NEG_RESPONSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POS_RESPONSE" => Some(Self::PosResponse),
                "NEG_RESPONSE" => Some(Self::NegResponse),
                "GLOBAL_NEG_RESPONSE" => Some(Self::GlobalNegResponse),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdditionalAudience {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
}
/// Nested message and enum types in `AdditionalAudience`.
pub mod additional_audience {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagComm {
    #[prost(string, tag = "1")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, tag = "3")]
    pub semantic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub funct_class: ::core::option::Option<funct_class::Ref>,
    #[prost(message, optional, tag = "5")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
    #[prost(enumeration = "diag_comm::DiagClassType", optional, tag = "6")]
    pub diag_class_type: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "7")]
    pub pre_condition_state_refs: ::prost::alloc::vec::Vec<pre_condition_state_ref::Ref>,
    #[prost(message, repeated, tag = "8")]
    pub state_transition_refs: ::prost::alloc::vec::Vec<state_transition_ref::Ref>,
    #[prost(message, repeated, tag = "9")]
    pub protocols: ::prost::alloc::vec::Vec<protocol::Ref>,
    #[prost(message, optional, tag = "10")]
    pub audience: ::core::option::Option<audience::Ref>,
    #[prost(bool, optional, tag = "11")]
    pub is_mandatory: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12")]
    pub is_executable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "13")]
    pub is_final: ::core::option::Option<bool>,
}
/// Nested message and enum types in `DiagComm`.
pub mod diag_comm {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiagClassType {
        StartComm = 0,
        StopComm = 1,
        VariantIdentification = 2,
        ReadDynDefinedMessage = 3,
        DynDefMessage = 4,
        ClearDynDefMessage = 5,
    }
    impl DiagClassType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StartComm => "START_COMM",
                Self::StopComm => "STOP_COMM",
                Self::VariantIdentification => "VARIANT_IDENTIFICATION",
                Self::ReadDynDefinedMessage => "READ_DYN_DEFINED_MESSAGE",
                Self::DynDefMessage => "DYN_DEF_MESSAGE",
                Self::ClearDynDefMessage => "CLEAR_DYN_DEF_MESSAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START_COMM" => Some(Self::StartComm),
                "STOP_COMM" => Some(Self::StopComm),
                "VARIANT_IDENTIFICATION" => Some(Self::VariantIdentification),
                "READ_DYN_DEFINED_MESSAGE" => Some(Self::ReadDynDefinedMessage),
                "DYN_DEF_MESSAGE" => Some(Self::DynDefMessage),
                "CLEAR_DYN_DEF_MESSAGE" => Some(Self::ClearDynDefMessage),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagService {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub diag_comm: ::core::option::Option<DiagComm>,
    #[prost(message, optional, tag = "5")]
    pub request: ::core::option::Option<request::Ref>,
    #[prost(message, repeated, tag = "6")]
    pub pos_responses: ::prost::alloc::vec::Vec<response::Ref>,
    #[prost(message, repeated, tag = "7")]
    pub neg_responses: ::prost::alloc::vec::Vec<response::Ref>,
    #[prost(bool, optional, tag = "9")]
    pub is_cyclic: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub is_multiple: ::core::option::Option<bool>,
    #[prost(enumeration = "diag_service::Addressing", optional, tag = "11")]
    pub addressing: ::core::option::Option<i32>,
    #[prost(enumeration = "diag_service::TransmissionMode", optional, tag = "12")]
    pub transmission_mode: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "13")]
    pub com_param_refs: ::prost::alloc::vec::Vec<ComParamRef>,
}
/// Nested message and enum types in `DiagService`.
pub mod diag_service {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransmissionMode {
        SendOnly = 0,
        ReceiveOnly = 1,
        SendAndReceive = 2,
        SendOrReceive = 3,
    }
    impl TransmissionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SendOnly => "SEND_ONLY",
                Self::ReceiveOnly => "RECEIVE_ONLY",
                Self::SendAndReceive => "SEND_AND_RECEIVE",
                Self::SendOrReceive => "SEND_OR_RECEIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEND_ONLY" => Some(Self::SendOnly),
                "RECEIVE_ONLY" => Some(Self::ReceiveOnly),
                "SEND_AND_RECEIVE" => Some(Self::SendAndReceive),
                "SEND_OR_RECEIVE" => Some(Self::SendOrReceive),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Addressing {
        Functional = 0,
        Physical = 1,
        FunctionalOrPhysical = 2,
    }
    impl Addressing {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Functional => "FUNCTIONAL",
                Self::Physical => "PHYSICAL",
                Self::FunctionalOrPhysical => "FUNCTIONAL_OR_PHYSICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FUNCTIONAL" => Some(Self::Functional),
                "PHYSICAL" => Some(Self::Physical),
                "FUNCTIONAL_OR_PHYSICAL" => Some(Self::FunctionalOrPhysical),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgCode {
    #[prost(string, tag = "1")]
    pub code_file: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub encryption: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub syntax: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub revision: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub entrypoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub library: ::prost::alloc::vec::Vec<library::Ref>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JobParam {
    #[prost(string, tag = "1")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub long_name: ::core::option::Option<LongName>,
    /// only used in input params
    #[prost(string, optional, tag = "3")]
    pub physical_default_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub dop_base: ::core::option::Option<dop::Ref>,
    #[prost(string, optional, tag = "5")]
    pub semantic: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleEcuJob {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub diag_comm: ::core::option::Option<DiagComm>,
    #[prost(message, repeated, tag = "3")]
    pub prog_codes: ::prost::alloc::vec::Vec<ProgCode>,
    #[prost(message, repeated, tag = "4")]
    pub input_params: ::prost::alloc::vec::Vec<JobParam>,
    #[prost(message, repeated, tag = "5")]
    pub output_params: ::prost::alloc::vec::Vec<JobParam>,
    #[prost(message, repeated, tag = "6")]
    pub neg_output_params: ::prost::alloc::vec::Vec<JobParam>,
}
/// Nested message and enum types in `SingleEcuJob`.
pub mod single_ecu_job {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MatchingParameter {
    #[prost(string, tag = "1")]
    pub expected_value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub diag_service: ::core::option::Option<diag_service::Ref>,
    #[prost(message, optional, tag = "3")]
    pub out_param: ::core::option::Option<param::Ref>,
    #[prost(bool, optional, tag = "4")]
    pub use_physical_addressing: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantPattern {
    #[prost(message, repeated, tag = "1")]
    pub matching_parameter: ::prost::alloc::vec::Vec<MatchingParameter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagLayer {
    #[prost(string, tag = "1")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(message, repeated, tag = "3")]
    pub funct_classes: ::prost::alloc::vec::Vec<funct_class::Ref>,
    #[prost(message, repeated, tag = "4")]
    pub com_param_refs: ::prost::alloc::vec::Vec<ComParamRef>,
    #[prost(message, repeated, tag = "5")]
    pub diag_services: ::prost::alloc::vec::Vec<diag_service::Ref>,
    #[prost(message, repeated, tag = "6")]
    pub single_ecu_jobs: ::prost::alloc::vec::Vec<single_ecu_job::Ref>,
    #[prost(message, repeated, tag = "8")]
    pub state_charts: ::prost::alloc::vec::Vec<state_chart::Ref>,
    #[prost(message, repeated, tag = "9")]
    pub additional_audiences: ::prost::alloc::vec::Vec<additional_audience::Ref>,
    #[prost(message, optional, tag = "10")]
    pub sdgs: ::core::option::Option<sdgs::Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionalGroup {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub diag_layer: ::core::option::Option<DiagLayer>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variant {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub diag_layer: ::core::option::Option<DiagLayer>,
    #[prost(bool, tag = "3")]
    pub is_base_variant: bool,
    #[prost(message, repeated, tag = "4")]
    pub variant_pattern: ::prost::alloc::vec::Vec<VariantPattern>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComplexValue {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<complex_value::ComplexValueEntry>,
}
/// Nested message and enum types in `ComplexValue`.
pub mod complex_value {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComplexValueEntry {
        #[prost(oneof = "complex_value_entry::Value", tags = "1, 2")]
        pub value: ::core::option::Option<complex_value_entry::Value>,
    }
    /// Nested message and enum types in `ComplexValueEntry`.
    pub mod complex_value_entry {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(string, tag = "1")]
            SimpleValue(::prost::alloc::string::String),
            #[prost(message, tag = "2")]
            ComplexValue(super::super::ComplexValue),
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Protocol {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, optional, tag = "2")]
    pub diag_layer: ::core::option::Option<DiagLayer>,
    #[prost(message, optional, tag = "4")]
    pub com_param_spec: ::core::option::Option<ComParamSpec>,
    #[prost(message, optional, tag = "5")]
    pub prot_stack: ::core::option::Option<prot_stack::Ref>,
    #[prost(message, repeated, tag = "6")]
    pub parent_refs: ::prost::alloc::vec::Vec<protocol::Ref>,
}
/// Nested message and enum types in `Protocol`.
pub mod protocol {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComParamRef {
    #[prost(string, optional, tag = "1")]
    pub simple_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub complex_value: ::core::option::Option<ComplexValue>,
    #[prost(message, optional, tag = "3")]
    pub com_param: ::core::option::Option<com_param::Ref>,
    #[prost(message, optional, tag = "4")]
    pub protocol: ::core::option::Option<protocol::Ref>,
    #[prost(message, optional, tag = "5")]
    pub prot_stack: ::core::option::Option<prot_stack::Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComParam {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(enumeration = "com_param::ComParamType", tag = "2")]
    pub com_param_type: i32,
    #[prost(string, tag = "3")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, tag = "5")]
    pub param_class: ::prost::alloc::string::String,
    #[prost(enumeration = "com_param::StandardisationLevel", tag = "6")]
    pub cp_type: i32,
    #[prost(uint32, optional, tag = "7")]
    pub display_level: ::core::option::Option<u32>,
    #[prost(enumeration = "com_param::Usage", tag = "8")]
    pub cp_usage: i32,
    #[prost(oneof = "com_param::SpecificData", tags = "9, 10")]
    pub specific_data: ::core::option::Option<com_param::SpecificData>,
}
/// Nested message and enum types in `ComParam`.
pub mod com_param {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RegularComParam {
        #[prost(string, optional, tag = "1")]
        pub physical_default_value: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "2")]
        pub dop: ::core::option::Option<super::dop::Ref>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComplexComParam {
        #[prost(message, repeated, tag = "1")]
        pub com_params: ::prost::alloc::vec::Vec<Ref>,
        #[prost(message, repeated, tag = "2")]
        pub complex_physical_default_values: ::prost::alloc::vec::Vec<
            super::ComplexValue,
        >,
        #[prost(bool, optional, tag = "3")]
        pub allow_multiple_values: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ComParamType {
        Regular = 0,
        Complex = 1,
    }
    impl ComParamType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::Complex => "COMPLEX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "COMPLEX" => Some(Self::Complex),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StandardisationLevel {
        Standard = 0,
        OemSpecific = 1,
        Optional = 2,
        OemOptional = 3,
    }
    impl StandardisationLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Standard => "STANDARD",
                Self::OemSpecific => "OEM_SPECIFIC",
                Self::Optional => "OPTIONAL",
                Self::OemOptional => "OEM_OPTIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STANDARD" => Some(Self::Standard),
                "OEM_SPECIFIC" => Some(Self::OemSpecific),
                "OPTIONAL" => Some(Self::Optional),
                "OEM_OPTIONAL" => Some(Self::OemOptional),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Usage {
        EcuSoftware = 0,
        EcuComm = 1,
        Application = 2,
        Tester = 3,
    }
    impl Usage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EcuSoftware => "ECU_SOFTWARE",
                Self::EcuComm => "ECU_COMM",
                Self::Application => "APPLICATION",
                Self::Tester => "TESTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ECU_SOFTWARE" => Some(Self::EcuSoftware),
                "ECU_COMM" => Some(Self::EcuComm),
                "APPLICATION" => Some(Self::Application),
                "TESTER" => Some(Self::Tester),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SpecificData {
        #[prost(message, tag = "9")]
        Regular(RegularComParam),
        #[prost(message, tag = "10")]
        Complex(ComplexComParam),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhysicalDimension {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(int32, optional, tag = "4")]
    pub length_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub mass_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub time_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub current_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub temperature_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub molar_amount_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub luminous_intensity_exp: ::core::option::Option<i32>,
}
/// Nested message and enum types in `PhysicalDimension`.
pub mod physical_dimension {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnitGroup {
    #[prost(string, tag = "1")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(message, repeated, tag = "3")]
    pub unitrefs: ::prost::alloc::vec::Vec<unit::Ref>,
}
/// Nested message and enum types in `UnitGroup`.
pub mod unit_group {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnitGroupCategory {
        Country = 0,
        EquivUnits = 1,
    }
    impl UnitGroupCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Country => "COUNTRY",
                Self::EquivUnits => "EQUIV_UNITS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COUNTRY" => Some(Self::Country),
                "EQUIV_UNITS" => Some(Self::EquivUnits),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnitSpec {
    #[prost(message, repeated, tag = "1")]
    pub unit_groups: ::prost::alloc::vec::Vec<UnitGroup>,
    #[prost(message, repeated, tag = "2")]
    pub units: ::prost::alloc::vec::Vec<Unit>,
    #[prost(message, repeated, tag = "3")]
    pub physical_dimensions: ::prost::alloc::vec::Vec<PhysicalDimension>,
    #[prost(message, optional, tag = "4")]
    pub sdgs: ::core::option::Option<Sdgs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComParamSubSet {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(message, repeated, tag = "2")]
    pub com_params: ::prost::alloc::vec::Vec<com_param::Ref>,
    #[prost(message, repeated, tag = "3")]
    pub complex_com_params: ::prost::alloc::vec::Vec<com_param::Ref>,
    #[prost(message, repeated, tag = "4")]
    pub data_object_props: ::prost::alloc::vec::Vec<dop::Ref>,
    #[prost(message, optional, tag = "5")]
    pub unit_spec: ::core::option::Option<UnitSpec>,
}
/// Nested message and enum types in `ComParamSubSet`.
pub mod com_param_sub_set {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtStack {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, tag = "4")]
    pub pdu_protocol_type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub physical_link_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub comparam_sub_set_refs: ::prost::alloc::vec::Vec<com_param_sub_set::Ref>,
}
/// Nested message and enum types in `ProtStack`.
pub mod prot_stack {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComParamSpec {
    #[prost(message, repeated, tag = "1")]
    pub prot_stacks: ::prost::alloc::vec::Vec<prot_stack::Ref>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Library {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ObjectId>,
    #[prost(string, tag = "2")]
    pub short_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub long_name: ::core::option::Option<LongName>,
    #[prost(string, tag = "4")]
    pub code_file: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub encryption: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub syntax: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "7")]
    pub entry_point: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Library`.
pub mod library {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ref {
        #[prost(message, optional, tag = "1")]
        pub r#ref: ::core::option::Option<super::ObjectId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcuData {
    #[prost(string, tag = "31")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub ecu_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "32")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "ecu_data::FeatureFlag", repeated, tag = "33")]
    pub feature_flags: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "3")]
    pub funct_classes: ::prost::alloc::vec::Vec<FunctClass>,
    #[prost(message, repeated, tag = "4")]
    pub units: ::prost::alloc::vec::Vec<Unit>,
    #[prost(message, repeated, tag = "5")]
    pub dops: ::prost::alloc::vec::Vec<Dop>,
    #[prost(message, repeated, tag = "6")]
    pub tables: ::prost::alloc::vec::Vec<Table>,
    #[prost(message, repeated, tag = "34")]
    pub table_rows: ::prost::alloc::vec::Vec<TableRow>,
    #[prost(message, repeated, tag = "7")]
    pub params: ::prost::alloc::vec::Vec<Param>,
    #[prost(message, repeated, tag = "8")]
    pub requests: ::prost::alloc::vec::Vec<Request>,
    #[prost(message, repeated, tag = "9")]
    pub responses: ::prost::alloc::vec::Vec<Response>,
    #[prost(message, repeated, tag = "10")]
    pub diag_coded_types: ::prost::alloc::vec::Vec<DiagCodedType>,
    #[prost(message, repeated, tag = "11")]
    pub sds: ::prost::alloc::vec::Vec<Sd>,
    #[prost(message, repeated, tag = "12")]
    pub sdgs: ::prost::alloc::vec::Vec<Sdg>,
    #[prost(message, repeated, tag = "13")]
    pub sdgss: ::prost::alloc::vec::Vec<Sdgs>,
    #[prost(message, repeated, tag = "14")]
    pub diag_services: ::prost::alloc::vec::Vec<DiagService>,
    #[prost(message, repeated, tag = "15")]
    pub single_ecu_jobs: ::prost::alloc::vec::Vec<SingleEcuJob>,
    #[prost(message, repeated, tag = "16")]
    pub variants: ::prost::alloc::vec::Vec<Variant>,
    #[prost(message, repeated, tag = "17")]
    pub functional_groups: ::prost::alloc::vec::Vec<FunctionalGroup>,
    #[prost(message, repeated, tag = "18")]
    pub dtcs: ::prost::alloc::vec::Vec<Dtc>,
    #[prost(message, repeated, tag = "19")]
    pub audiences: ::prost::alloc::vec::Vec<Audience>,
    #[prost(message, repeated, tag = "20")]
    pub additional_audiences: ::prost::alloc::vec::Vec<AdditionalAudience>,
    #[prost(message, repeated, tag = "21")]
    pub states: ::prost::alloc::vec::Vec<State>,
    #[prost(message, repeated, tag = "22")]
    pub pre_condition_state_refs: ::prost::alloc::vec::Vec<PreConditionStateRef>,
    #[prost(message, repeated, tag = "23")]
    pub state_transitions: ::prost::alloc::vec::Vec<StateTransition>,
    #[prost(message, repeated, tag = "24")]
    pub state_transition_refs: ::prost::alloc::vec::Vec<StateTransitionRef>,
    #[prost(message, repeated, tag = "25")]
    pub state_charts: ::prost::alloc::vec::Vec<StateChart>,
    #[prost(message, repeated, tag = "26")]
    pub com_params: ::prost::alloc::vec::Vec<ComParam>,
    #[prost(message, repeated, tag = "27")]
    pub com_param_sub_sets: ::prost::alloc::vec::Vec<ComParamSubSet>,
    #[prost(message, repeated, tag = "28")]
    pub protocols: ::prost::alloc::vec::Vec<Protocol>,
    #[prost(message, repeated, tag = "29")]
    pub prot_stacks: ::prost::alloc::vec::Vec<ProtStack>,
    #[prost(message, repeated, tag = "30")]
    pub libraries: ::prost::alloc::vec::Vec<Library>,
}
/// Nested message and enum types in `EcuData`.
pub mod ecu_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeatureFlag {
        Reserved = 0,
    }
    impl FeatureFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reserved => "RESERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVED" => Some(Self::Reserved),
                _ => None,
            }
        }
    }
}
